<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Infer.Runtime</name>
    </assembly>
    <members>
        <member name="T:MicrosoftResearch.Infer.Factors.VectorFromArrayOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.Vector.FromArray(System.Double[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,System.Double[])">
            <summary>
            Evidence message for EP
            </summary>
            <param name="vector">Constant value for 'fromArray'.</param>
            <param name="array">Constant value for 'data'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(fromArray,data))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="vector">Constant value for 'fromArray'.</param>
            <param name="array">Incoming message from 'data'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(data) p(data) factor(fromArray,data))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="vector">Constant value for 'fromArray'.</param>
            <param name="array">Incoming message from 'data'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(data) p(data) factor(fromArray,data))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="vector">Incoming message from 'fromArray'.</param>
            <param name="to_vector">Outgoing message to 'vector'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(fromArray) p(fromArray) factor(fromArray,data))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="vector">Incoming message from 'fromArray'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(fromArray) p(fromArray) factor(fromArray,data) / sum_fromArray p(fromArray) messageTo(fromArray))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(fromArray,data))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.VectorAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'fromArray'
            </summary>
            <param name="array">Incoming message from 'data'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'fromArray' as the random arguments are varied.
            The formula is <c>proj[p(fromArray) sum_(data) p(data) factor(fromArray,data)]/p(fromArray)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.VectorAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'fromArray'
            </summary>
            <param name="array">Incoming message from 'data'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'fromArray' as the random arguments are varied.
            The formula is <c>proj[sum_(data) p(data) factor(fromArray,data)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian,``0)">
            <summary>
            EP message to 'data'
            </summary>
            <param name="vector">Incoming message from 'fromArray'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="array">Incoming message from 'data'.</param>
            <param name="to_vector">Outgoing message to 'vector'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'data' as the random arguments are varied.
            The formula is <c>proj[p(data) sum_(fromArray) p(fromArray) factor(fromArray,data)]/p(data)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="vector"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            VMP message to 'data'
            </summary>
            <param name="vector">Incoming message from 'fromArray'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="array">Incoming message from 'data'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'data' with 'fromArray' integrated out.
            The formula is <c>sum_fromArray p(fromArray) factor(fromArray,data)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="vector"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Maths.Vector,``0)">
            <summary>
            EP message to 'data'
            </summary>
            <param name="vector">Constant value for 'fromArray'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'data' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorFromArrayOp.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Maths.Vector,``0)">
            <summary>
            VMP message to 'data'
            </summary>
            <param name="vector">Constant value for 'fromArray'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'data' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.SampleAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.MeanAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.PrecisionAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'precision'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing EP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'precision' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(mean) p(mean) factor(sample,mean,precision)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(sample) p(sample) factor(sample,mean,precision)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,precision))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,mean) p(sample,mean) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(precision) p(precision) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.TPdfLn(System.Double,System.Double,System.Double)">
            <summary>
            Logarithm of Student T density.
            </summary>
            <param name="x">sample</param>
            <param name="v">variance parameter</param>
            <param name="n">degrees of freedom plus 1</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,mean) p(sample,mean) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOpBase.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(precision) p(precision) factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Gaussian(System.Double,System.Double)"/> and <see cref="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogFactorValue(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for Gibbs
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's value at the given arguments</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GaussianOp.ForceProper">
            <summary>
            Static flag to force a proper distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GaussianOp.QuadratureNodeCount">
            <summary>
            Number of quadrature nodes to use for computing the messages.
            Reduce this number to save time in exchange for less accuracy.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(mean,precision) p(mean,precision) factor(sample,mean,precision)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(precision) p(precision) factor(sample,mean,precision)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(sample,precision) p(sample,precision) factor(sample,mean,precision)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(precision) p(precision) factor(sample,mean,precision)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'precision'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'precision' as the random arguments are varied.
            The formula is <c>proj[p(precision) sum_(sample,mean) p(sample,mean) factor(sample,mean,precision)]/p(precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.QuadratureNodesAndWeights(MicrosoftResearch.Infer.Distributions.Gamma,System.Double[],System.Double[])">
            <summary>
            Quadrature nodes for Gamma expectations
            </summary>
            <param name="precision">'precision' message</param>
            <param name="nodes">Place to put the nodes</param>
            <param name="logWeights">Place to put the log-weights</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(mean,precision) p(mean,precision) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,precision) p(sample,precision) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,mean,precision) p(sample,mean,precision) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(mean,precision) p(mean,precision) factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,mean,precision) p(sample,mean,precision) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,precision) p(sample,precision) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(mean,precision) p(mean,precision) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(sample,precision) p(sample,precision) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(precision) p(precision) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(precision) p(precision) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'precision'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing VMP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'precision' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'precision'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'precision'.
            The formula is <c>exp(sum_(sample,mean) p(sample,mean) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'precision'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing VMP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'precision'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'precision'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'precision'.
            The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,mean,precision) p(sample,mean,precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(precision) p(precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(mean) p(mean) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(mean,precision) p(mean,precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,precision) p(sample,precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,mean) p(sample,mean) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double,System.Double)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianOp_Slow">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Gaussian(System.Double,System.Double)"/> and <see cref="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp_Slow.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(sample,precision) p(sample,precision) factor(sample,mean,precision)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianOp_Laplace">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Gaussian(System.Double,System.Double)"/> and <see cref="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.EnumSupport">
            <summary>
            Provides factors and operators for using Enum types.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumSupport.EnumToInt``1(``0)">
            <summary>
            Converts an Enum to an Int
            </summary>
            <param name="en"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumSupport.DiscreteEnum``1(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Samples an enum value from a discrete enum distribution.
            </summary>
            <typeparam name="TEnum">The type of the enum to sample</typeparam>
            <param name="probs">Vector of the probability of each Enum value, in order</param>
            <returns>An enum sampled from the distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumSupport.AreEqual``1(``0,``0)">
            <summary>
            Test if two enums are equal.
            </summary>
            <param name="a">First integer</param>
            <param name="b">Second integer</param>
            <returns>True if a==b.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.EnumToIntOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.EnumSupport.EnumToInt``1(``0)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogAverageFactor(System.Int32,`0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Int">Constant value for 'Int'.</param>
            <param name="Enum">Constant value for 'Enum'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Int,Enum))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogEvidenceRatio(System.Int32,`0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Int">Constant value for 'Int'.</param>
            <param name="Enum">Constant value for 'Enum'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Int,Enum))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.AverageLogFactor(System.Int32,`0)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="Int">Constant value for 'Int'.</param>
            <param name="Enum">Constant value for 'Enum'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Int,Enum))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Int">Constant value for 'Int'.</param>
            <param name="Enum">Incoming message from 'Enum'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Enum) p(Enum) factor(Int,Enum))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Int">Constant value for 'Int'.</param>
            <param name="Enum">Incoming message from 'Enum'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Enum) p(Enum) factor(Int,Enum))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,`0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Int">Incoming message from 'Int'.</param>
            <param name="Enum">Constant value for 'Enum'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Int) p(Int) factor(Int,Enum))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Int">Incoming message from 'Int'.</param>
            <param name="Enum">Incoming message from 'Enum'.</param>
            <param name="to_Int">Outgoing message to 'Int'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Int,Enum) p(Int,Enum) factor(Int,Enum))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Int">Incoming message from 'Int'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Int) p(Int) factor(Int,Enum) / sum_Int p(Int) messageTo(Int))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Int,Enum))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.IntAverageConditional(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'Int'
            </summary>
            <param name="Enum">Incoming message from 'Enum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Int' as the random arguments are varied.
            The formula is <c>proj[p(Int) sum_(Enum) p(Enum) factor(Int,Enum)]/p(Int)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Enum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.EnumAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            EP message to 'Enum'
            </summary>
            <param name="Int">Incoming message from 'Int'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Enum' as the random arguments are varied.
            The formula is <c>proj[p(Enum) sum_(Int) p(Int) factor(Int,Enum)]/p(Enum)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Int"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.EnumAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            EP message to 'Enum'
            </summary>
            <param name="Int">Constant value for 'Int'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Enum' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.IntAverageLogarithm(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'Int'
            </summary>
            <param name="Enum">Incoming message from 'Enum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Int' as the random arguments are varied.
            The formula is <c>proj[sum_(Enum) p(Enum) factor(Int,Enum)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Enum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.EnumAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            VMP message to 'Enum'
            </summary>
            <param name="Int">Incoming message from 'Int'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Enum' with 'Int' integrated out.
            The formula is <c>sum_Int p(Int) factor(Int,Enum)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Int"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.EnumAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            VMP message to 'Enum'
            </summary>
            <param name="Int">Constant value for 'Int'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Enum' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.EnumSupport.DiscreteEnum``1(MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
            <remarks>
            This class provides operators which have Enum arguments.  
            The rest are provided by DiscreteFromDirichlet.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.LogAverageFactor(`0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'Sample'.</param>
            <param name="probs">Incoming message from 'Probs'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Probs) p(Probs) factor(Sample,Probs))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.LogAverageFactor(`0,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'Sample'.</param>
            <param name="probs">Constant value for 'Probs'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Sample,Probs))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.AverageLogFactor(`0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'Sample'.</param>
            <param name="probs">Incoming message from 'Probs'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(Probs) p(Probs) log(factor(Sample,Probs))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.AverageLogFactor(`0,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'Sample'.</param>
            <param name="probs">Constant value for 'Probs'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Sample,Probs))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.LogEvidenceRatio(`0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'Sample'.</param>
            <param name="probs">Incoming message from 'Probs'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Probs) p(Probs) factor(Sample,Probs))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.LogEvidenceRatio(`0,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'Sample'.</param>
            <param name="probs">Constant value for 'Probs'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Sample,Probs))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.ProbsAverageConditional(`0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'Probs'
            </summary>
            <param name="sample">Constant value for 'Sample'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Probs' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichletOp`1.ProbsAverageLogarithm(`0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'Probs'
            </summary>
            <param name="sample">Constant value for 'Sample'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Probs' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.EnumSupport.AreEqual``1(``0,``0)"/>, given random arguments to the function.
            </summary>
            <remarks>This class only implements enum-specific overloads that are not provided by DiscreteAreEqualOp<para></para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            EP message to 'a'
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(areEqual) p(areEqual) factor(areEqual,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AAverageConditional(System.Boolean,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            EP message to 'a'
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AAverageLogarithm(System.Boolean,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' with 'areEqual' integrated out.
            The formula is <c>sum_areEqual p(areEqual) factor(areEqual,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            EP message to 'b'
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(areEqual) p(areEqual) factor(areEqual,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.BAverageConditional(System.Boolean,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            EP message to 'b'
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' with 'areEqual' integrated out.
            The formula is <c>sum_areEqual p(areEqual) factor(areEqual,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.BAverageLogarithm(System.Boolean,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AreEqualAverageConditional(`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            EP message to 'areEqual'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'areEqual' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'areEqual' as the random arguments are varied.
            The formula is <c>proj[p(areEqual) sum_(b) p(b) factor(areEqual,a,b)]/p(areEqual)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},`0)">
            <summary>
            EP message to 'areEqual'
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'areEqual' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'areEqual' as the random arguments are varied.
            The formula is <c>proj[p(areEqual) sum_(a) p(a) factor(areEqual,a,b)]/p(areEqual)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AreEqualAverageLogarithm(`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            VMP message to 'areEqual'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'areEqual' as the random arguments are varied.
            The formula is <c>proj[sum_(b) p(b) factor(areEqual,a,b)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},`0)">
            <summary>
            VMP message to 'areEqual'
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'areEqual' as the random arguments are varied.
            The formula is <c>proj[sum_(a) p(a) factor(areEqual,a,b)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,`0,`0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(areEqual) p(areEqual) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogAverageFactor(System.Boolean,`0,`0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogAverageFactor(System.Boolean,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},`0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogEvidenceRatio(System.Boolean,`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="to_B">Outgoing message to 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(areEqual,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumAreEqualOp`1.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},`0,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="to_A">Outgoing message to 'A'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(areEqual,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CountTrueOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.CountTrue(System.Boolean[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.PoissonBinomialTableInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            Initialize the buffer 'PoissonBinomialTable'.
            </summary>
            <param name="array">Incoming message from 'array'.</param>
            <returns>Initial value of buffer 'PoissonBinomialTable'.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.PoissonBinomialTable(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            Update the buffer 'PoissonBinomialTable'.
            </summary>
            <param name="array">Incoming message from 'array'.</param>
            <returns>Updated value of buffer 'PoissonBinomialTable'.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.CountAverageConditional(System.Double[0:,0:])">
            <summary>
            Compute EP message to 'count'.
            </summary>
            <param name="poissonBinomialTable">Buffer 'poissonBinomialTable'.</param>
            <returns>Outgoing message to 'count'.</returns>
            <remarks><para>
            Marginal distribution of count is known as Poisson Binomial.
            It can be found in O(n^2) time using dynamic programming, where n is the length of the array.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.ArrayAverageConditional``1(``0,MicrosoftResearch.Infer.Distributions.Discrete,System.Double[0:,0:],``0)">
            <summary>
            Compute EP message to 'array'.
            </summary>
            <typeparam name="TBernoulliArray">Type of messages from/to 'array'.</typeparam>
            <param name="array">Incoming message from 'array'.</param>
            <param name="count">Incoming message from 'count'.</param>
            <param name="poissonBinomialTable">Buffer 'poissonBinomialTable'.</param>
            <param name="result">Modified to contain the outgoing message to 'array'.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            Poison Binomial for a given list of Bernoulli random variables with one variable excluded can be computed
            in linear time given Poisson Binomial for the whole list of items computed in a forward pass, as well as a special table
            containing averaged Poisson Binomial, which can be computed in a backward pass.
            Both tables can be computed in O(n^2) time, where n is a size of the list, so the time complexity of this message operator
            is also O(n^2).
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.ArrayAverageConditional``1(``0,System.Int32,System.Double[0:,0:],``0)">
            <summary>
            Compute EP message to 'array'.
            </summary>
            <typeparam name="TBernoulliArray">Type of messages from/to 'array'.</typeparam>
            <param name="array">Incoming message from 'array'.</param>
            <param name="count">Constant value of 'count'.</param>
            <param name="poissonBinomialTable">Buffer 'poissonBinomialTable'.</param>
            <param name="result">Modified to contain the outgoing message to 'array'.</param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="count">Incoming message from 'count'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(count) p(count) factor(count,array) / sum_count p(count) messageTo(count))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="count"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.LogEvidenceRatio(System.Int32,System.Double[0:,0:])">
            <summary>
            Evidence message for EP
            </summary>
            <param name="count">Constant value for 'count'.</param>
            <param name="poissonBinomialTable">Buffer 'poissonBinomialTable'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(count,array))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.LogEvidenceRatio(System.Int32,System.Boolean[])">
            <summary>
            Evidence message for EP
            </summary>
            <param name="count">Constant value for 'count'.</param>
            <param name="array">Constant value for 'array'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(count,array))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.PoissonBinomialForwardPass(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            Compute Poisson Binomial table for a given list of Bernoulli-distributed random variables in a forward pass.
            </summary>
            <param name="array">List of Bernoulli random variables.</param>
            <returns>Table A, such that A[i, j] = P(sum(<paramref name="array"/>[1], ..., <paramref name="array"/>[i]) = j).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CountTrueOp.AveragedPoissonBinomialBackwardPassTableRows(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Enumerate rows of averaged Poisson Binomial table for a given list of Bernoulli-distributed random variables in a backward pass.
            </summary>
            <param name="array">List of Bernoulli random variables.</param>
            <param name="averager">Distribution over sum of values in <paramref name="array"/> used to average the Poisson Binomial.</param>
            <returns>
            <para>
            Rows of table A, such that A[i, j] =
            \sum_c P(<paramref name="averager"/> = c) P(sum(<paramref name="array"/>[i + 1], ..., <paramref name="array"/>[n]) + j = c).
            Rows are returned last-to-first, the very first row is omitted.
            </para>
            </returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseGammaList">
            <summary>
            Represents a sparse list of Gamma distributions, optimised for the case where many share 
            the same parameterisation.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1">
            <summary>
            Approximate Sparse List.
            </summary>
            <typeparam name="T">List element type. Must implement <see cref="T:MicrosoftResearch.Infer.Maths.Diffable"/>.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.SparseList`1">
            <summary>
            A list which is optimised for the case where most of its elements share a common value.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ISparseList`1">
            <summary>
            Exposes sparse lists. Inherits from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
            <typeparam name="T">Element type</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ISparseEnumerable`1">
            <summary>
            Sparsely enumerable
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ISparseEnumerable`1.GetSparseEnumerator">
            <summary>
            Returns a sparse enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.FromSize(System.Int32)">
            <summary>
            Create a sparse list of given length with elements all equal
            to the default value for the element type
            </summary>
            <param name="count">Number of elements in the list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Constant(System.Int32,`0)">
            <summary>
            Create a sparse list of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in the list</param>
            <param name="value">Value for each element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Copy(System.Collections.Generic.IList{`0})">
            <summary>
            Creator a sparse list as a copy of another list (which may not be sparse)
            </summary>
            <param name="that">The source list - can be dense or sparse</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.FromSparseValues(System.Int32,`0,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{`0}})">
            <summary>
            Constructs a sparse list from a sorted list of sparse elements.
            </summary>
            <param name="count">Count for result</param>
            <param name="commonValue">Common value</param>
            <param name="sortedSparseValues">Sorted list of sparse elements</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.#ctor">
            <summary>
            Null constructor.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.#ctor(System.Int32)">
            <summary>
            Constructs a sparse list with the given number of elements.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.#ctor(System.Int32,`0)">
            <summary>
            Constructs a sparse list of a given length and assigns all elements the given value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.#ctor(System.Int32,`0,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{`0}})">
            <summary>
            Constructs a sparse list of a given length and assigns all elements the given value, except
            for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.#ctor(MicrosoftResearch.Infer.Collections.SparseList{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that">the sparse list to copy into this new sparse list</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.GetSparseIndex(System.Int32)">
            <summary>
            Gets the index into the sparse values array corresponding to an element index.
            If there is no sparse value at that index, returns the binary complement of the 
            index in the sparse array where such an element should be inserted to retain the
            sort order of the sparse array.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.GetFirstCommonIndex">
            <summary>
            Gets the dense index of the first common element.
            </summary>
            <returns>Returns the dense index of the first common element or -1 if there are no common elements</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.GetEnumerator">
            <summary>
            Gets a typed enumerator which yields the list elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator which yields the list elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetAllElementsTo(`0)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetTo(System.Collections.Generic.IList{`0})">
            <summary>
            Copies values from another list.
            </summary>
            <param name="that"></param>
            <remarks> The source list can be dense, in which case 
            default(T) is used as the common value.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.CheckCompatible``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>
            Checks that a given list is the same size as this list.
            Throws an exception if not with the given string
            </summary>
            <param name="that">The list to check</param>
            <param name="paramName"></param>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetTo(MicrosoftResearch.Infer.Collections.SparseList{`0})">
            <summary>
            Copies values from a sparse list to this sparse list.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetTo(System.Collections.Generic.IList{`0},`0)">
            <summary>
            Copies values from a list which must have the same size as this list,
            using the specified common value.
            </summary>
            <param name="dlist">The list to copy from</param>
            <param name="commonValue">Common value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Clone">
            <summary>
            Clones this list - return as a sparse list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.System#ICloneable#Clone">
            <summary>
            Clones this list - return as an object
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another (list) object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.EqualsAll(`0)">
            <summary>
            Tests if all elements are equal to the given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.All(System.Converter{`0,System.Boolean})">
            <summary>
            Tests if all elements in the list satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Any(System.Converter{`0,System.Boolean})">
            <summary>
            Tests if any elements in the list satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.IndexOfAll(System.Converter{`0,System.Boolean})">
            <summary>
            Returns an enumeration of the indices of all elements which satisfy the specified condition.
            Indices are returned in sorted order.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Reduce``1(``0,System.Func{``0,`0,``0})">
            <summary>
            Reduce method. Operates on this list
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <returns></returns>
            <remarks>This method does not take advantage of this list's sparseness.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Reduce``1(``0,System.Func{``0,`0,``0},System.Func{``0,`0,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of sparse structure. Operates on this list
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
            <remarks>This method does not take advantage of this list's sparseness.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Reduce``2(``0,MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},System.Func{``0,`0,``1,``0},System.Func{``0,`0,``1,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of sparse structure. Operates on this list
            and another sparse list
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">The other sparse list</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Reduce``3(``0,MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``2},System.Func{``0,`0,``1,``2,``0},System.Func{``0,`0,``1,``2,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of sparse structure. Operates on this list
            and two other sparse lists
            </summary>
            <param name="initial">Initial value</param>
            <param name="b">A second sparse list</param>
            <param name="c">A third sparse list</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Reduce``2(``0,System.Collections.Generic.IEnumerable{``1},System.Func{``0,`0,``1,``0})">
            <summary>
            Reduce method. Operates on this list and another list.
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">A second list</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
            <remarks>This method does not take advantage of this list's sparseness.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Reduce``3(``0,System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``2},System.Func{``0,`0,``1,``2,``0})">
            <summary>
            Reduce method. Operates on this list and two other lists.
            </summary>
            <param name="initial">Initial value</param>
            <param name="a">A second list</param>
            <param name="b">A third list</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="a"/> and <paramref name="b"/></param>
            <returns></returns>
            <remarks>This method does not take advantage of this list's sparseness.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Contains(`0)">
            <summary>
            Returns true if this list contains the specified value
            </summary>
            <param name="value">The value to test for</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.IndexOf(`0)">
            <summary>
            Returns the index of the first occurence of the given value in the list.
            Returns -1 if the value is not in the list
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the list</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies this sparse list to the given array starting at the specified index
            in the target array
            </summary>
            <param name="array">The target array</param>
            <param name="index">The start index in the target array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Insert(System.Int32,`0)">
            <summary>
            Not implemented
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.RemoveAt(System.Int32)">
            <summary>
            Not implemented
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Add(`0)">
            <summary>
            Not implemented
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Clear">
            <summary>
            Clears this list, setting it to zero length.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.Remove(`0)">
            <summary>
            Not implemented
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.System#Collections#IList#Add(System.Object)">
            <summary>
            Not implemented
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Not implemented
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Not implemented
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.ToArray``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates an array from the list
            </summary>
            <typeparam name="T2"></typeparam>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``1(MicrosoftResearch.Infer.Collections.SparseList{``0},System.Func{``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of another sparse list
            </summary>
            <param name="fun">The function which maps from type T2 to type T</param>
            <param name="that">The other list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``1(MicrosoftResearch.Infer.Collections.ISparseEnumerable{``0},System.Func{``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of a sparse collection
            </summary>
            <param name="fun">The function which maps from type T2 to type T</param>
            <param name="that">The other list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of a collection
            </summary>
            <param name="fun">The function which maps from type T2 to type T</param>
            <param name="that">The other list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``2(MicrosoftResearch.Infer.Collections.SparseList{``0},MicrosoftResearch.Infer.Collections.SparseList{``1},System.Func{``0,``1,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of two other sparse lists
            </summary>
            <param name="fun">The function which maps two elements to an element of this list</param>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <returns></returns>
            <remarks>Assumes the lists are all the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``2(MicrosoftResearch.Infer.Collections.ISparseEnumerable{``0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},System.Func{``0,``1,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of two other sparse lists
            </summary>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <param name="fun">The function which maps two elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,`0})">
            <summary>
            Sets the elements of this list to a function of the elements of two collections
            </summary>
            <param name="fun">The function which maps the two elements of the other lists to an element of this list</param>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``3(MicrosoftResearch.Infer.Collections.ISparseEnumerable{``0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``2},System.Func{``0,``1,``2,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of three sparse collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="fun">The function which maps three elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of three sparse collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="fun">The function which maps three elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``4(MicrosoftResearch.Infer.Collections.ISparseList{``0},MicrosoftResearch.Infer.Collections.ISparseList{``1},MicrosoftResearch.Infer.Collections.ISparseList{``2},MicrosoftResearch.Infer.Collections.ISparseList{``3},System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of three other collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="d">The fourth collection</param>
            <param name="fun">The function which maps four elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunction``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of four sparse collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="d">The fourth collection</param>
            <param name="fun">The function which maps four elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.SetToFunctionInPlace``1(MicrosoftResearch.Infer.Collections.SparseList{``0},System.Func{`0,``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of this sparse list and another sparse list
            x = fun(x,b)
            </summary>
            <param name="fun">The function which maps (T,T1) to T</param>
            <param name="b">The other sparse list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.ToString">
            <summary>
            Converts this sparse list into a human readable string
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.ToString(System.String)">
            <summary>
            String representation of this list with a specified delimiter
            </summary>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.ToArray">
            <summary>
            Converts this sparse list to an array
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.ToList">
            <summary>
            Converts this sparse list to an ordinary non-sparse list
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseList`1.GetSparseEnumerator">
            <summary>
            Gets a sparse enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.Sparsity">
            <summary>
            The <see cref="P:MicrosoftResearch.Infer.Collections.SparseList`1.Sparsity"/> specification of this list.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.SparseValues">
            <summary>
            A list of the value and indices of elements which may not have the common value 
            (although they are not precluded from doing so).
            This list is kept sorted by index to allow efficient operations on the sparse list.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.CommonValue">
            <summary>
            The value of all elements not mentioned explicitly as sparse values.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.Count">
            <summary>
            Get or set the number of elements in this list.  Set the number of elements
            will grow or shrink the list accordingly.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.SparseCount">
            <summary>
            The number of elements not equal to the common value
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.Item(System.Int32)">
            <summary>Gets or sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.HasCommonElements">
            <summary>
            Returns true if there is at least one element which has the common value.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseList`1.IsReadOnly">
            <summary>
            Sparse lists are not read only.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.DefaultTolerance">
            <summary>
            The default tolerance for the approximate sparse list
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.FromSize(System.Int32,System.Double)">
            <summary>
            Create a sparse list of given length with elements all equal
            to the default value for the element type
            </summary>
            <param name="count">Number of elements in the list</param>
            <param name="tolerance">The tolerance for the approximation</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.Constant(System.Int32,`0,System.Double)">
            <summary>
            Create a sparse list of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in the list</param>
            <param name="value">Value for each element</param>
            <param name="tolerance">The tolerance for the approximation</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.FromSparseValues(System.Int32,`0,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{`0}},System.Double)">
            <summary>
            Constructs a sparse list from a sorted list of sparse elements.
            </summary>
            <param name="count">Count for result</param>
            <param name="commonValue">Common value</param>
            <param name="sortedSparseValues">Sorted list of sparse elements</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor">
            <summary>
            Null constructor.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Int32)">
            <summary>
            Constructs an approximate sparse list with the given number of elements
            and with default tolerance.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Int32,`0)">
            <summary>
            Constructs a sparse list of a given length and assigns all elements the given value.
            The tolerance is set to the default value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Int32,`0,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{`0}})">
            <summary>
            Constructs a sparse list of a given length and assigns all elements the given value, except
            for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            The tolerance is set to the default value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(MicrosoftResearch.Infer.Collections.SparseList{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that">the sparse list to copy into this new sparse list</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Double)">
            <summary>
            Constructs an approximate sparse list with the given tolerance
            </summary>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs an approximate sparse list with the given number of elements
            and with the given tolerance.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Int32,`0,System.Double)">
            <summary>
            Constructs a sparse list of a given length and assigns all elements the given value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(System.Int32,`0,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{`0}},System.Double)">
            <summary>
            Constructs a sparse list of a given length and assigns all elements the given value, except
            for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.#ctor(MicrosoftResearch.Infer.Collections.SparseList{`0},System.Double)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that">the sparse list to copy into this new sparse list</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetTo(MicrosoftResearch.Infer.Collections.ApproximateSparseList{`0})">
            <summary>
            Copies values from a sparse list to this sparse list.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetTo(System.Collections.Generic.IList{`0},`0)">
            <summary>
            Copies values from a list which must have the same size as this list,
            using the specified common value.
            </summary>
            <param name="dlist">The list to copy from</param>
            <param name="commonValue">Common value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.Clone">
            <summary>
            Clones this list - return as a sparse list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``1(MicrosoftResearch.Infer.Collections.SparseList{``0},System.Func{``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of another sparse list
            </summary>
            <param name="fun">The function which maps from type T2 to type T</param>
            <param name="that">The other list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``1(MicrosoftResearch.Infer.Collections.ISparseEnumerable{``0},System.Func{``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of a sparse collection
            </summary>
            <param name="fun">The function which maps from type T2 to type T</param>
            <param name="that">The other list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of a collection
            </summary>
            <param name="fun">The function which maps from type T2 to type T</param>
            <param name="that">The other list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``2(MicrosoftResearch.Infer.Collections.SparseList{``0},MicrosoftResearch.Infer.Collections.SparseList{``1},System.Func{``0,``1,`0})">
            <summary>
            Sets the elements of this approximate sparse list to a function of the elements of
            two other sparse lists
            </summary>
            <param name="fun">The function which maps two elements to an element of this list</param>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <returns></returns>
            <remarks>Assumes the lists are all the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``2(MicrosoftResearch.Infer.Collections.ISparseEnumerable{``0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},System.Func{``0,``1,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of two other sparse lists
            </summary>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <param name="fun">The function which maps two elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,`0})">
            <summary>
            Sets the elements of this list to a function of the elements of two collections
            </summary>
            <param name="fun">The function which maps the two elements of the other lists to an element of this list</param>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``3(MicrosoftResearch.Infer.Collections.ISparseEnumerable{``0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``2},System.Func{``0,``1,``2,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of three sparse collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="fun">The function which maps three elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of three sparse collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="fun">The function which maps three elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``4(MicrosoftResearch.Infer.Collections.ISparseList{``0},MicrosoftResearch.Infer.Collections.ISparseList{``1},MicrosoftResearch.Infer.Collections.ISparseList{``2},MicrosoftResearch.Infer.Collections.ISparseList{``3},System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of three other collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="d">The fourth collection</param>
            <param name="fun">The function which maps four elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunction``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,`0})">
            <summary>
            Sets the elements of this sparse list to a function of the elements of four sparse collections
            </summary>
            <param name="a">The first collection</param>
            <param name="b">The second collection</param>
            <param name="c">The third collection</param>
            <param name="d">The fourth collection</param>
            <param name="fun">The function which maps four elements to an element of this list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.SetToFunctionInPlace``1(MicrosoftResearch.Infer.Collections.SparseList{``0},System.Func{`0,``0,`0})">
            <summary>
            Sets the elements of this approximate sparse list to a function of the elements
            of this sparse list and another sparse list x = fun(x,b)
            </summary>
            <param name="fun">The function which maps (T,T1) to T</param>
            <param name="b">The other sparse list</param>
            <returns></returns>
            <remarks>Assumes the lists are the same length</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.Tolerance">
            <summary>
            The tolerance for the approximation
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ApproximateSparseList`1.Item(System.Int32)">
            <summary>Gets or sets an element.</summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IDistribution`1">
            <summary>Distribution interface</summary>
            <typeparam name="T">The type of objects in the domain, e.g. Vector or Matrix.</typeparam>
            <remarks><para>
            T should generally have value semantics, i.e. it should override Equals to use value equality.
            Otherwise it implies a Distribution over references.
            </para><para>
            In addition to this interface, Distributions should override Equals to 
            use value equality.  
            A typical implementation of Equals is: <c>MaxDiff(that) == 0.0</c>
            </para><para>
            To be generally used by message-passing algorithms, a distribution should also implement the
            following interfaces:
            <c>SettableTo, SettableToProduct, SettableToRatio, SettableToPower, SettableToWeightedSum,
            CanGetLogAverageOf, CanGetAverageLog</c>
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.HasPoint`1">
            <summary>
            Whether the distribution supports being a point mass
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.HasPoint`1.Point">
            <summary>
            Access the location of a point mass.
            </summary>
            <remarks><para>
            If the distribution parameters do not represent a point mass, 
            getting this property returns an undefined value (if T is a ValueType) 
            or a storage area with undefined contents (if T is a reference type).
            It should not throw an exception.
            Setting Point will change the distribution into a point mass, overriding any other 
            property settings.
            Note: Point = Point does have an effect!
            </para><para>
            If T is a reference type, then the result is volatile.  
            Its contents expire upon invoking any subsequent distribution method.
            </para><para>
            Point is a property because it is expected that each distribution would have a 
            corresponding data field.  Accessing the Point should take constant time.
            </para></remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.HasPoint`1.IsPointMass">
            <summary>
            Gets whether the distribution parameters represent a point mass.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Diffable">
            <summary>
            Supports calculating the maximum difference between
            this instance and another object (not necessarily of the same type)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Diffable.MaxDiff(System.Object)">
            <summary>
            The maximum difference between this instance and the given
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SettableToUniform">
            <summary>
            Whether the distribution can be set to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SettableToUniform.SetToUniform">
            <summary>
            Set the distribution to be uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SettableToUniform.IsUniform">
            <summary>
            Ask whether the distribution instance is uniform
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogProb`1">
            <summary>
            Whether the distribution supports evaluation of its density
            </summary>
            <typeparam name="T">Domain type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogProb`1.GetLogProb(`0)">
            <summary>
            Evaluate the log of the density function at the specified domain value
            </summary>
            <param name="value">The value at which to calculate the density</param>
            <returns>The log density</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Sampleable`1">
            <summary>
            Whether the distribution supports sampling
            </summary>
            <typeparam name="T">The sample type (i.e. the domain type)</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Sampleable`1.Sample">
            <summary>
            Sample the distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Sampleable`1.Sample(`0)">
            <summary>
            Sample the distribution and provide a place to put the result.
            </summary>
            <param name="result">Where to put the result. This is ignored for value-type domains</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableTo`1">
            <summary>
            Supports setting an instance to a value
            </summary>
            <typeparam name="T">The type of value</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableTo`1.SetTo(`0)">
            <summary>
            Set the instance to have the same value as given
            </summary>
            <param name="value">The value to set to</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToProduct`1">
            <summary>
            Supports setting an instance to the product of two values of the same type
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToProduct`2">
            <summary>
            Supports setting an instance to the product of
            two values of different types
            </summary>
            <typeparam name="T">The first type</typeparam>
            <typeparam name="U">The second type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableToProduct`2.SetToProduct(`0,`1)">
            <summary>
            Set this to the product of a and b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToPower`1">
            <summary>
            Supports setting an instance to a value raised to a power
            </summary>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableToPower`1.SetToPower(`0,System.Double)">
            <summary>
            Set this to the given value raised to the given power
            </summary>
            <param name="value"></param>
            <param name="exponent"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToRatio`1">
            <summary>
            Supports setting an instance to the ratio of
            two values of the same type
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToRatio`2">
            <summary>
            Supports setting an instance to the ratio of
            two values of different types
            </summary>
            <typeparam name="T">The first type</typeparam>
            <typeparam name="U">The second type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableToRatio`2.SetToRatio(`0,`1,System.Boolean)">
            <summary>
            Set this to the ratio of a and b
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
            <param name="forceProper">If true, the result is modified to have parameters in a safe range</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToWeightedSum`1">
            <summary>
            Supports setting an instance to the weighted sum of
            two values of the same type
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableToWeightedSum`1.SetToSum(System.Double,`0,System.Double,`0)">
            <summary>
            Set the parameters to best match a mixture distribution.
            </summary>
            <param name="weight1">A finite nonnegative weight.</param>
            <param name="weight2">A finite nonnegative weight.</param>
            <param name="value1"></param>
            <param name="value2"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogAverageOf`1">
            <summary>
            Whether the distribution can compute the expectation of another distribution's value.
            </summary>
            <typeparam name="T">The other distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogAverageOf`1.GetLogAverageOf(`0)">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogAverageOfPower`1">
            <summary>
            Whether the distribution can compute the expectation of another distribution raised to a power.
            </summary>
            <typeparam name="T">The distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogAverageOfPower`1.GetLogAverageOfPower(`0,System.Double)">
            <summary>
            The log-integral of one distribution times another raised to a power.
            </summary>
            <param name="that">The other distribution</param>
            <param name="power">The exponent</param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*Math.Pow(that.Evaluate(x),power))</c></returns>
            <remarks>This is not the same as GetLogAverageOf(that^power) because it includes the normalization constant of that.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetAverageLog`1">
            <summary>
            Whether the distribution supports the expected logarithm of one instance under another
            </summary>
            <typeparam name="T">The distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetAverageLog`1.GetAverageLog(`0)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGammaList.DefaultTolerance">
            <summary>
            Default tolerance for sparsity approximation
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.#ctor(System.Int32)">
            <summary>
            Constructs a sparse Gamma with the specified number of elements
            all of which are set to uniform
            </summary>
            <param name="size">The size of the list</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.#ctor(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Constructs a sparse Gamma list of the given size, and assigns all
            elements to the specified common value
            </summary>
            <param name="size">The size of the list</param>
            <param name="commonValue">The common value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.#ctor(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{MicrosoftResearch.Infer.Distributions.Gamma}})">
            <summary>
            Constructs a sparse Gamma list of a given length and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list</param>
            <param name="commonValue">The common value</param>
            <param name="sortedSparseValues">The sorted list of non-common values</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.#ctor(MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.#ctor(System.Double)">
            <summary>
            Constructs a sparse Gamma list with the given tolerance
            </summary>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs a sparse Gamma with the specified number of elements
            all of which are set to uniform
            </summary>
            <param name="size">The size of the list</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.#ctor(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Constructs a sparse Gamma list of the given size, and assigns all
            elements to the specified common value
            </summary>
            <param name="size">The size of the list</param>
            <param name="commonValue">The common value</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.#ctor(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{MicrosoftResearch.Infer.Distributions.Gamma}},System.Double)">
            <summary>
            Constructs a sparse Gamma list of a given length and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list</param>
            <param name="commonValue">The common value</param>
            <param name="sortedSparseValues">The sorted list of non-common values</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromSize(System.Int32,System.Double)">
            <summary>
            Constructs a sparse Gamma with the specified number of elements
            all of which are set to uniform
            </summary>
            <param name="size"></param>
            <param name="tolerance">The tolerance for the approximation</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromGamma(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Constructs a sparse Gamma with the specified number of elements
            all of which are set to the specified Gamma
            </summary>
            <param name="size">Size</param>
            <param name="commonValue">The common value</param>
            <param name="tolerance">The tolerance for the approximation</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromSparseValues(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{MicrosoftResearch.Infer.Distributions.Gamma}},System.Double)">
            <summary>
            Returns a sparse Gamma list of a given length and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list</param>
            <param name="commonValue">The common value</param>
            <param name="sortedSparseValues">The sorted list of non-common values</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromMeanAndVariance(System.Int32,System.Double,System.Double,System.Double)">
             <summary>
            Creates a sparse Gamma list of a given size, with each
             element having a given mean and variance.
             </summary>
             <param name="size">The size of the list</param>
             <param name="mean">The desired mean.</param>
             <param name="variance">The desired variance.</param>
             <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromMeanAndMeanLog(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Creates a sparse Gamma list of a given size, with each
            element having a given mean and mean log.
            </summary>
            <param name="size">The size of the list</param>
            <param name="mean">Desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromLogMeanAndMeanLog(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Creates a sparse Gamma list of a given size, with each
            element having a given log mean and mean log.
            </summary>
            <param name="size">The size of the list</param>
            <param name="logMean">Log of desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndRate(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Creates a sparse Gamma list of a given size, with each
            element having a given shape and rate.
            </summary>
            <param name="size">The size of the list</param>
            <param name="shape">shape</param>
            <param name="rate">rate = 1/scale</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndRate(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Creates a sparse Gamma list of a given size with given shape and rate Vectors.
            </summary>
            <param name="shape">shape</param>
            <param name="rate">rate = 1/scale</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndScale(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Creates a sparse Gamma list of a given size, with each
            element having a given shape and scale.
            </summary>
            <param name="size">The size of the list</param>
            <param name="shape">shape</param>
            <param name="scale">scale</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndScale(MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector,System.Double)">
            <summary>
            Creates a sparse Gamma list of a given size with given shape and scale Vectors.
            </summary>
            <param name="shape">shape</param>
            <param name="scale">scale</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromNatural(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Creates a sparse Gamma list of a given size, with each
            element having the specified natural parameters
            </summary>
            <param name="size">The size of the list</param>
            <param name="shapeMinus1">shape - 1</param>
            <param name="rate">rate = 1/scale</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromSize(System.Int32)">
            <summary>
            Constructs a sparse Gamma with the specified number of elements
            all of which are set to uniform
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromGamma(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Constructs a sparse Gamma with the specified number of elements
            all of which are set to the specified Gamma
            </summary>
            <param name="size">Size</param>
            <param name="commonValue">The common value</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromSparseValues(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{MicrosoftResearch.Infer.Distributions.Gamma}})">
            <summary>
            Returns a sparse Gamma list of a given length and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list</param>
            <param name="commonValue">The common value</param>
            <param name="sortedSparseValues">The sorted list of non-common values</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromMeanAndVariance(System.Int32,System.Double,System.Double)">
             <summary>
            Creates a sparse Gamma list of a given size, with each
             element having a given mean and variance.
             </summary>
             <param name="size">The size of the list</param>
             <param name="mean">The desired mean.</param>
             <param name="variance">The desired variance.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromMeanAndMeanLog(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a sparse Gamma list of a given size, with each
            element having a given mean and mean log.
            </summary>
            <param name="size">The size of the list</param>
            <param name="mean">Desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromLogMeanAndMeanLog(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a sparse Gamma list of a given size, with each
            element having a given log mean and mean log.
            </summary>
            <param name="size">The size of the list</param>
            <param name="logMean">Log of desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndRate(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a sparse Gamma list of a given size, with each
            element having a given shape and rate.
            </summary>
            <param name="size">The size of the list</param>
            <param name="shape">shape</param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndRate(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a sparse Gamma list of a given size with given shape and rate Vectors.
            </summary>
            <param name="shape">shape</param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndScale(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a sparse Gamma list of a given size, with each
            element having a given shape and scale.
            </summary>
            <param name="size">The size of the list</param>
            <param name="shape">shape</param>
            <param name="scale">scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromShapeAndScale(MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Creates a sparse Gamma list of a given size with given shape and scale Vectors.
            </summary>
            <param name="shape">shape</param>
            <param name="scale">scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.FromNatural(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a sparse Gamma list of a given size, with each
            element having the specified natural parameters
            </summary>
            <param name="size">The size of the list</param>
            <param name="shapeMinus1">shape - 1</param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.MaxDiff(System.Object)">
            <summary>
            Returns the maximum difference between the parameters of this sparse Gamma list
            and another
            </summary>
            <param name="thatd">The other sparse Gamma list</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.SetToUniform">
            <summary>
            Sets this sparse Gamma list to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.IsUniform">
            <summary>
            Asks whether this sparse Gamma list is uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.GetLogProb(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Evaluates the log of the density function
            </summary>
            <param name="value">The point at which to evaluate the density</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.Sample">
            <summary>
            Samples from this sparse Gamma list
            </summary>
            <returns></returns>
            <remarks>This method is inefficient in that the result will be dense even though the return type is sparse.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.Sample(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Samples from this sparse Gamma list
            </summary>
            <param name="result">Where to put the result</param>
            <returns></returns>
            <remarks>This method is inefficient in that the result will be dense even though the return type is sparse.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.Sample(MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Samples from a list of Gamma distributions with the specified vectors
            of shapes and rates
            </summary>
            <param name="shapes">Vector of shapes</param>
            <param name="rates">Vector of rates</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.SetTo(MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Sets this sparse Gamma list to another sparse Gamma list
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.Clone">
            <summary>
            Clones this sparse Gamma list.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.SetToProduct(MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Sets this sparse Gamma list to the product of two other sparse Gamma lists
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.SetToPower(MicrosoftResearch.Infer.Distributions.SparseGammaList,System.Double)">
            <summary>
            Sets this sparse Gamma list to the power of another sparse Gamma list
            </summary>
            <param name="value"></param>
            <param name="exponent"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.SetToRatio(MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList,System.Boolean)">
            <summary>
            Sets this sparse Gamma list to the ratio of two other sparse Gamma lists
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.SparseGammaList,System.Double,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Creates a sparse Gamma list whose elements match the means and variances
            of the weighted sums of the elements of two other sparse Gamma lists.
            </summary>
            <param name="weight1">The first weight</param>
            <param name="value1">The first sparse Gamma list</param>
            <param name="weight2">The second weight</param>
            <param name="value2">The second sparse Gamma list</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Returns the log of the integral of the product of this sparse Gamma list and another sparse Gamma list
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.SparseGammaList,System.Double)">
            <summary>
            Returns the log of the integral of the product of this sparse Gamma list and another sparse Gamma list raised to a power
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGammaList.GetAverageLog(MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            The expected logarithm of that sparse Gamma list under this sparse Gamma list.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGammaList.Dimension">
            <summary>
            The dimension of the SparseGammaList domain
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGammaList.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGammaList.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.PointMass`1">
            <summary>
            A point mass, which is the 'distribution' you get for an observed variable.
            All the probability mass is at the point given by observed value.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetMean`1">
            <summary>
            Whether the distribution supports retrieval of a mean value
            </summary>
            <typeparam name="MeanType">Type of the mean value</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetMean`1.GetMean">
            <remarks><para>
            </para><para>
            This is not a property because it is not reasonable to expect that distributions
            would generally have their mean as a data member.  Computing the mean could take a long
            time for some distributions.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.#ctor">
            <summary>
            Parameterless constructor required for serialization 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.#ctor(`0)">
            <summary>
            Creates a point mass at the specified location.
            </summary>
            <param name="point">The location of the point mass.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.Create(`0)">
            <summary>
            Creates a point mass at the specified location.
            </summary>
            <param name="point">The location of the point mass.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.Clone">
            <summary>
            Creates a copy of the point mass.
            </summary>
            <returns>The new PointMass object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.MaxDiff(System.Object)">
            <summary>
            Returns 0 if the two distributions are the same, positive infinity otherwise.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetToUniform">
            <summary>
            Always throws an exception, since a PointMass cannot be set to uniform.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.IsUniform">
            <summary>
            Always returns false
            </summary>
            <returns>false</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.GetLogProb(`0)">
            <summary>
            Returns 0 if the value is at the point mass and negative infinity elsewhere.
            </summary>
            <param name="value">The value at which to compute the log probability.</param>
            <returns>0 or negative infinity</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.Sample">
            <summary>
            Returns the location of the point mass
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.Sample(`0)">
            <summary>
            Returns the location of the point mass
            </summary>
            <param name="result">Where to put the result</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.GetMean">
            <summary>
            Returns the location of the point mass
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetTo(MicrosoftResearch.Infer.Distributions.PointMass{`0})">
            <summary>
            Sets this point mass to that point mass
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetToProduct(MicrosoftResearch.Infer.Distributions.PointMass{`0},MicrosoftResearch.Infer.Distributions.PointMass{`0})">
            <summary>
            Throws an exception unless the two point masses are equal 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetToRatio(MicrosoftResearch.Infer.Distributions.PointMass{`0},MicrosoftResearch.Infer.Distributions.PointMass{`0},System.Boolean)">
            <summary>
            Not supported
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetToPower(MicrosoftResearch.Infer.Distributions.PointMass{`0},System.Double)">
            <summary>
            Sets to the value of the given point mass
            </summary>
            <param name="value"></param>
            <param name="exponent"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.PointMass{`0},System.Double,MicrosoftResearch.Infer.Distributions.PointMass{`0})">
            <summary>
            Throws an exception unless the point masses are equal
            </summary>
            <param name="weight1"></param>
            <param name="value1"></param>
            <param name="weight2"></param>
            <param name="value2"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.PointMass{`0})">
            <summary>
            Returns 0 if the this and that point mass are equal, negative infinity otherwise
            </summary>
            <param name="that"></param>
            <returns>Not implemented</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.GetAverageLog(MicrosoftResearch.Infer.Distributions.PointMass{`0})">
            <summary>
            Returns 0 if the this and that point mass are equal, negative infinity otherwise
            </summary>
            <param name="that"></param>
            <returns>Not implemented</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.PointMass`1.Point">
            <summary>
            The location of the point mass.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.PointMass`1.IsPointMass">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IsDistributionWrapper">
            <summary>
            Marker interface for classes which wrap distributions
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Accumulator`1">
            <summary>
            Indicates support for adding an item to a distribution estimator
            </summary>
            <typeparam name="T">Type of item to add - could be a distribution type or a sample type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Accumulator`1.Add(`0)">
            <summary>
            Adds an item to the estimator
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Accumulator`1.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SampleList`1">
            <summary>
            Sample List
            </summary>
            <typeparam name="T">Domain type for sample list</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SampleList`1.Add(`0)">
            <summary>
            Add a sample to the sample list
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SampleList`1.Clear">
            <summary>
            Clears out all the samples
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SampleList`1.Samples">
            <summary>
            Samples
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ConditionalList`1">
            <summary>
            Conditional List
            </summary>
            <typeparam name="TDist">Distribution type for conditional list</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConditionalList`1.Add(`0)">
            <summary>
            Add a sample to the sample list
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConditionalList`1.Clear">
            <summary>
            Clears out all the samples
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.ConditionalList`1.Conditionals">
            <summary>
            Samples
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2">
            <summary>
            Gibbs marginal - wraps underlying estimator, provides burn-in and thinning,
            and maintains thinned samples and conditionals
            </summary>
            <typeparam name="TDist">The distribution type</typeparam>
            <typeparam name="T">The domain type</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Estimator`1">
            <summary>
            Indicates support for retrieving an estimated distribution
            </summary>
            <typeparam name="T">Distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Estimator`1.GetDistribution(`0)">
            <summary>
            Retrieve the estimated distribution
            </summary>
            <param name="result">Where to put the result - ignored if the distribution type is a value type</param>
            <returns>The resulting estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.#ctor(`0,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Constructor from a distribution prototype, and burn in and thin parameters
            </summary>
            <param name="distPrototype">Prototype distribution</param>
            <param name="burnIn">Burn in - number of sample discarded initially</param>
            <param name="thin">Thinning parameter - only every 'thin' samples returned</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.#ctor(MicrosoftResearch.Infer.Distributions.GibbsMarginal{`0,`1})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
            <remarks>This does a soft copy of the estimator and sample and conditional lists</remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.LastSample">
            <summary>
            Last sample added. If no samples, returns default(T)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.LastConditional">
            <summary>
            Last conditional distribution added. If no conditionals, returns uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Clear">
            <summary>
            Clears out all the samples and clears the accumulators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.GetDistribution(`0)">
            <summary>
            Get the estimated distribution from the samples
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.PostUpdate">
            <summary>
            Perform an update by adding a sample from the last conditional
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.ToString">
            <summary>
            Shows the GibbsMarginal in string form
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Estimator">
            <summary>
            The embedded estimator
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Samples">
            <summary>
            Thinned samples
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Conditionals">
            <summary>
            Thinned conditionals
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Distribution">
            <summary>
            The marginal
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GaussianEstimator">
            <summary>
            Estimates a Gaussian distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GaussianEstimator.mva">
            <summary>
            Where to accumulate means and variances
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.#ctor">
            <summary>
            Creates a new Gaussian estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Add(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Adds a Gaussian distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Add(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Adds a Gaussian distribution with given weight to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
            <param name="weight">The weight of the distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Add(System.Double)">
            <summary>
            Adds an sample to the estimator
            </summary>
            <param name="sample">The sample add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Add(System.Double,System.Double)">
            <summary>
            Adds a sample with a given weight to the estimator
            </summary>
            <param name="sample">The sample to add</param>
            <param name="weight">The weight of the sample</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Computes the maximum-likelihood Gaussian from the samples.
            </summary>
            <param name="result"></param>
            <returns>Returns a new Gaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.SetTo(MicrosoftResearch.Infer.Distributions.GaussianEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Beta">
            <summary>
            A Beta distribution over the interval [0,1].
            </summary>
            <remarks><para>
            The Beta is often used as a distribution on probability values.
            The formula for the distribution is <c>p(x) = (Gamma(trueCount+falseCount)/Gamma(trueCount)/Gamma(falseCount)) x^{trueCount-1} (1-x)^(falseCount-1)</c>
            subject to the constraint 0 &lt;= x &lt;= 1.
            </para><para>
            If trueCount = falseCount = 1, the distribution is uniform.
            If falseCount = infinity, the distribution is redefined to be a point mass on trueCount.
            When trueCount &lt;= 0 or falseCount &lt;= 0, the distribution is improper.
            In this case, the density is redefined to not include the Gamma terms, i.e.
            there is no normalizer.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogNormalizer">
            <summary>
            Whether the distribution can compute its normalizer.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogNormalizer.GetLogNormalizer">
            <summary>
            The logarithm of the distribution's normalizer, i.e. the integral of its minimal exponential-family representation.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetVariance`1">
            <summary>
            Whether the distribution supports retrieval of a variance value
            </summary>
            <typeparam name="VarType">Type of the variance value</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetVariance`1.GetVariance">
            <summary>
            Method to get the variance
            </summary>
            <returns>The variance</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVarianceOut`2">
            <summary>
            Whether the distribution supports the joint getting of mean and variance
            where the mean and variance are returned as 'out' argiments
            </summary>
            <typeparam name="MeanType">Mean type</typeparam>
            <typeparam name="VarType">Variance type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVarianceOut`2.GetMeanAndVariance(`0@,`1@)">
            <summary>
            Get the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2">
            <summary>
            Whether the distribution supports the joint setting of mean and variance
            </summary>
            <typeparam name="MeanType"></typeparam>
            <typeparam name="VarType"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2.SetMeanAndVariance(`0,`1)">
            <summary>
            Set the parameters to produce a given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <remarks>In cases where the given mean and variance cannot be matched exactly, the mean
            should have priority.</remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Beta.TrueCount">
            <summary>
            True count
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Beta.FalseCount">
            <summary>
            False count
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.IsProper">
            <summary>
            Whether the distribution is proper or not. It is improper
            when trueCount &lt;= 0 or falseCount &lt;= 0 in which case it
            cannot be normalised
            </summary>
            <returns>true if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMean">
            <summary>
            The expected value E[p].
            </summary>
            <returns><c>TrueCount/TotalCount</c></returns>
            <remarks>The result must be between 0 and 1.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanSquare">
            <summary>
            The expected square E[p^2].
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanCube">
            <summary>
            The expected cube E[p^3].
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanLog">
            <summary>
            The expected logarithm E[log(p)].
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanLogs(System.Double@,System.Double@)">
            <summary>
            The expected logarithms E[log(p)] and E[log(1-p)].
            </summary>
            <param name="eLogP"></param>
            <param name="eLogOneMinusP"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetVariance">
            <summary>
            The variance var(p).
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance for this instance
            </summary>
            <param name="mean">Mean value - output</param>
            <param name="variance">Variance - output</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance for this instance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Clone">
            <summary>
            Clones this Beta. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Beta type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.MaxDiff(System.Object)">
            <summary>
            The maximum 'difference' between the parameters of this instance and of that instance.
            </summary>
            <param name="thatd">That distribution</param>
            <returns>The resulting maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="that">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_Equality(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_Inequality(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Not Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToUniform">
            <summary>
            Sets this instance to be uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.IsUniform">
            <summary>
            Whether the distribution is uniform
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetLogProb(System.Double)">
            <summary>
            Evaluates the logarithm of the density function
            </summary>
            <param name="value">Domain value</param>
            <returns>Log of the probability density for the given domain value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetLogNormalizer">
            <summary>
            Gets the log normalizer for the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.BetaLn(System.Double,System.Double)">
            <summary>
            Computes the log Beta function: <c>GammaLn(trueCount)+GammaLn(falseCount)-GammaLn(trueCount+falseCount)</c>.
            </summary>
            <param name="trueCount">Any real number.</param>
            <param name="falseCount">Any real number.</param>
            <returns><c>GammaLn(trueCount)+GammaLn(falseCount)-GammaLn(trueCount+falseCount)</c></returns>
            <remarks>
            If trueCount &lt;= 0 or falseCount &lt;= 0, the result is defined to be 0.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetAverageLog(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetTo(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Sets the parameters of this instance to the parameters of that instance
            </summary>
            <param name="value">that instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToProduct(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Sets the parameters to represent the product of two Betas.
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <remarks>
            The result may not be proper, i.e. its parameters may be negative.
            For example, if you multiply Beta(0.1,0.1) by itself you get Beta(-0.8, -0.8).
            No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_Multiply(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Static product operator. Create a Beta distribution which is the product of
            two Beta distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting Beta distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToRatio(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two Betas.
            </summary>
            <param name="numerator">The numerator distribution.  Can be the same object as this.</param>
            <param name="denominator">The denominator distribution.  Can be the same object as this.</param>
            <param name="forceProper">If true, the counts of the result are made >= 1, under the constraint that denominator*result has the same mean as numerator.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_Division(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Static ratio operator. Create a Beta distribution which is the ratio of 
            two Beta distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>The resulting Beta distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToPower(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            Sets the parameters to represent the a Beta raised to some power.
            </summary>
            <param name="dist">The distribution</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Beta.AllowImproperSum">
            <summary>
            Property to allow an improper sum
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Beta,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Set the parameters to match the moments of a mixture distribution.
            </summary>
            <param name="dist1">The first distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            The log of the integral of the product of this Beta and that Beta
            </summary>
            <param name="that">That beta</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Sample">
            <summary>
            Sample from this Beta distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Sample(System.Double,System.Double)">
            <summary>
            Static method to sample from a Beta distribution with the specified true and false counts
            </summary>
            <param name="trueCount">True count</param>
            <param name="falseCount">False count</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SampleFromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Static method to sample from a Beta distribution with the specified mean and variance 
            </summary>
            <param name="mean">The mean of the Beta distribution to sample from</param>
            <param name="variance">The variance of the Beta distribution to sample from</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.#ctor(System.Double,System.Double)">
            <summary>
            Creates a Beta distribution with the given parameters.
            </summary>
            <param name="trueCount"></param>
            <param name="falseCount"></param>
            <remarks>
            The formula for the distribution is <c>p(x) = (Gamma(trueCount+falseCount)/Gamma(trueCount)/Gamma(falseCount)) x^{trueCount-1} (1-x)^(falseCount-1)</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.#ctor(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a new Beta distribution from a specified mean and variance
            </summary>
            <param name="mean">mean</param>
            <param name="variance">variance</param>
            <returns>The new Beta distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.FromMeanLogs(System.Double,System.Double)">
            <summary>
            Constructs a Beta distribution with the given E[log(p)] and E[log(1-p)].
            </summary>
            <param name="eLogP">Desired expectation E[log(p)].</param>
            <param name="eLogOneMinusP">Desired expectation E[log(1-p)].</param>
            <returns>A new Beta distribution.</returns>
            <remarks>This function is equivalent to maximum-likelihood estimation of a Beta distribution
            from data given by sufficient statistics. So we want to maximize
            (a-1)eLogP + (b-1)eLogOneMinusP + Gamma(a+b) - Gamma(a) - Gamma(b)
            with respect to a, b where a=trueCount, b=falseCount.
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Uniform">
            <summary>
            Instantiates a uniform Beta distribution
            </summary>
            <returns>A new uniform Beta distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.PointMass(System.Double)">
            <summary>
            Instantiates a point-mass Beta distribution
            </summary>
            <param name="mean">The domain value where the point mass occurs</param>
            <returns>A new point-mass Beta distribution at the specified location</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.ToString">
            <summary>
            Override of the ToString method
            </summary>
            <returns></returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Beta.TotalCount">
            <summary>
            The sum of TrueCount and FalseCount.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Beta.Point">
            <summary>
            Gets/sets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Beta.IsPointMass">
            <summary>
            Whether the instance is a point mass beta distribution
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Bernoulli">
            <summary>
            Represents a distribution on a binary variable.
            </summary>
            <remarks>
            The most common way to use the distribution is to get and set its ProbTrue property.
            
            The distribution is represented by a single number, the log odds: log p(x=true)/p(x=false).
            If this is 0, then the distribution is uniform.
            If this is infinity, then the distribution is a point mass on x=true.
            If this is -infinity, then the distribution is a point mass on x=false.
            In terms of the log odds, p(x=true) = 1/(1+exp(-logOdds)).
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanSetMean`1">
            <summary>
            Whether the distribution supports setting of its mean value
            </summary>
            <typeparam name="MeanType">Type of the mean value</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanSetMean`1.SetMean(`0)">
            <summary>
            Method to set the mean
            </summary>
            <param name="value">The mean value</param>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Bernoulli.LogOdds">
            <summary>
            Log odds parameter
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetProbTrue">
            <summary>
            Gets the probability of the binary variable being true
            </summary>
            <returns>p(x=true)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetProbTrue(System.Double)">
            <summary>
            Sets the probability of the binary variable being true
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetProbFalse">
            <summary>
            Gets the probability of the binary variable being false
            </summary>
            <returns>p(x=false)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetProbFalse(System.Double)">
            <summary>
            Sets the probability of the binary variable being false
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogProbTrue">
            <summary>
            Gets the log probability of the binary variable being true
            </summary>
            <returns>log(p(x=true))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetLogProbTrue(System.Double)">
            <summary>
            Sets the log probability of the binary variable being true
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogProbFalse">
            <summary>
            Gets the log probability of the binary variable being false
            </summary>
            <returns>log(p(x=false))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetLogProbFalse(System.Double)">
            <summary>
            Sets the log probability of the binary variable being false
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToUniform">
            <summary>
            Sets the distribution to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.IsUniform">
            <summary>
            Whether the distribution is uniform
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogProb(System.Boolean)">
            <summary>
            Evaluates the logarithm of the density function
            </summary>
            <param name="x">true or false</param>
            <returns>Log of the probability density for the given event</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogNormalizer">
            <summary>
            Gets the log normalizer of the distribution
            </summary>
            <returns>This equals -log(1-p)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Log of the probability that a draw from this distribution
            is equal to a draw from that distribution.
            </summary>
            <param name="that">That distribution</param>
            <returns>The resulting log probability</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetAverageLog(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Sample">
            <summary>
            Samples from a Bernoulli distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Sample(System.Double)">
            <summary>
            Samples from a Bernoulli distribution with a specified p(true)
            </summary>
            <param name="probTrue">p(true)</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetMean">
            <summary>
            Gets the mean of this Bernoulli distribution
            </summary>
            <returns>The mean</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetMean(System.Double)">
            <summary>
            Sets the mean of this Bernoulli distribution
            </summary>
            <param name="mean">The mean</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetVariance">
            <summary>
            Gets the variance of this Bernoulli distribution
            </summary>
            <returns>The variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.#ctor(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.#ctor(System.Double)">
            <summary>
            Creates a Bernoulli distribution with given probability of being true.
            </summary>
            <param name="probTrue">p(true)</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Uniform">
            <summary>
            Instantiates a uniform Bernoulli distribution
            </summary>
            <returns>A new uniform Bernoulli distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.PointMass(System.Boolean)">
            <summary>
            Instantiates a point-mass Bernoulli distribution
            </summary>
            <param name="value">true of false</param>
            <returns>A new point-mass Bernoulli distribution at the specified value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.FromLogOdds(System.Double)">
            <summary>
            Instantiates a Bernoulli distribution from a log-odds value
            </summary>
            <param name="logOdds">The log-odds</param>
            <returns>A new Bernoulli distribution at the specified log-odds</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToProduct(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Sets this instance to a product of two Bernoulli distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_Multiply(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Creates a Bernoulli distribution which is the product of two Bernoulli distribution
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting Bernoulli distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Sets this instance to a ratio of two Bernoulli distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <param name="forceProper">Ignored</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_Division(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Creates a Bernoulli distribution which is the ratio of two Bernoulli distribution
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>The resulting Bernoulli distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToPower(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Sets this instance to the power of a Bernoulli distributions
            </summary>
            <param name="dist">The distribution to raise to a power</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Raises this distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_LogicalNot(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Creates the complementary distribution
            </summary>
            <param name="dist">The original distribution</param>
            <returns>The complementary distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Creates a Bernoulli distribution which is a weighted sum of two Bernoulli distribution
            </summary>
            <param name="weight1">The weight for the first distribution</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The weight for the second distribution</param>
            <param name="dist2">The second distribution</param>
            <returns>The resulting Bernoulli distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetTo(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Sets this instance to have the parameters of another instance
            </summary>
            <param name="that">The source Bernoulli distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Clone">
            <summary>
            Clones this Bernoulli. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Bernoulli type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.MaxDiff(System.Object)">
            <summary>
            The maximum 'difference' between this instance and that instance.
            This returns the absolute difference between the Log-odds
            </summary>
            <param name="thatd">That distribution</param>
            <returns>The resulting maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>true if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_Equality(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_Inequality(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.ToString">
            <summary>
            Override of ToString method
            </summary>
            <returns>String representation of instance - shows distribution type and p(true)</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.LogitProbEqual(System.Double,System.Double)">
            <summary>
            Computes the logical AreEqual function in the log-odds domain.
            </summary>
            <param name="x">The log-odds of variable A, which can be any real number from -Inf to Inf.</param>
            <param name="y">The log-odds of variable B, which can be any real number from -Inf to Inf.</param>
            <returns>The log-odds that A == B.</returns>
            <remarks>The logical LogitProbEqual function is defined as p1 EQ p2 = p1*p2 + (1-p1)*(1-p2).
            It is the same as the complement of XOR: !(p1 XOR p2).
            In the log-odds domain, this is:
            LogOdds(Logistic(x) EQ Logistic(y)) = log (1+exp(-x-y))/(exp(-x)+exp(-y)).
            To compute this reliably when x>0 and y>0, factor out min(x,y).
            For other cases, use the identity AE(-x,-y) = AE(x,y) and AE(-x,y) = AE(x,-y) = -AE(x,y).
            Note the result is 0 if x=0 or y=0.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.LogProbEqual(System.Double,System.Double)">
            <summary>
            Computes the log-probability that A==B where p(A)=Logistic(x), p(B)=Logistic(y).
            </summary>
            <param name="x">The log-odds of variable A, which can be any real number from -Inf to Inf.</param>
            <param name="y">The log-odds of variable B, which can be any real number from -Inf to Inf.</param>
            <returns>The log-probability that A==B.</returns>
            <remarks>
            The result is Math.Log(0.5) if x=0 or y=0.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Or(System.Double,System.Double)">
            <summary>
            Computes the logical OR function in the log-odds domain.
            </summary>
            <param name="x">Any real number, including infinity.</param>
            <param name="y">Any real number, including infinity.</param>
            <returns>The log odds of (p1 OR p2), where p1 = Logistic(x) and p2 = Logistic(y)</returns>
            <remarks>The logical OR function is defined as p1 OR p2 = 1 - (1-p1)*(1-p2) = p1 + p2 - p1*p2.
            In the log-odds domain, this is:
            LogOdds(Logistic(x) OR Logistic(y)) = log(exp(x) + exp(y) + exp(x+y)).  
            To compute this reliably, factor out max(x,y,x+y).
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Gate(System.Double,System.Double)">
            <summary>
            Computes the Bernoulli gating function in the log-odds domain.
            </summary>
            <param name="x"></param>
            <param name="gate"></param>
            <returns></returns>
            <remarks>
            The Bernoulli gating function is x if gate = -infinity and 0 if gate = infinity.
            It is one of the messages sent by a logical OR factor.
            In the log-odds domain, this is:
            log (1 + exp(-gate))/(1 + exp(-gate-x))
            </remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Bernoulli.IsPointMass">
            <summary>
            Whether the distribution is a point mass (true with probability 1 or false
            with probability 1)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Bernoulli.Point">
            <summary>
            Gets/sets the distribution as a point
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Set`1">
            <summary>
            A collection of unique items.
            </summary>
            <typeparam name="T">The item type.</typeparam>
            <remarks>
            A collection of items, all of which are different according
            to Equals.  null items are not allowed.  Adding a duplicate has no effect.
            Union, intersection, and superset are all supported via operator overloading.
            The items are stored in the keys of a Dictionary that ensures uniqueness
            via its own comparer function.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all items in a collection.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.Contains(System.Collections.Generic.IList{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>result[i] is true iff the set contains list[i].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>true if the set contains all items in list.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.ContainsAny(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>true if the set contains any item in list.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.Remove(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in a collection.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.op_GreaterThanOrEqual(MicrosoftResearch.Infer.Collections.Set{`0},MicrosoftResearch.Infer.Collections.Set{`0})">
            <summary>
            Superset operator.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>True iff a is equal to or a superset of b.</returns>
            <remarks>null is treated as an empty set.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.op_LessThanOrEqual(MicrosoftResearch.Infer.Collections.Set{`0},MicrosoftResearch.Infer.Collections.Set{`0})">
            <summary>
            Subset operator.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>True iff a is equal to or a subset of b.</returns>
            <remarks>null is treated as an empty set.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ConvertibleToArray">
            <summary>
            Indicates if the object can convert to and from an array.
            </summary>
            <remarks>
            Possessing this interface implies that the object also has a constructor accepting an array type,
            such that <c>new T(this.ToArray())</c> is equivalent to <c>this.Clone()</c>.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ArrayAsList`1">
            <summary>
            Wraps a multidimensional array to look like a linear list.
            </summary>
            <remarks>
            In the MSDN documentation, the Array class claims to implement IList.  In fact, this interface is only supported
            for one-dimensional arrays.  ArrayAsList provides this missing functionality for multidimensional arrays.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SerializableVector">
            <summary>
            Helper class for serializing Vectors.  To serialize a Vector, first cast it to SerializableVector.  After deserializing, cast back to Vector.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UnaryOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Random``1(MicrosoftResearch.Infer.Distributions.Sampleable{``0})"/>, given random arguments to the function.
            </summary>
            <typeparam name="DomainType">Domain type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.LogAverageFactor``1(``0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="random">Incoming message from 'random'</param>
            <param name="dist">Incoming message from 'dist'</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.LogAverageFactor``1(`0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="random">Constant value for 'random'</param>
            <param name="dist">Incoming message from 'dist'</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.LogEvidenceRatio``1(``0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="random">Incoming message from 'random'</param>
            <param name="dist">Incoming message from 'dist'</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.LogEvidenceRatio``1(`0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="random">Constant value for 'random'</param>
            <param name="dist">Incoming message from 'dist'</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.RandomAverageConditional``1(``0)">
            <summary>
            EP message to 'random'.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="dist">Incoming message from 'dist'</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.AverageLogFactor``1(``0,``0)">
            <summary>
            Evidence message for VMP.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="random">Incoming message from 'random'</param>
            <param name="dist">Incoming message from 'dist'</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.AverageLogFactor``1(`0,``0)">
            <summary>
            Evidence message for VMP.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="random">Constant value for 'random'</param>
            <param name="dist">Incoming message from 'dist'</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.RandomAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'random'.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="dist">Incoming message from 'dist'</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstantOp`1">
            <summary>
            Provides outgoing messages for <see cref="!:Factor.Constant&lt;DomainType&gt;"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstantOp`1.LogEvidenceRatio">
            <summary>
            Evidence message for EP.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstantOp`1.ConstantAverageConditional``1(`0,``0)">
            <summary>
            EP message to 'constant'
            </summary>
            <typeparam name="DistributionType">Distribution type</typeparam>
            <param name="value">Constant value</param>
            <param name="result">Where to put result</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstantOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstantOp`1.ConstantAverageLogarithm``1(`0,``0)">
            <summary>
            VMP message to 'constant'
            </summary>
            <typeparam name="DistributionType">Distribution type</typeparam>
            <param name="value">Constant value</param>
            <param name="result">Where to put result</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GaussianFromMeanAndVariance(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.SampleAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(mean) p(mean) factor(sample,mean,variance)]/p(sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Incoming message from 'variance'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(variance) p(variance) factor(sample,mean,variance)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="variance"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.LaplacianTimesGaussianMoments(System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary>
            Compute moments of 0.5*exp(-abs(x))*N(x;m,v)
            </summary>
            <param name="m"></param>
            <param name="v"></param>
            <param name="mu"></param>
            <param name="vu"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="variance">Incoming message from 'variance'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(mean,variance) p(mean,variance) factor(sample,mean,variance)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="variance"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.InterpolateBesselKMoment(System.Double,System.Double[])">
            <summary>
            Approximate a moment of VG(x;a) by interpolating its values for integer shapes
            </summary>
            <param name="a">The starting integer shape</param>
            <param name="binomt">The exact moment for integer shapes starting at <paramref name="a"/></param>
            <returns>The interpolated moment</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.NormalCdfMomentRatios(System.Int32,System.Double,System.Double)">
            <summary>
            Computes int_0^Inf x^n N(x;m,v) dx / N(m/sqrt(v);0,1)
            </summary>
            <param name="nMax"></param>
            <param name="m"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.NormalCdfMoments(System.Int32,System.Double,System.Double)">
            <summary>
            Compute int_0^Inf x^n N(x;m,v) dx for all integer n from 0 to nMax.  Loses accuracy if m &lt; -1.
            </summary>
            <param name="nMax"></param>
            <param name="m"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.NormalVGMoments(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Compute int_0^Inf x^n N(x;m+v,v) VG(x;a) dx *2*exp(m+v/2).  Loses accuracy if m &lt; -1.
            </summary>
            <param name="nMax"></param>
            <param name="aMax"></param>
            <param name="m"></param>
            <param name="v"></param>
            <param name="moments1"></param>
            <returns>NormalVGMoment[a][n] where a ranges from 1 to aMax, n ranges from 0 to nMax+aMax-a</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.NormalVGMomentRatios(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Compute int_0^Inf x^n N(x;m+v,v) VG(x;a) dx *2*exp(m+v/2)/N(m/sqrt(v);0,1)
            </summary>
            <param name="nMax"></param>
            <param name="aMax"></param>
            <param name="m"></param>
            <param name="v"></param>
            <param name="moments1"></param>
            <returns>NormalVGMoment[a][n] where a ranges from 1 to aMax, n ranges from 0 to nMax+aMax-a</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.MeanAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(sample) p(sample) factor(sample,mean,variance)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.MeanAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="variance">Incoming message from 'variance'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(variance) p(variance) factor(sample,mean,variance)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="variance"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="variance">Incoming message from 'variance'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(sample,variance) p(sample,variance) factor(sample,mean,variance)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="variance"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.VarianceAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'variance'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="variance">Incoming message from 'variance'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'variance' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'variance' as the random arguments are varied.
            The formula is <c>proj[p(variance) sum_(mean) p(mean) factor(sample,mean,variance)]/p(variance)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="variance"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.VarianceAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'variance'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Incoming message from 'variance'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'variance' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'variance' as the random arguments are varied.
            The formula is <c>proj[p(variance) sum_(sample) p(sample) factor(sample,mean,variance)]/p(variance)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="variance"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.VarianceAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'variance'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Incoming message from 'variance'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'variance' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'variance' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="variance"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.VarianceAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'variance'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Incoming message from 'variance'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'variance' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'variance' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="variance"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianFromMeanAndVarianceOp.VarianceGammaTimesGaussianIntegral(System.Double,System.Double,System.Double)">
            <summary>
            Compute int_{-Inf}^{Inf} N(x;m,v) VG(x;a) dx * 2/N(m/sqrt(v);0,1)
            </summary>
            <param name="a"></param>
            <param name="m"></param>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.HasMessageFunctionsAttribute">
            <summary>
            When applied to an assembly, indicates that the assembly should be searched for message functions.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethodAttribute">
            <summary>
            When applied to a class, indicates that the class provides message functions for a given factor.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.Type">
            <summary>
            Type which contains the factor definition
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.MethodName">
            <summary>
            Method name for the factor
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.ParameterTypes">
            <summary>
            Parameter types for the factor
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.NewParameterNames">
            <summary>
            New names for factor parameters overriding the default choice of parameter names
            - these are used to name message passing methods
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.Default">
            <summary>
            True if this class should override other classes for the same factor.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.#ctor(System.Type,System.String,System.Type[])">
            <summary>
            Creates a new FactorMethod attribute
            </summary>
            <param name="type">Type which contains the factor definition</param>
            <param name="methodName">Method name for the factor</param>
            <param name="parameterTypes">Parameter types for the factor</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.#ctor(System.String[],System.Type,System.String,System.Type[])">
            <summary>
            Creates a new FactorMethod attribute
            </summary>
            <param name="type">Type which contains the factor definition</param>
            <param name="methodName">Method name for the factor</param>
            <param name="parameterTypes">Parameter types for the factor</param>
            <param name="newParameterNames">New names for factor parameters overriding the default choice of
            parameter names - these are used to name message passing methods</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.HiddenAttribute">
            <summary>
            Marks a factor as hidden
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.HiddenAttribute.IsDefined(System.Reflection.MethodInfo)">
            <summary>
            Returns true if the given method has a 'Hidden' attribute
            </summary>
            <param name="mi">The method info</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.HiddenAttribute.IsDefined(System.Type)">
            <summary>
            Returns true if the given type has a 'Hidden' attribute
            </summary>
            <param name="ty">The type</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BuffersAttribute">
            <summary>
            When applied to a message operator class, indicates that the message operators may use the named parameters as storage for holding algorithm state.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.BuffersAttribute.BufferNames">
            <summary>
            Names of buffers that may be used as method parameters.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BuffersAttribute.#ctor(System.String[])">
            <summary>
            Creates a new Buffers attribute
            </summary>
            <param name="names"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ParameterNamesAttribute">
            <summary>
            When applied to a method, overrides the default choice of parameter names.
            </summary>
            <remarks>
            The first parameter is the result.  Thus the method <c>int f(int x)</c> has two parameters, the
            result and x.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ParameterNamesAttribute.Names">
            <summary>
            The new parameter names
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ParameterNamesAttribute.#ctor(System.String[])">
            <summary>
            Creates a new ParameterNames attribute
            </summary>
            <param name="names"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.AllExceptIndexAttribute">
            <summary>
            When applied to a message function parameter, indicates that the function depends on all items
            in the message collection except the resultIndex.  The default is all items.
            </summary>
            <remarks>
            This attribute cannot be combined with MatchingIndexAttribute, since they would cancel.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MatchingIndexAttribute">
            <summary>
            When applied to a message function parameter, indicates that the function depends on the one
            item in the message collection at resultIndex.  The default is all items.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IndexedAttribute">
            <summary>
            When applied to a message function parameter, indicates that the argument should be indexed by resultIndex.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CancelsAttribute">
            <summary>
            When applied to a message function parameter, indicates that the argument's value is cancelled by another argument, thus there is no real dependency.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ProperAttribute">
            <summary>
            The distribution must be proper.
            </summary>
            <remarks>
            Applies to message function parameters.  Indicates that the parameter should be a proper distribution,
            or else the behavior is undefined.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipAttribute">
            <summary>
            The result is always uniform.
            </summary>
            <remarks>
            Applies to message functions.  This annotation is optional and allows the inference
            engine to skip unnecessary function calls, i.e. ones which would produce uniform results.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) whenever this parameter is uniform, hence the function call can be skipped.
            </summary>
            <remarks><para>
            Applies to message function parameters.  This annotation is optional and allows the inference
            engine to skip unnecessary function calls, i.e. ones which would produce a uniform result or throw
            an exception.  For LogAverageFactor and AverageLogFactor, SkipIfUniform means the result would be 0.
            </para><para>
            When applied to an array parameter, this attribute means the result is uniform (or an exception would be thrown)
            whenever all dependent elements in the array are uniform.
            For example:
            <list type="bullet">
            <item><term><c>f([AllExceptIndex,SkipIfUniform] Message[] array, int resultIndex)</c></term>
            <description><c>f</c> depends on all elements other than resultIndex, and can be skipped if all of these are uniform.
            <c>f</c> does not depend on <c>array[resultIndex]</c> and the uniformity of this element is ignored.
            </description>
            </item>
            </list>
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfAllUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if all elements are uniform, hence the function call can be skipped.
            </summary>
            <remarks><para>
            Applies to message functions and message function array parameters.
            This annotation is optional and allows the inference
            engine to skip unnecessary function calls, i.e. ones which would produce a uniform result or throw
            an exception.
            When applied to a message function, it means that the result is uniform (or an exception would be thrown) whenever all parameters to the function are uniform.
            When applied to an array parameter, it means that the result is uniform (or an exception would be thrown) whenever all dependent elements in the array are uniform.
            Array elements that the function does not depend on are ignored.
            </para><para>
            It only makes sense to apply this attribute to a method when the method parameters have no SkipIfUniform attributes set.
            Otherwise SkipIfAllUniform is automatically implied by SkipIfUniform for the parameter.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.SkipIfAllUniformAttribute.ParameterNames">
            <summary>
            List of parameter names for which to check for uniformity
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SkipIfAllUniformAttribute.#ctor">
            <summary>
            Creates a new SkipIfAllUniform attribute
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SkipIfAllUniformAttribute.#ctor(System.String[])">
            <summary>
            Creates a new SkipIfAllUniform attribute applied to the specified parameter names
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfAnyUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if any element is uniform, hence the function call can be skipped.
            </summary>
            <remarks><para>
            Applies to message function array parameters.
            This annotation is optional and allows the inference
            engine to skip unnecessary function calls, i.e. ones which would produce a uniform result or throw
            an exception.
            When applied to an array parameter, it means that the result is uniform (or an exception would be thrown) whenever any dependent element in the array is uniform.
            Array elements that the function does not depend on are ignored.
            When applied to a parameter that is not an array, it has the same meaning as SkipIfUniform.
            </para><para>
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfAnyExceptIndexIsUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if any element except
            at the result index is uniform, hence the function call can be skipped.
            </summary>
            <remarks>
            Examples:
            <list type="bullet">
            <item><term><c>f([SkipIfAnyExceptIndexIsUniform] Message[] array, int resultIndex)</c></term>
            <description>Since no dependency attribute was given, the default is that <c>f</c> depends on all elements of the array.
            Since <c>SkipIfAnyExceptIndexIsUniform</c> was given, <c>f</c> returns uniform (or throws an exception) if any elements except the one at resultIndex is uniform.
            Thus <c>array[resultIndex]</c> is a dependency but its uniformity is ignored.</description>
            </item>
            <item><term><c>f([AllExceptIndex,SkipIfAnyExceptIndexIsUniform] Message[] array, int resultIndex)</c></term>
            <description>In this case, <c>f</c> depends on all elements other than resultIndex, and returns uniform (or throws an exception) if any of them are uniform.
            Thus it is equivalent to <c>[AllExceptIndex,SkipIfUniform]</c></description>
            </item>
            <item><term><c>f([MatchingIndex,SkipIfAnyExceptIndexIsUniform] Message[] array, int resultIndex)</c></term>
            <description>Here <c>SkipIfAnyExceptIndexIsUniform</c> is ignored since <c>f</c> only depends on <c>array[resultIndex]</c>.
            </description>
            </item>
            </list>
            This attribute can be stacked with the other SkipIfUniform attributes, to build up a set of skip cases.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfAllExceptIndexAreUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if all elements except
            at the result index are uniform, hence the function call can be skipped.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfMatchingIndexIsUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if the element at
            the result index is uniform, hence the function call can be skipped.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IgnoreDependencyAttribute">
            <summary>
            When attached to a method parameter, indicates that the dependency should be ignored by the FactorManager.  Only a declaration dependency will be retained.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IgnoreDeclarationAttribute">
            <summary>
            When attached to a method parameter, indicates that the dependency and the declaration dependency should be ignored by the FactorManager.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstantAttribute">
            <summary>
            When attached to a factor parameter, indicates that the parameter
            is constant - i.e. cannot be changed by observation or by inference
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstantAttribute.IsDefined(System.Reflection.ParameterInfo)">
            <summary>
            Returns true if this parameter has a Constant attribute
            </summary>
            <param name="pi"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.RequiredArgumentAttribute">
            <summary>
            When applied to a method argument, indicates that argument is required to have
            been set before calling the method
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.RequiredArgumentAttribute.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsReturnedAttribute">
            <summary>
            When applied to a method argument, indicates that the argument will be returned unmodified
            as the result of the method.  This automatically implies SkipIfUniform and Trigger.
            </summary>
            <remarks>
            This attribute allows significant optimisations to be undertaken in the compiler.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsReturnedAttribute.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsReturnedInEveryElementAttribute">
            <summary>
            When applied to a method argument for methods that return lists, indicates that all elements
            of the returned list will be identical and equal to that argument.  This automatically implies SkipIfUniform.
            </summary>
            <remarks>
            This attribute allows significant optimisations to be undertaken in the compiler.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsReturnedInEveryElementAttribute.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DependsOnIteration">
            <summary>
            When applied to a method invoke expression, indicates that the execution of this
            expression depends on the iteration counter
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DependsOnIteration.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.TriggerAttribute">
            <summary>
            When applied to a method argument, indicates that the method's result is invalidated when
            a dependent item in that argument changes.
            </summary>
            <remarks>
            The formal definition of trigger is:
            If C uses A, and A is triggered by B, then when B changes, A must be updated before C.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MatchingIndexTriggerAttribute">
            <summary>
            When applied to a method argument, indicates that the method's result is invalidated when
            the array element at resultIndex changes.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.NoTriggersAttribute">
            <summary>
            When applied to a method, indicates that no default triggers should be assigned to its parameters.
            The method will explicitly mark its triggers using TriggerAttribute.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FreshAttribute">
            <summary>
            When applied to a method argument, indicates that the argument must be up-to-date
            before invoking the method.
            When applied to a method, indicates that the method must be recomputed whenever any of its arguments change.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MultiplyAllAttribute">
            <summary>
            When applied to a message function, indicates that the function returns the product of its arguments.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.NoInitAttribute">
            <summary>
            When applied to a method argument, indicates that the argument does not benefit from initialization (by default, initialization is assumed to be beneficial)
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReturnsCompositeArrayAttribute">
            <summary>
            When applied to a factor, indicates that the factor returns a composite array.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
            <summary>
            Improper message exception
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ImproperMessageException.#ctor(System.Object)">
            <summary>
            Creates an improper message exception with the specified distribution
            </summary>
            <param name="distribution">Distribution instance</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.NotSupportedAttribute">
            <summary>
            When applied to a method, indicates that the method will always throw a NotSupportedException.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.NotSupportedAttribute.Message">
            <summary>
            Message for the exception that will be thrown by the method
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.NotSupportedAttribute.#ctor(System.String)">
            <summary>
            Creates a NotSupported attribute with the given exception message
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.QualityBand">
            <summary>
            Quality bands for Infer.NET components - distributions, operators, factors
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QualityBand.Unknown">
            <summary>
            Unknown. Components which are not marked with a quality band. 
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QualityBand.Experimental">
            <summary>
            Experimental components are work in progress and represent early stage development
            of new components. They are typically usable in just a few common scenarios, and
            will not have undergone rigorous testing. They are primarily intended for use by
            researchers and provide an opportunity for preliminary feedback. It is possible that
            a given experimental component may not be included in a future release. These may
            be undocumented or only sparsely documented.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QualityBand.Preview">
            <summary>
            Preview components are intended to meet most basic usage scenarios. While in
            the Preview Quality Band, these components may have a moderate number of breaking
            API or behavior changes in response to user feedback and as we learn more
            about how they will be used. Users are likely to encounter bugs and
            functionality issues for less common scenarios. These will have some documentation
            which may be minimal.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QualityBand.Stable">
            <summary>
            Stable components are suitable for a wide range of usage scenarios and will
            have incorporated substantial design and functionality feedback. They may continue
            evolving via limited bug fixes, fine-tuning, and support for additional scenarios.
            Stable components may have a small number of breaking API or behaviour changes
            when feedback demands it. These components will have reasonable documentation
            which may include examples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.QualityBand.Mature">
            <summary>
            Mature components are ready for full release, meeting the highest levels of
            quality and stability. Future releases of mature components will maintain a high
            quality bar with no breaking changes other than in exceptional circumstances.
            Users should be confident using mature components, knowing that when they
            upgrade from one version of Infer.NET to a newer version it will be a quick and
            easy process. These components will have detailed documentation and at least one
            example of usage.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Quality">
            <summary>
            Attribute used to label Infer.NET components. They may be attached to algorithm classes,
            distribution classes, and operator classes. They may also be attached to any methods on
            these classes
            </summary>
            <remarks>Methods inherit the quality of their class. Classes are, by default, experimental.
            <para>
            The compiler will convert static quality bands to a quality band for each generated statement
            of code. Depending on the error level and warning levels set in the compiler, Errors and/or
            warnings will be issued. In addition, a general warning/error may be issued for the algorithm.
            </para>
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Quality.Band">
            <summary>
            Quality band
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Quality.#ctor(MicrosoftResearch.Infer.QualityBand)">
            <summary>
            Constructor
            </summary>
            <param name="band"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Quality.GetQualityBand(System.Type)">
            <summary>
            Gets the quality band associated with a type. If this is an array type
            then the quality of the element is returned. If the type has generic parameters
            then the quality of the generic type is returned
            </summary>
            <param name="t">Type</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Quality.GetQualityBand(System.Reflection.MemberInfo)">
            <summary>
            Gets the quality band associated with a member of a class
            </summary>
            <param name="mi">Member info</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Quality.ToString">
            <summary>
            ToString override
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BinomialOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Binomial(System.Int32,System.Double)"/>, given random arguments to the function.
            </summary>
            <remarks>The factor is f(sample,n,p) = choose(n,sample) p^sample (1-p)^(n-sample)</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,trialCount,p))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogAverageFactor(System.Int32,System.Double,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="p">Constant value for 'p'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,trialCount,p))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogAverageFactor(System.Int32,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="p">Constant value for 'p'.</param>
            <param name="trialCount">Incoming message from 'trialCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(trialCount) p(trialCount) factor(sample,trialCount,p))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="p">Incoming message from 'p'.</param>
            <param name="trialCount">Incoming message from 'trialCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(p,trialCount) p(p,trialCount) factor(sample,trialCount,p))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Beta,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="p">Incoming message from 'p'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(p) p(p) factor(sample,trialCount,p))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,trialCount,p) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.LogEvidenceRatio(System.Int32,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="p">Constant value for 'p'.</param>
            <param name="trialCount">Incoming message from 'trialCount'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(trialCount) p(trialCount) factor(sample,trialCount,p))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.SampleAverageConditional(System.Double,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="p">Constant value for 'p'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="p">Incoming message from 'p'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(p) p(p) factor(sample,trialCount,p)]/p(sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.SampleAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="p">Constant value for 'p'.</param>
            <param name="trialCount">Incoming message from 'trialCount'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(trialCount) p(trialCount) factor(sample,trialCount,p)]/p(sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="p">Incoming message from 'p'.</param>
            <param name="trialCount">Incoming message from 'trialCount'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(p,trialCount) p(p,trialCount) factor(sample,trialCount,p)]/p(sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.TrialCountAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'trialCount'
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="p">Constant value for 'p'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'trialCount' as the random arguments are varied.
            The formula is <c>proj[p(trialCount) sum_(sample) p(sample) factor(sample,trialCount,p)]/p(trialCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.TrialCountAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'trialCount'
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="p">Incoming message from 'p'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'trialCount' as the random arguments are varied.
            The formula is <c>proj[p(trialCount) sum_(sample,p) p(sample,p) factor(sample,trialCount,p)]/p(trialCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.TrialCountAverageConditional(System.Int32,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'trialCount'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="p">Constant value for 'p'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'trialCount' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.TrialCountAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'trialCount'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="p">Incoming message from 'p'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'trialCount' as the random arguments are varied.
            The formula is <c>proj[p(trialCount) sum_(p) p(p) factor(sample,trialCount,p)]/p(trialCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.PAverageConditional(System.Int32,System.Int32)">
            <summary>
            EP message to 'p'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <returns>The outgoing EP message to the 'p' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'p' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.AverageLogFactor(System.Int32,System.Double,System.Int32)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="p">Constant value for 'p'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,trialCount,p))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Beta,System.Int32)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="p">Incoming message from 'p'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(p) p(p) log(factor(sample,trialCount,p))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.PAverageLogarithm(System.Int32,System.Int32)">
            <summary>
            VMP message to 'p'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <returns>The outgoing VMP message to the 'p' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'p' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.PAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'p'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="trialCount">Incoming message from 'trialCount'.</param>
            <returns>The outgoing VMP message to the 'p' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'p'.
            The formula is <c>exp(sum_(trialCount) p(trialCount) log(factor(sample,trialCount,p)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.PAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            VMP message to 'p'
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <returns>The outgoing VMP message to the 'p' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'p'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,trialCount,p)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BinomialOp.PAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'p'
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="trialCount">Incoming message from 'trialCount'.</param>
            <returns>The outgoing VMP message to the 'p' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'p'.
            The formula is <c>exp(sum_(sample,trialCount) p(sample,trialCount) log(factor(sample,trialCount,p)))</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.WrappedGaussian">
            <summary>
            A Gaussian distribution on a periodic domain, such as angles between 0 and 2*pi.
            </summary>
            <remarks>
            The distribution is represented by a unwrapped Gaussian and a period length L.
            To get the wrapped density, the unwrapped density is summed over all shifts by L, i.e.
            p(x) = sum_k N(x + Lk; m, v)  over all integers k
            The wrapped density is automatically normalized over the range [0,L) because it 
            simply moves the probability mass that was previously distributed over the real line 
            to all lie in the interval [0,L).
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Gaussian">
            <summary>
            The unwrapped Gaussian, with mean in [0,L)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Period">
            <summary>
            The period length, greater than zero
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.#ctor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Create a WrappedGaussian distribution
            </summary>
            <param name="unwrapped"></param>
            <param name="period"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a WrappedGaussian distribution
            </summary>
            <param name="unwrappedMean"></param>
            <param name="unwrappedVariance"></param>
            <param name="period"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Uniform(System.Double)">
            <summary>
            Create a uniform WrappedGaussian distribution
            </summary>
            <param name="period"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.PointMass(System.Double,System.Double)">
            <summary>
            Create a WrappedGaussian distribution with all mass on a single point
            </summary>
            <param name="point"></param>
            <param name="period"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Mod(System.Double)">
            <summary>
            Return x modulo the period
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Mod(System.Double,System.Double)">
            <summary>
            Return x modulo the period
            </summary>
            <param name="x"></param>
            <param name="period"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Clone">
            <summary>
            Make a deep copy of this distribution. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this distribution and that
            </summary>
            <param name="thatd"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Equals(System.Object)">
            <summary>
            True if this distribution has the same parameters as that
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.GetHashCode">
            <summary>
            A hash of the distribution parameter values
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.ToString">
            <summary>
            A human-readable string containing the parameters of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.op_Equality(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.op_Inequality(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.SetToUniform">
            <summary>
            Set the distribution to uniform, keeping the same period
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.IsUniform">
            <summary>
            True if the distribution is uniform
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.GetLogProb(System.Double)">
            <summary>
            Get the log probability density at value. 
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.SetTo(MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Set this distribution equal to value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.SetToProduct(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Set this distribution equal to the approximate product of a and b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <remarks>
            Since WrappedGaussians are not closed under multiplication, the result is approximate.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.op_Multiply(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Creates a new WrappedGaussian which is the product of two other WrappedGaussians
            </summary>
            <param name="a">First WrappedGaussian</param>
            <param name="b">Second WrappedGaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.SetToRatio(MicrosoftResearch.Infer.Distributions.WrappedGaussian,MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Boolean)">
            <summary>
            Set this equal to numerator/denominator
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double,MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Set the parameters to match the moments of a mixture distribution.
            </summary>
            <param name="dist1">The first distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Sample">
            <summary>
            Sample from the distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Sample(System.Double)">
            <summary>
            Sample from the distribution
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Get the logarithm of the average value of that distribution under this distribution, i.e. log(int this(x) that(x) dx)
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.GetAverageLog(MicrosoftResearch.Infer.Distributions.WrappedGaussian)">
            <summary>
            Get the average logarithm of that distribution under this distribution, i.e. int this(x) log( that(x) ) dx
            </summary>
            <param name="that"></param>
            <returns></returns>
            <remarks>
            The result is approximate.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WrappedGaussian.SetToPower(MicrosoftResearch.Infer.Distributions.WrappedGaussian,System.Double)">
            <summary>
            Set this equal to (dist)^exponent
            </summary>
            <param name="dist"></param>
            <param name="exponent"></param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.WrappedGaussian.Point">
            <summary>
            Set this distribution to a point mass, or get its location
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.WrappedGaussian.IsPointMass">
            <summary>
            True if the distribution is a point mass. 
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IFunction">
            <summary>
            Function interface - used for distributions over a function domain
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IFunction.Evaluate(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluate a function
            </summary>
            <param name="X">Input</param>
            <returns>Output</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ConstantFunction">
            <summary>
            Class implementing the constant function. Used as a domain prototype
            for distributions over functions
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConstantFunction.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConstantFunction.Evaluate(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluate the function
            </summary>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConstantFunction.#ctor">
            <summary>
            Constructor for constant function - default value is 0.0
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConstantFunction.#ctor(System.Double)">
            <summary>
            Constructor for constant function
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.ConstantFunction.ConstantValue">
            <summary>
            The constant value of the function
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IGaussianProcess">
            <summary>
            Basic GP interface
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Mean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Mean of f at a given point
            </summary>
            <param name="X">Input</param>
            <returns>E[f(x)]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Mean(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Mean of f at a list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>E[f(x_i)]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Variance(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Variance of f at a given point
            </summary>
            <param name="X">Input</param>
            <returns>var(f(x))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Covariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Covariance of f at two points
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>cov(f(x),f(y))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Covariance(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Covariance matrix of f at a list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>cov(f(x_1),f(x_2),...)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Marginal(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Marginal distribution of f at a given point
            </summary>
            <param name="X">Input</param>
            <returns>p(f(x))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Joint(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Joint distribution of f at a list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>p(f(x_1),f(x_2),...)</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LuDecomposition">
            <summary>
            Class for calculating and doing operations with an LU decomposition
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.LuDecomposition.LU">
            <summary>
            The matrix
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LUDecomposition class with a given number of rows and columns
            </summary>
            <param name="nRows">Number of rows</param>
            <param name="nCols">Number of columns</param>
            <remarks><para>
            Currently this only supports square matrices
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.#ctor(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Constructs an LUDecopmosition class, and performs the decomposition on the given matrix.
            </summary>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.InPlace(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Creates performs and returns an LUDecomposition on a given matrix.
            </summary>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.Decompose(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Decomposes the matrix A
            </summary>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.Decompose">
            <summary>
            Performs the decomposition for this instance
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.Determinant">
            <summary>
            Returns the determinant of the given instance. The
            decomposition is assumed to have been performed
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.Solve(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Solves Ay = x for y, leaving the result in x.
            </summary>
            <param name="x"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.CompiledExpression`1">
            <summary>
            Class that stores a delegate expression together with its compiled form.
            </summary>
            <typeparam name="TFunc">Type of a delegate represented by the expression.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.CompiledExpression`1.#ctor">
            <summary>
            Creates new instance of a class.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.CompiledExpression`1.#ctor(System.Linq.Expressions.Expression{`0})">
            <summary>
            Creates new instance of a class that stores given expression inside.
            </summary>
            <param name="expression">Expression to store.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.CompiledExpression`1.Get">
            <summary>
            Retrieves compiled version of the stored expression.
            </summary>
            <returns>Compiled expression.</returns>
            <exception cref="T:System.InvalidOperationException">If this instances stores no expression.</exception>
        </member>
        <member name="P:MicrosoftResearch.Infer.Utils.CompiledExpression`1.Expression">
            <summary>
            Gets or sets the expression stored by this instance.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Predicate`2">
            <summary>
            Delegate for two argument predicate
            </summary>
            <typeparam name="T1">Type of first argument</typeparam>
            <typeparam name="T2">Type of second argument</typeparam>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Predicate`3">
            <summary>
            Delegate for three argument predicate
            </summary>
            <typeparam name="T1">Type of first argument</typeparam>
            <typeparam name="T2">Type of second argument</typeparam>
            <typeparam name="T3">Type of third argument</typeparam>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.EnumerableExtensions.Merge``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Merges two sorted lists into one list in ascending order.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list1"></param>
            <param name="list2"></param>
            <param name="comparer"></param>
            <returns></returns>
            <remarks>
            If items from list1 and list2 are equal, the items from list1 are put first.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.EnumerableExtensions.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.List{``0}@)">
            <summary>
            Skip n items from a stream, saving the skipped items to a list
            </summary>
            <typeparam name="T">The item type.</typeparam>
            <param name="stream">A stream</param>
            <param name="count">The number of items to skip from the front of the stream.</param>
            <param name="head">On return, the skipped items.</param>
            <returns>The rest of the stream.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Collection">
            <summary>
            Extension methods for ICollection
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Collection.Sort``2(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``1})">
            <summary>
            Sort a pair of collections according to the values in the first collection
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
            <param name="keys"></param>
            <param name="items"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Collection.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add multiple items to a collection
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="collection">The collection to add to</param>
            <param name="items">The items to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Collection.ContainsAll``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Test if a collection contains multiple items
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="collection">The collection</param>
            <param name="items">The items to search for</param>
            <returns>True if the collection contains all items.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Collection.ContainsAny``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Test if a collection contains any of multiple items
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="collection">The collection</param>
            <param name="items">The items to search for</param>
            <returns>True if the collection contains any item in items.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Collection.ToArray``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Create an array of items from the collection
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="collection">The collection</param>
            <returns>An array containing all items in the collection</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LineSearchEval">
            <summary>
            Delegate type for function evaluation
            </summary>
            <param name="step">Step value</param>
            <param name="calcDeriv">Calculate the derivative</param>
            <param name="deriv">Where to put the derivative</param>
            <returns>Function evaluation</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LineSearch">
            <summary>
            This line search algorithm is algorithm 3.5/3.6 from
            Nocedal and Wright (Second edition, 2006). It provides
            a step length that satisfies the strong Wolfe conditions.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LineSearch.SetWolfeConstants(System.Double,System.Double)">
            <summary>
            Set Wolfe conditions
            </summary>
            <param name="c1">Sufficient decrease condition</param>
            <param name="c2">Curvature condition</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LineSearch.Zoom(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Zoom in once we have bracketed the desired step length
            </summary>
            <param name="lo">Low point of step interval</param>
            <param name="phiLo">Evaluation at lo</param>
            <param name="dPhiLo">Derivative at lo</param>
            <param name="hi">High point of step interval</param>
            <param name="phiHi">Evaluation at lo</param>
            <param name="dPhiHi">Derivative at lo</param>
            <returns>The best step length</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LineSearch.Run(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Main execution method for line search
            </summary>
            <param name="initialStep"></param>
            <param name="maxStep"></param>
            <returns>Step satisfying Wolfe conditions</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.LineSearch.Phi">
            <summary>
            Line search evaluation function
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.LineSearch.InterpolationTolerance">
            <summary>
            When performing interpolation this is the minimum
            fraction of the range by which the interpolant
            must be from one of the two end points
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.LineSearch.MaximumZoomIterations">
            <summary>
            Maximum number of iterations for the zoom method
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.LineSearch.ExtrapolationMultiplier">
            <summary>
            Multiplier for the extrapolation
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LBFGS">
            <summary>
            Implements the LBFGS compact Quasi-Newton solver. 
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.BFGS">
            <summary>
            This implementation of BFGS is based on Algorithm 6.1 from
            Nocedal and Wright (Second edition, 2006).
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.BFGS.dimension">
            <summary>
            Following fields are set up by the main run
            routine, and are used to provide the 1-D function that
            the line search needs
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.BFGS.debug">
            <summary>
            Whether to output debug info
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.BFGS.convergenceCriteria">
            <summary>
             Convergence criteria:
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.BFGS.#ctor">
            <summary>
            BFGS constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.BFGS.SetWolfeConstants(System.Double,System.Double)">
            <summary>
            Set Wolfe conditions
            </summary>
            <param name="c1">Sufficient decrease condition</param>
            <param name="c2">Curvature condition</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.BFGS.LSEval(System.Double,System.Boolean,System.Double@)">
            <summary>
            This is the 1-D function that the line search sees.
            The Run function will set up the necessary fields
            </summary>
            <param name="step">step</param>
            <param name="calcDeriv">flag to calculate derivative</param>
            <param name="deriv">the derivative</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.BFGS.TryLineSearch(System.Double,System.Double,System.Double)">
            <summary>
            Line search
            </summary>
            <param name="s0">Initial step</param>
            <param name="smax">Maximum step</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.BFGS.Run(MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.FunctionEval)">
            <summary>
            Run an unconstrained minimization using BFGS
            </summary>
            <param name="x0">Starting step</param>
            <param name="normOfFirstStep">Norm of first step</param>
            <param name="func">Multivariate function and derivative evaluator</param>
            <returns>The local minimum point</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.BFGS.RaiseIterationEvent(System.Int32,System.Double,System.Double)">
            <summary>
            Safely invoke the iteration event
            </summary>
            <param name="iteration"></param>
            <param name="objVal"></param>
            <param name="rmsDeriv"></param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.linesearchDebug">
            <summary>
            Whether to debug the line search
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.IterationsPerformed">
            <summary>
             Number of iterations performed to reach convergence (or failure)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.Epsilon">
            <summary>
            Convergence tolerance
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.MaximumStep">
            <summary>
            Maximum step
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.InitialStep">
            <summary>
            Initial step
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.MaximumIterations">
            <summary>
            Maximum number of iterations
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.BFGS.Cancel">
            <summary>
            Cancel
            </summary>
        </member>
        <member name="E:MicrosoftResearch.Infer.Maths.BFGS.OnIteration">
            <summary>
            Event triggered at each iteration
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.BFGS.ConvergenceCriteria">
            <summary>
             Convergence criteria:
            - Gradient: |grad F|/sqrt(dimensions) &lt;= eps
            - Objective: |F(k+1)-F(k)|&lt;=eps*max{|F(k)|,|F(k+1)|,1}
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.BFGS.ConvergenceCriteria.Gradient">
            <summary>
            |grad F|/sqrt(dimensions) &lt;= eps
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.BFGS.ConvergenceCriteria.Objective">
            <summary>
            |F(k+1)-F(k)|&lt;=eps*max{|F(k)|,|F(k+1)|,1}
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LBFGS.#ctor(System.Int32)">
            <summary>
            Limited-memory BFGS constructor
            </summary>
            <param name="approxDim">Approximation dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LBFGS.Init">
            <summary>
            Clear various arrays
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LBFGS.Run(MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.FunctionEval)">
            <summary>
            Run an unconstrained minimization using BFGS
            </summary>
            <param name="x0">Starting step</param>
            <param name="normOfFirstStep">Norm of first step</param>
            <param name="func">Multivariate function and derivative evaluator</param>
            <returns>The local minimum point</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.LBFGS.ApproximationDimension">
            <summary>
            Number of dimesions to use in the approximation to the inverse Hessian. 
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LBFGSArray">
            <summary>
            Implements the LBFGS compact Quasi-Newton solver on an array of Vectors (which may be sparse)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LBFGSArray.#ctor(System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="approxDim">Rank of the hessian approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LBFGSArray.Run(MicrosoftResearch.Infer.Maths.Vector[],System.Double,MicrosoftResearch.Infer.Maths.LBFGSArray.FunctionEvalArray)">
            <summary>
            Run an unconstrained minimization using LBFGS
            </summary>
            <param name="x0">Starting value</param>
            <param name="normOfFirstStep">Norm of first step</param>
            <param name="func">Multivariate function and derivative evaluator</param>
            <returns>The local minimum point</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LBFGSArray.FunctionEvalArray">
            <summary>
            Delegate type for function evaluation
            </summary>
            <param name="x">Independent value</param>
            <param name="dX">If reference is not null, calculate the deriv here</param>
            <returns>Function evaluation</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.PiecewiseVector">
            <summary>
            A one-dimensional vector of double values, optimised for the case where many contiguous ranges
            of elements have the same value.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Vector">
            <summary>
            Base class for vectors. <see cref="T:MicrosoftResearch.Infer.Maths.DenseVector"/>, <see cref="T:MicrosoftResearch.Infer.Maths.SparseVector"/>, and <see cref="T:MicrosoftResearch.Infer.Maths.ApproximateSparseVector"/>
            all inherit from this base class.
            </summary>
            <remarks>This class includes factory methods for instantiating Vectors of different <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/>
            specifications. Beyond this initial construction, application code does not need to know the
            the sparsity, and most operations can be done via this general base class which will handle sparsity correctly.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.CanSetAllElementsTo`1">
            <summary>
            Supports setting all elements to duplicates of the same value
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.CanSetAllElementsTo`1.SetAllElementsTo(`0)">
            <summary>
            Set all elements to duplicates of the given value
            </summary>
            <param name="value">The value to set to</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>
            Throws an exception.  Provided only to allow serialization of derived classes.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <summary>
            Throws an exception.  Provided only to allow serialization of derived classes.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Zero(System.Int32)">
            <summary>
            Creates a dense vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Zero(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/> specification.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Constant(System.Int32,System.Double)">
            <summary>
            Create a dense vector of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Constant(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Create a vector of given length with elements all equal to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/> specification.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Copy(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Create a vector as a copy of another vector.
            </summary>
            <param name="that">The source vector - can be dense or sparse</param>
            <remarks>Sparsity of created vector matches that of source vector</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Copy(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Create a vector as a copy of another vector with a given target sparsity
            </summary>
            <param name="that">The source vector - can be dense or sparse</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/> specification.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.FromArray(System.Double[])">
            <summary>
            Constructs a dense vector from an array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.FromArray(System.Double[],MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Constructs a vector from an array.
            </summary>
            <param name="data">1D array of elements.</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/> specification.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.FromArray(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector from part of an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.FromList(System.Collections.Generic.IList{System.Double})">
            <summary>
            Constructs a vector from a list. Maintains sparsity. 
            </summary>
            <param name="list">List to create vector from.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.FromArray(System.Int32,System.Double[],System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Constructs a vector from part of an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/> specification.</param>
            <remarks><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexOf(System.Double)">
            <summary>
            Returns the index of the first occurence of the given value in the array.
            Returns -1 if the value is not in the array
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Contains(System.Double)">
            <summary>
            Returns true if the Vector contains the specified item value
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies this vector to the given array starting at the specified index
            in the target array
            </summary>
            <param name="array">The target array</param>
            <param name="index">The start index in the target array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GetEnumerator">
            <summary>
            Gets a typed enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.CheckCompatible(MicrosoftResearch.Infer.Maths.Vector,System.String)">
            <summary>
            Checks that a given vector is the same size as this vector.
            Throws an exception if not with the given string
            </summary>
            <param name="that">The vector to check</param>
            <param name="paramName"></param>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.All(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if all elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Any(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if any elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Any(MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Boolean})">
            <summary>
            Test if any corresponding elements in this and that vector satisfy a condition
            </summary>
            <param name="that"></param>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexOfAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns an enumeration of the indices of all elements which satisfy the specified condition.
            Indices are returned in sorted order.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ToArray">
            <summary>
            Converts this vector to an array of doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetAllElementsTo(System.Double)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetTo(System.Double[])">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length matches <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetTo(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copies values from a Vector to this vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetTo(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Copies values from an Enumerable to this vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Reduce(System.Double,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and that vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and two other vectors
            </summary>
            <param name="initial">Initial value</param>
            <param name="a">A second vector</param>
            <param name="b">A third vector</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Sum">
            <summary>
            Returns the sum of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Sum(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the sum of a function of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this vector filtered by a function of a second vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SumI">
            <summary>
            Returns the sum of over zero-based index * element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SumISq">
            <summary>
            Returns the sum of over square of index^2 times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Max">
            <summary>
            Returns the maximum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Max(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the maximum of a function of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Min">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Min(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the minimum of a function of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Median">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.LogSumExp">
            <summary>
            Returns the log of the sum of exponentials of the elements of the vector
            computed to high accuracy
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexOfMinimum">
            <summary>
            Returns the index of the minimum element.
            </summary>
            <returns>The index of the minimum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexOfMaximum">
            <summary>
            Returns the index of the maximum element.
            </summary>
            <returns>The index of the maximum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexAtCumulativeSum(System.Double)">
            <summary>
            Returns the index of the first element at which the sum of all elements so far is greater
            than a particular value. Useful for finding the median of a Discrete distribution.
            </summary>
            <param name="targetSum">The sum of interest</param>
            <returns>
            The index of the element where <paramref name="targetSum"/> is exceeded 
            or -1 if <paramref name="targetSum"/> cannot be exceeded.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Inner(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product of this vector with another vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Inner(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this vector with a second vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this vector with a function of a second vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Outer(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the outer product of this vector with another vector.
            </summary>
            <param name="that">Second vector.</param>
            <returns>Their outer product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToDiagonal(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the diagonal of a matrix.
            </summary>
            <param name="m">A matrix with Rows==Cols==this.Count.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Scale(System.Double)">
            <summary>
            Multiplies this vector by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns></returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of a given vector
            </summary>
            <param name="that">The given vector</param>
            <param name="fun">The function which maps doubles to doubles</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of two vectors
            </summary>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <param name="fun">The function which maps two doubles to a double</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToPower(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to the elementwise power of another vector.
            </summary>
            <param name="that">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="exponent">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="that"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the elementwise product of two other vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSum(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to a linear combination of two other vectors
            </summary>
            <param name="aScale">The multiplier for vector a</param>
            <param name="a">Vector a</param>
            <param name="bScale">The multiplier for vector b</param>
            <param name="b">Vector b</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSum(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the elementwise sum of two other vectors.
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSum(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to another vector plus a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToDifference(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the difference of two vectors
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> receives the difference, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToDifference(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Set this vector to another vector minus a constant
            </summary>
            <param name="a">The other vector</param>
            <param name="b">The constant</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToDifference(System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to a constant minus another vector
            </summary>
            <param name="a">The constant</param>
            <param name="b">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to a vector times a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the product of a vector by a matrix (i.e. x*A).
            </summary>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <param name="A">A matrix.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to the product of a matrix by a vector (i.e. A*x).
            </summary>
            <param name="A">A matrix.</param>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the elementwise ratio of two other vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Multiply(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Multiplies every element of a vector by a scalar.
            </summary>
            <param name="a">A vector.</param>
            <param name="b">A scalar.</param>
            <returns>A new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Multiply(System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Multiply every element of this vector by a scalar.
            </summary>
            <param name="a">A vector.</param>
            <param name="b">A scalar.</param>
            <returns>A new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_ExclusiveOr(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns a vector to some power.
            </summary>
            <param name="a">A vector.</param>
            <param name="b">A scalar.</param>
            <returns>A new vector with this[i] = Math.Pow(a[i],b).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Multiply(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the elementwise product of two vectors.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>A new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Addition(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Add a scalar to every element of a vector.
            </summary>
            <param name="a">A vector.</param>
            <param name="b">A scalar.</param>
            <returns>A vector with the sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Addition(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the sum of two vectors.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>The sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Subtraction(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the difference of two vectors
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>The difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Subtraction(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Subtracts a scalar from each element of a vector.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">A scalar.</param>
            <returns>The difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Subtraction(System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Subtracts a scalar from each element of a vector.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">A scalar.</param>
            <returns>The difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_UnaryNegation(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a vector which is the unary negation of a vector.
            </summary>
            <param name="a">The vector to negate.</param>
            <returns>The negation of a.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Division(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the ratio of two vectors
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>The difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.InnerProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product of two vectors.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>The inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Equality(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Equality operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if the vectors have the same size and element values.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Inequality(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Inequality operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if vectors are not equal.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another (DenseVector) object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.EqualsAll(System.Double)">
            <summary>
            Tests if all elements are equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GreaterThan(System.Double)">
            <summary>
            Tests if all elements are strictly greater than a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are strictly greater than <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.LessThan(System.Double)">
            <summary>
            Tests if all elements are strictly less than a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are strictly less than <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GreaterThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly greater than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly greater than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.LessThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly less than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GreaterThanOrEqual(System.Double)">
            <summary>
            Tests if all elements are greater than or equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are greater than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.LessThanOrEqual(System.Double)">
            <summary>
            Tests if all elements are less than or equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are less than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is greater than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.LessThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is less than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_GreaterThan(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Greater than operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if each element in the first vector is greater than the corresponding element in the second vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_GreaterThan(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Greater than operator.
            </summary>
            <param name="a">Vector.</param>
            <param name="value">Value to compare against.</param>
            <returns>True if each element is greater than given value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_LessThan(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Less than operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if each element in the first vector is less than the corresponding element in the second vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_LessThan(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Less than operator.
            </summary>
            <param name="a">Vector.</param>
            <param name="value">Value to compare against.</param>
            <returns>True if each element is less than given value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Greater than or equal to operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if each element in the first vector is not less than the corresponding element in the second vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Greater than or equal to operator.
            </summary>
            <param name="a">Vector.</param>
            <param name="value">Value to compare against.</param>
            <returns>True if each element is not less than given value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_LessThanOrEqual(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Less than or equal to operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if each element in the first vector is not greater than the corresponding element in the second vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_LessThanOrEqual(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Less than or equal to operator.
            </summary>
            <param name="a">Vector.</param>
            <param name="value">Value to compare against.</param>
            <returns>True if each element is not greater than given value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the maximum absolute difference between this vector and another vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the maximum relative difference between this vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ToString(System.String,System.String)">
            <summary>
            String representation of vector with a specified format and delimiter
            </summary>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ToString(System.String,System.String,System.Func{System.Int32,System.String})">
            <summary>
            String representation of vector with a specified format and delimiter
            and a function for converting integers to display strings.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.PredivideBy(MicrosoftResearch.Infer.Maths.UpperTriangularMatrix)">
            <summary>
            Gets the solution to Ax=b, where A is an upper triangular matrix, and b is this vector.
            Equivalent to the left-division x = A\b.
            </summary>
            <param name="A">An upper triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.PredivideByTranspose(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to A'x=b, where A is a lower triangular matrix, and b is this vector.
            Equivalent to the left-division x = A'\b.
            </summary>
            <param name="A">A lower triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.PredivideBy(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to Ax=b, where A is a lower triangular matrix, and b is this vector.
            Equivalent to the left-division x = A\b.
            </summary>
            <param name="A">A lower triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.PredivideBy(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Premultiply this vector by the inverse of a positive definite matrix
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Append(System.Double)">
            <summary>
            Appends an item to a vector - returns a new vector
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Append(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Return a new vector which is the concatenation of this vector and a second vector.
            </summary>
            <param name="second">Second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Concat(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Create a vector by concatenating two vectors.
            </summary>
            <param name="first">First vector</param>
            <param name="second">Second vector</param>
            <returns>A new vector with all elements of the first vector followed by all elements of the second vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Subvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32,System.Int32)">
            <summary>
            Copy a subvector.
            </summary>
            <param name="source">A vector whose length is at least <c>count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="source"/> to copy.</param>
            <param name="count">The number of elements to copy.</param>
            <returns>A Vector of length <paramref name="count"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSubarray(System.Double[],System.Int32)">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="values"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSubvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>
            Copies value from a vector.
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Subvector(System.Int32,System.Int32)">
            <summary>
            Create a subvector of this vector
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetSubvector(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set a subvector of this to another vector.
            </summary>
            <param name="startIndex">The index of the first element of this to copy to.</param>
            <param name="that">A vector whose length is at most <c>this.Count - startIndex</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Clone">
            <summary>
            Clones this vector - return as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ToString(System.String)">
            <summary>
            String representation of vector with a specified format for each element
            </summary>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ToString">
            <summary>
            Converts this sparse vector into a human readable string
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity">
            <summary>
            The <see cref="P:MicrosoftResearch.Infer.Maths.Vector.Sparsity"/> specification of this vector.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.IsDense">
            <summary>
            True if this vector is dense
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.IsSparse">
            <summary>
            True if is this vector is sparse (exact or approximate)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.IsApproximate">
            <summary>
            True if this vector is approximate (sparse only)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.IsExact">
            <summary>
            True if this vector is exact (dense or sparse)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.Item(System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.IsReadOnly">
            <summary>
            Is read only
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.Count">
            <summary>
            Number of elements in vector
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Zero(System.Int32)">
            <summary>
            Create a piecewise vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Constant(System.Int32,System.Double)">
            <summary>
            Create a piecewise vector of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Copy(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creator a piecewise vector as a copy of another vector (of any type)
            </summary>
            <param name="that">The source vector - can be dense or sparse</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.FromArray(System.Double[])">
            <summary>
            Constructs a piecewise vector from a dense array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.FromSubvectors(System.Int32,System.Double,System.Collections.Generic.List{MicrosoftResearch.Infer.Maths.ConstantVector})">
            <summary>
            Constructs a piecewise vector from a sorted list of subvectors, which will
            be used directly and not copied.
            </summary>
            <param name="count">Count for result</param>
            <param name="commonValue">Common value</param>
            <param name="sortedDisjointVectors">Sorted list of disjoint subvectors</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Append(System.Double)">
            <summary>
            Appends an item to a vector - returns a new piecewise vector
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Append(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a new vector which appends a second vector to this vector
            </summary>
            <param name="second">Second vector</param>
            <returns></returns>
            <remarks>If the second vector is dense then the result becomes dense</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.#ctor">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.#ctor(System.Int32)">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.#ctor(System.Int32,System.Double,System.Collections.Generic.List{MicrosoftResearch.Infer.Maths.ConstantVector})">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value, except
            for the specified list of vectors. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="sortedVectors">The list of vectors, which must be disjoint and sorted by index.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.#ctor(MicrosoftResearch.Infer.Maths.PiecewiseVector)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that">the vector to copy into this new vector</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Creates a piecewise vector from a list of doubles.
            </summary>
            <param name="dlist">the list of doubles</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GetSubvector(System.Int32)">
            <summary>
            Gets the subvector that contains the specified index, or null if none.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GetFirstCommonIndex">
            <summary>
            Gets the dense index of the first common element.
            </summary>
            <returns>Returns the dense index of the first common element or -1 if there are no common elements</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GetEnumerator">
            <summary>
            Gets a typed enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.ApplyRangeFunction(MicrosoftResearch.Infer.Maths.PiecewiseVector,MicrosoftResearch.Infer.Maths.PiecewiseVector.RangeFunc)">
            <summary>
            Applies a function to ranges in common between this vector and another
            and returns the number of elements with common values in both vectors.
            </summary>
            <param name="b"></param>
            <param name="func"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetAllElementsTo(System.Double)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetTo(System.Double[])">
            <summary>
            Copies values from an array. The minimum value is used as the common value
            </summary>
            <param name="values">An array whose length matches <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetTo(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copies values from a Vector to this vector.
            </summary>
            <param name="that"></param>
            <remarks> The source vector can be dense, in which case the
            minimum value is used as the common value.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetTo(MicrosoftResearch.Infer.Maths.PiecewiseVector)">
            <summary>
            Copies values from a piecewise vector to this piecewise vector.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToConstantInRange(System.Int32,System.Int32,System.Double)">
            <summary>
            Sets the vector to a constant value between the specified
            start and end indices inclusive (and zero elsewhere).
            </summary>
            <param name="start">The start index</param>
            <param name="end">The end index</param>
            <param name="value">The constant value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToConstantInRanges(System.Collections.Generic.IEnumerable{System.Int32},System.Double)">
            <summary>
            Sets the vector to a constant value in multiple ranges (and zero elsewhere).
            The start and end points of the ranges are specified as consecutive pairs
            in a single enumerable which must therefore have even length.
            </summary>
            <param name="startEndPairs">Enumerable containing pairs of start and end values</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetTo(System.Collections.Generic.IList{System.Double})">
            <summary>
            Copies values from a list of doubles which must have the same size as this vector.
            The 'common value' is set to the minimum value of the list.
            </summary>
            <param name="dlist"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetTo(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Copies values from a list of doubles which must have the same size as this vector,
            using the specified common value.
            </summary>
            <param name="dlist">List of doubles</param>
            <param name="commonValue">Common value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.InsertPiece(MicrosoftResearch.Infer.Maths.ConstantVector,System.Int32)">
            <summary>
            Inserts a piece into the pieces list, merging it with
            the preceding piece if they are adjacent and have the same value.
            </summary>
            <remarks>
            The calling code must ensure that 'index' is set to ensure
            that 'pieces' remains in the correct sorted order.
            This code just handles any merging necessary.
            </remarks>
            <param name="sub">The piece to insert</param>
            <param name="index">The index to insert at</param>
            <returns>The index of the piece added or merged</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetTo(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Copies values from an Enumerable to this vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Clone">
            <summary>
            Clones this vector - return as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.System#ICloneable#Clone">
            <summary>
            Clones this vector - return as an object
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another (vector) object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GreaterThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly greater than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly greater than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.LessThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly less than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is greater than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.LessThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is less than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the maximum absolute difference between this vector and another vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the maximum relative difference between this vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.All(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if all elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Any(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if any elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.IndexOfAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns an enumeration of the indices of all elements which satisfy the specified condition.
            Indices are returned in sorted order.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Reduce(System.Double,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and that vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and that vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Reduce``1(``0,System.Func{``0,System.Double,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of piecewise structure. Operates on this list
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
            <remarks>This method does not take advantage of this list's sparseness.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Sum">
            <summary>
            Returns the sum of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Sum(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the sum of a function of all elements.
            </summary>
            <param name="fun">Conversion function</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this vector filtered by a function of a second vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this piecewise vector filtered by a function of a second piecewise vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SumI">
            <summary>
            Returns the sum of over zero-based index times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SumISq">
            <summary>
            Returns the sum of over square of index^2 times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Max">
            <summary>
            Returns the maximum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Max(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the maximum of a function of the elements in the vector
            </summary>
            <param name="fun">Conversion function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Min">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Min(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <param name="fun">Conversion function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.LogSumExp">
            <summary>
            Returns the log of the sum of exponentials of the elements of the vector
            computed to high accuracy
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.IndexOfMinimum">
            <summary>
            Returns the index of the minimum element.
            </summary>
            <returns>The index of the minimum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.IndexOfMaximum">
            <summary>
            Returns the index of the maximum element.
            </summary>
            <returns>The index of the maximum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.IndexAtCumulativeSum(System.Double)">
            <summary>
            Returns the index of the first element at which the sum of all elements so far is greater
            than a particular value. Useful for finding the median of a Discrete distribution.
            </summary>
            <param name="targetSum">The sum of interest</param>
            <returns>
            The index of the element where <paramref name="targetSum"/> is exceeded 
            or -1 if <paramref name="targetSum"/> cannot be exceeded.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Inner(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product of this vector with another vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Inner(MicrosoftResearch.Infer.Maths.PiecewiseVector)">
            <summary>
            Returns the inner product of this piecewise vector with another piecewise vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Inner(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of this vector with a function of a second vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Inner(MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of this piecewise vector with a function of a second piecewise vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this vector with a function of a second vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this piecewise vector with a function of a second piecewise vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToDiagonal(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the diagonal of a matrix.
            </summary>
            <param name="m">A matrix with Rows==Cols==this.Count.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Scale(System.Double)">
            <summary>
            Multiplies this vector by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns></returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Contains(System.Double)">
            <summary>
            Returns true if the Vector contains the specified value
            </summary>
            <param name="value">The value to test for</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.IndexOf(System.Double)">
            <summary>
            Returns the index of the first occurence of the given value in the array.
            Returns -1 if the value is not in the array
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies this vector to the given array starting at the specified index
            in the target array
            </summary>
            <param name="array">The target array</param>
            <param name="index">The start index in the target array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of a given vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The given vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToFunction(MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this piecewise vector to a function of the elements of another piecewise vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of two vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToFunction(MicrosoftResearch.Infer.Maths.PiecewiseVector,MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this piecewise vector to a function of the elements of two other piecewise vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToFunctionInPlace(MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this piecewise vector to a function of the elements of this piecewise vector and another piecewise vectors
            x = fun(x,b)
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.ToString(System.String)">
            <summary>
            String representation of vector with a specified format for each element
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.ToString(System.String,System.String)">
            <summary>
            String representation of vector with a specified format and delimiter
            </summary>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.ToString(System.String,System.String,System.Func{System.Int32,System.String})">
            <summary>
            String representation of vector with a specified format and delimiter
            and a function for converting integers to display strings.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.ToArray">
            <summary>
            Converts this piecewise vector to an array of doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.ToVector">
            <summary>
            Converts this piecewise vector to an ordinary dense vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>
            Copies values from a vector. If the source vector is piecewise, then the common value
            is set to the common value from the source vector. If the source vector
            is dense, then the common value is set to the minimum of the data in the source vector
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.PiecewiseVector,System.Int32)">
            <summary>
            Copies values from a piecewise vector. The common value is set to the common value
            from the source vector.
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.Subvector(System.Int32,System.Int32)">
            <summary>
            Create a subvector of this piecewise vector.
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.FromXml(System.Xml.XmlReader)">
            <summary>
            Read a PiecewiseVector from XML.
            </summary>
            <param name="reader"></param>
            <returns>PiecewiseVector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PiecewiseVector.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Write to XML.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.PiecewiseVector.Pieces">
            <summary>
            A list of the pieces of this vector.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.PiecewiseVector.CommonValue">
            <summary>
            The value of all elements which are not in any of the vector pieces.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.PiecewiseVector.Count">
            <summary>
            The number of elements in this vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.PiecewiseVector.Item(System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.PiecewiseVector.CommonValueCount">
            <summary>
            The number of elements that don't belong to any subvector
            and so take the common value.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.PiecewiseVector.HasCommonElements">
            <summary>
            Whether there are any elements that don't belong to a subvector
            and so take the common value.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.PiecewiseVector.RangeFunc">
            <summary>
            An action that takes a range and two values.
            </summary>
            <param name="start">The start of the range</param>
            <param name="end">The end of the range</param>
            <param name="value1">The first value</param>
            <param name="value2">The second value</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.ConstantVector">
            <summary>
            A vector which has a constant value between its start and end indices.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ConstantVector.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ConstantVector.Contains(System.Int32)">
            <summary>
            True if the index lies inside this vector.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ConstantVector.ToString">
            <summary>
            String representation of this constant vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ConstantVector.ToString(System.String,System.Func{System.Int32,System.String})">
            <summary>
            String representation of this constant vector using the supplied value format
            and function for converting ints to strings.
            </summary>
            <param name="format"></param>
            <param name="intToString"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ConstantVector.CompareTo(System.Object)">
            <summary>
            Compares this constant vector to another one.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ConstantVector.Start">
            <summary>
            The start index
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ConstantVector.End">
            <summary>
            The end index
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ConstantVector.Value">
            <summary>
            The value of the vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ConstantVector.Count">
            <summary>
            The number of elements in this vector
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SubvectorOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.Vector.Subvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32,System.Int32)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="subvector">Constant value for 'subvector'.</param>
            <param name="source">Constant value for 'source'.</param>
            <param name="startIndex">Constant value for 'startIndex'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(subvector,source,startIndex,count))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="subvector">Constant value for 'subvector'.</param>
            <param name="source">Constant value for 'source'.</param>
            <param name="startIndex">Constant value for 'startIndex'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(subvector,source,startIndex,count))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="subvector">Constant value for 'subvector'.</param>
            <param name="source">Constant value for 'source'.</param>
            <param name="startIndex">Constant value for 'startIndex'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(subvector,source,startIndex,count))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'SourceVariance'
            </summary>
            <param name="Source">Incoming message from 'source'.</param>
            <returns>Initial value of buffer 'SourceVariance'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Update the buffer 'SourceVariance'
            </summary>
            <param name="Source">Incoming message from 'source'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Source"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'SourceMean'
            </summary>
            <param name="Source">Incoming message from 'source'.</param>
            <returns>Initial value of buffer 'SourceMean'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Update the buffer 'SourceMean'
            </summary>
            <param name="Source">Incoming message from 'source'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="SourceVariance">Buffer 'SourceVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Source"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="subvector">Constant value for 'subvector'.</param>
            <param name="SourceMean">Buffer 'SourceMean'.</param>
            <param name="SourceVariance">Buffer 'SourceVariance'.</param>
            <param name="startIndex">Constant value for 'startIndex'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(subvector,source,startIndex,count))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="subvector">Constant value for 'subvector'.</param>
            <param name="SourceMean">Buffer 'SourceMean'.</param>
            <param name="SourceVariance">Buffer 'SourceVariance'.</param>
            <param name="startIndex">Constant value for 'startIndex'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(subvector,source,startIndex,count))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="subvector">Incoming message from 'subvector'.</param>
            <param name="to_subvector">Outgoing message to 'subvector'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(subvector) p(subvector) factor(subvector,source,startIndex,count))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="subvector">Incoming message from 'subvector'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(subvector) p(subvector) factor(subvector,source,startIndex,count) / sum_subvector p(subvector) messageTo(subvector))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SubvectorAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'subvector'
            </summary>
            <param name="SourceMean">Buffer 'SourceMean'.</param>
            <param name="SourceVariance">Buffer 'SourceVariance'.</param>
            <param name="startIndex">Constant value for 'startIndex'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'subvector' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'source'
            </summary>
            <param name="subvector">Incoming message from 'subvector'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="startIndex">Constant value for 'startIndex'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'source' as the random arguments are varied.
            The formula is <c>proj[p(source) sum_(subvector) p(subvector) factor(subvector,source,startIndex,count)]/p(source)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="subvector"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceAverageConditional(MicrosoftResearch.Infer.Maths.Vector,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'source'
            </summary>
            <param name="subvector">Constant value for 'subvector'.</param>
            <param name="startIndex">Constant value for 'startIndex'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'source' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(subvector,source,startIndex,count))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SubvectorAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'subvector'
            </summary>
            <param name="SourceMean">Buffer 'SourceMean'.</param>
            <param name="SourceVariance">Buffer 'SourceVariance'.</param>
            <param name="startIndex">Constant value for 'startIndex'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'subvector' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'source'
            </summary>
            <param name="subvector">Incoming message from 'subvector'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="startIndex">Constant value for 'startIndex'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'source' with 'subvector' integrated out.
            The formula is <c>sum_subvector p(subvector) factor(subvector,source,startIndex,count)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="subvector"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="subvector"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubvectorOp.SourceAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'source'
            </summary>
            <param name="subvector">Constant value for 'subvector'.</param>
            <param name="startIndex">Constant value for 'startIndex'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'source' conditioned on the given values.
            </para></remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:MicrosoftResearch.Infer.Factors.VectorElementOp" -->
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'ArrayVariance'
            </summary>
            <param name="array">Incoming message from 'array'.</param>
            <returns>Initial value of buffer 'ArrayVariance'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Update the buffer 'ArrayVariance'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'ArrayMean'
            </summary>
            <param name="array">Incoming message from 'array'.</param>
            <returns>Initial value of buffer 'ArrayMean'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Update the buffer 'ArrayMean'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="ArrayVariance">Buffer 'ArrayVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="ArrayMean">Buffer 'ArrayMean'.</param>
            <param name="ArrayVariance">Buffer 'ArrayVariance'.</param>
            <param name="index">Constant value for 'index'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(array) p(array) factor(item,array,index))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="ArrayMean">Buffer 'ArrayMean'.</param>
            <param name="ArrayVariance">Buffer 'ArrayVariance'.</param>
            <param name="index">Constant value for 'index'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(array) p(array) factor(item,array,index))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ItemAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>
            EP message to 'item'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="ArrayMean">Buffer 'ArrayMean'.</param>
            <param name="ArrayVariance">Buffer 'ArrayVariance'.</param>
            <param name="index">Constant value for 'index'.</param>
            <returns>The outgoing EP message to the 'item' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'item' as the random arguments are varied.
            The formula is <c>proj[p(item) sum_(array) p(array) factor(item,array,index)]/p(item)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="item">Incoming message from 'item'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(item) p(item) factor(item,array,index)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="item"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayAverageConditional(System.Double,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="ArrayMean">Buffer 'ArrayMean'.</param>
            <param name="ArrayVariance">Buffer 'ArrayVariance'.</param>
            <param name="index">Constant value for 'index'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="item">Incoming message from 'item'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ItemAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Int32)">
            <summary>
            VMP message to 'item'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="ArrayMean">Buffer 'ArrayMean'.</param>
            <param name="ArrayVariance">Buffer 'ArrayVariance'.</param>
            <param name="index">Constant value for 'index'.</param>
            <returns>The outgoing VMP message to the 'item' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'item' as the random arguments are varied.
            The formula is <c>proj[sum_(array) p(array) factor(item,array,index)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="item">Incoming message from 'item'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'item' integrated out.
            The formula is <c>sum_item p(item) factor(item,array,index)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="item"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorElementOp.ArrayAverageLogarithm(System.Double,System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SubarrayOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Subarray``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})"/>, given random arguments to the function.
            This factor gets a sub-array of different items from an array of items
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogAverageFactor(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Constant value for 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items) p(items) factor(items,array,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogAverageFactor``1(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogAverageFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogAverageFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Constant value for 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items) p(items) factor(items,array,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{``0})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items) p(items) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ItemsAverageConditional``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            EP message to 'items'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'items' as the random arguments are varied.
            The formula is <c>proj[p(items) sum_(array) p(array) factor(items,array,indices)]/p(items)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="items">Incoming message from 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(items) p(items) factor(items,array,indices)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(items) p(items) factor(items,array,indices)]/p(array)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(items,array,indices))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ItemsAverageLogarithm``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            VMP message to 'items'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'items' as the random arguments are varied.
            The formula is <c>proj[sum_(array) p(array) factor(items,array,indices)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ArrayAverageLogarithm``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="items">Incoming message from 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'items' integrated out.
            The formula is <c>sum_items p(items) factor(items,array,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ArrayAverageLogarithm``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'items' integrated out.
            The formula is <c>sum_items p(items) factor(items,array,indices)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PowerPlate">
            <summary>
            Power plate factor method
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlate.Enter``1(``0,System.Double)">
            <summary>
            Copy a value from outside to the inside of a power plate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="exponent"></param>
            <returns>A copy of value.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PowerPlateOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.PowerPlate.Enter``1(``0,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.ValueAverageConditional``1(``0,System.Double,``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="enter">Incoming message from 'enter'.</param>
            <param name="exponent">Constant value for 'exponent'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = (enter,exponent)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.EnterAverageConditional``1(``0,``0,System.Double,``0)">
            <summary>
            EP message to 'enter'.
            </summary>
            <param name="enter">Incoming message from 'enter'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="exponent">Constant value for 'exponent'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'enter'.
            The formula is <c>int f(enter,x) q(x) dx</c> where <c>x = (value,exponent)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.AverageLogFactor">
            <summary>
            Returns 0.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.ValueAverageLogarithm``1(``0,System.Double,``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="enter">Incoming message from 'enter'.</param>
            <param name="exponent">Constant value for 'exponent'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.EnterAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'enter'.
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Damp">
            <summary>
            Damp factor methods
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Damp.Backward``1(``0,System.Double)">
            <summary>
            Copy a value and damp the backward message.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="stepsize">1.0 means no damping, 0.0 is infinite damping.</param>
            <returns></returns>
            <remarks>
            If you use this factor, be sure to increase the number of algorithm iterations appropriately.
            The number of iterations should increase according to the reciprocal of stepsize.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Damp.Forward``1(``0,System.Double)">
            <summary>
            Copy a value and damp the forward message.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="stepsize">1.0 means no damping, 0.0 is infinite damping.</param>
            <returns></returns>
            <remarks>
            If you use this factor, be sure to increase the number of algorithm iterations appropriately.
            The number of iterations should increase according to the reciprocal of stepsize.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DampBackwardOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Damp.Backward``1(``0,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampBackwardOp.LogEvidenceRatio">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(backward,value,stepsize))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampBackwardOp.ValueAverageConditional``1(``0,System.Double,``0)">
            <summary>
            EP message to 'value'
            </summary>
            <param name="backward">Incoming message from 'backward'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="stepsize">Constant value for 'stepsize'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'value' as the random arguments are varied.
            The formula is <c>proj[p(value) sum_(backward) p(backward) factor(backward,value,stepsize)]/p(value)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="backward"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampBackwardOp.BackwardAverageConditional``1(``0)">
            <summary>
            EP message to 'backward'
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'backward' as the random arguments are varied.
            The formula is <c>proj[p(backward) sum_(value) p(value) factor(backward,value,stepsize)]/p(backward)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DampForwardOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Damp.Forward``1(``0,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampForwardOp.LogEvidenceRatio">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(forward,value,stepsize))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampForwardOp.ForwardAverageConditional``1(``0,System.Double,``0)">
            <summary>
            EP message to 'forward'
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="stepsize">Constant value for 'stepsize'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'forward' as the random arguments are varied.
            The formula is <c>proj[p(forward) sum_(value) p(value) factor(forward,value,stepsize)]/p(forward)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampForwardOp.ValueAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'value'
            </summary>
            <param name="forward">Incoming message from 'forward'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'value' as the random arguments are varied.
            The formula is <c>proj[p(value) sum_(forward) p(forward) factor(forward,value,stepsize)]/p(value)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BooleanOrOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Or(System.Boolean,System.Boolean)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(or,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(or,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AverageLogFactor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(or,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,System.Boolean)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="or">Incoming message from 'or'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(or) p(or) factor(or,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'or'
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'or' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'or' as the random arguments are varied.
            The formula is <c>proj[p(or) sum_(a,b) p(a,b) factor(or,a,b)]/p(or)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'or'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'or' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'or' as the random arguments are varied.
            The formula is <c>proj[p(or) sum_(b) p(b) factor(or,a,b)]/p(or)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'or'
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'or' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'or' as the random arguments are varied.
            The formula is <c>proj[p(or) sum_(a) p(a) factor(or,a,b)]/p(or)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(or,b) p(or,b) factor(or,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(b) p(b) factor(or,a,b)]/p(a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(or) p(or) factor(or,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(or,a) p(or,a) factor(or,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(or) p(or) factor(or,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(a) p(a) factor(or,a,b)]/p(b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="or">Incoming message from 'or'.</param>
            <param name="to_or">Outgoing message to 'or'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(or) p(or) factor(or,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(or,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(or,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(or,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="or">Incoming message from 'or'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(or) p(or) factor(or,a,b) / sum_or p(or) messageTo(or))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(or,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(or,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(or,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(or,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'or'
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'or' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'or' as the random arguments are varied.
            The formula is <c>proj[sum_(a,b) p(a,b) factor(or,a,b)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'or'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'or' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'or' as the random arguments are varied.
            The formula is <c>proj[sum_(b) p(b) factor(or,a,b)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'or'
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'or' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'or' as the random arguments are varied.
            The formula is <c>proj[sum_(a) p(a) factor(or,a,b)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            Because the factor is deterministic, 'or' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(b) p(b) log(sum_or p(or) factor(or,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' with 'or' integrated out.
            The formula is <c>sum_or p(or) factor(or,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(or,a,b)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            Because the factor is deterministic, 'or' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(a) p(a) log(sum_or p(or) factor(or,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' with 'or' integrated out.
            The formula is <c>sum_or p(or) factor(or,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            The formula is <c>exp(sum_(a) p(a) log(factor(or,a,b)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.IsBetween(System.Double,System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.ForceProper">
            <summary>
            Static flag to force a proper distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogProbBetween(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            The logarithm of the probability that L &lt;= X &lt; U.
            </summary>
            <param name="X"></param>
            <param name="L">Can be negative infinity.</param>
            <param name="U">Can be positive infinity.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,x) p(isBetween,x) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(x) p(x) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,x) p(isBetween,x) factor(isBetween,x,lowerBound,upperBound) / sum_isBetween p(isBetween) messageTo(isBetween))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(x) p(x) factor(isBetween,x,lowerBound,upperBound))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            EP message to 'isBetween'
            </summary>
            <param name="X">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'isBetween' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isBetween' as the random arguments are varied.
            The formula is <c>proj[p(isBetween) sum_(x) p(x) factor(isBetween,x,lowerBound,upperBound)]/p(isBetween)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'x' as the random arguments are varied.
            The formula is <c>proj[p(x) sum_(isBetween) p(isBetween) factor(isBetween,x,lowerBound,upperBound)]/p(x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogProbBetween(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            The logarithm of the probability that L &lt;= X &lt; U.
            </summary>
            <param name="X"></param>
            <param name="L">Can be uniform.  Can be negative infinity.</param>
            <param name="U">Can be uniform.  Can be positive infinity.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,x,lowerBound,upperBound) p(isBetween,x,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(x,lowerBound,upperBound) p(x,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,x,lowerBound) p(isBetween,x,lowerBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(x,lowerBound) p(x,lowerBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,x,upperBound) p(isBetween,x,upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(x,upperBound) p(x,upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,lowerBound,upperBound) p(isBetween,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(lowerBound,upperBound) p(lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,lowerBound) p(isBetween,lowerBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(lowerBound) p(lowerBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,upperBound) p(isBetween,upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(upperBound) p(upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(isBetween,x,lowerBound,upperBound))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,x,lowerBound,upperBound) p(isBetween,x,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound) / sum_isBetween p(isBetween) messageTo(isBetween))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,x,upperBound) p(isBetween,x,upperBound) factor(isBetween,x,lowerBound,upperBound) / sum_isBetween p(isBetween) messageTo(isBetween))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,x,lowerBound) p(isBetween,x,lowerBound) factor(isBetween,x,lowerBound,upperBound) / sum_isBetween p(isBetween) messageTo(isBetween))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,lowerBound,upperBound) p(isBetween,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound) / sum_isBetween p(isBetween) messageTo(isBetween))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,upperBound) p(isBetween,upperBound) factor(isBetween,x,lowerBound,upperBound) / sum_isBetween p(isBetween) messageTo(isBetween))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isBetween,lowerBound) p(isBetween,lowerBound) factor(isBetween,x,lowerBound,upperBound) / sum_isBetween p(isBetween) messageTo(isBetween))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(x,lowerBound,upperBound) p(x,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(x,upperBound) p(x,upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(x,lowerBound) p(x,lowerBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(lowerBound,upperBound) p(lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(upperBound) p(upperBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(isBetween,x,lowerBound,upperBound))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(lowerBound) p(lowerBound) factor(isBetween,x,lowerBound,upperBound))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'isBetween'
            </summary>
            <param name="X">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'isBetween' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isBetween' as the random arguments are varied.
            The formula is <c>proj[p(isBetween) sum_(x,lowerBound,upperBound) p(x,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(isBetween)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="lowerBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'isBetween'
            </summary>
            <param name="X">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'isBetween' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isBetween' as the random arguments are varied.
            The formula is <c>proj[p(isBetween) sum_(x,upperBound) p(x,upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(isBetween)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="upperBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'isBetween'
            </summary>
            <param name="X">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'isBetween' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isBetween' as the random arguments are varied.
            The formula is <c>proj[p(isBetween) sum_(x,lowerBound) p(x,lowerBound) factor(isBetween,x,lowerBound,upperBound)]/p(isBetween)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="lowerBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'isBetween'
            </summary>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="upperBound">Incoming message from 'upperBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'isBetween' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isBetween' as the random arguments are varied.
            The formula is <c>proj[p(isBetween) sum_(lowerBound,upperBound) p(lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(isBetween)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="lowerBound"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="upperBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'isBetween'
            </summary>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'isBetween' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isBetween' as the random arguments are varied.
            The formula is <c>proj[p(isBetween) sum_(upperBound) p(upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(isBetween)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="upperBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'isBetween'
            </summary>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'isBetween' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isBetween' as the random arguments are varied.
            The formula is <c>proj[p(isBetween) sum_(lowerBound) p(lowerBound) factor(isBetween,x,lowerBound,upperBound)]/p(isBetween)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="lowerBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'lowerBound'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'lowerBound' as the random arguments are varied.
            The formula is <c>proj[p(lowerBound) sum_(isBetween,x,upperBound) p(isBetween,x,upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(lowerBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'upperBound' as the random arguments are varied.
            The formula is <c>proj[p(upperBound) sum_(isBetween,x,lowerBound) p(isBetween,x,lowerBound) factor(isBetween,x,lowerBound,upperBound)]/p(upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'x' as the random arguments are varied.
            The formula is <c>proj[p(x) sum_(isBetween,lowerBound,upperBound) p(isBetween,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'x' as the random arguments are varied.
            The formula is <c>proj[p(x) sum_(isBetween,upperBound) p(isBetween,upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'x' as the random arguments are varied.
            The formula is <c>proj[p(x) sum_(isBetween,lowerBound) p(isBetween,lowerBound) factor(isBetween,x,lowerBound,upperBound)]/p(x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'x' as the random arguments are varied.
            The formula is <c>proj[p(x) sum_(lowerBound,upperBound) p(lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(x)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'x' as the random arguments are varied.
            The formula is <c>proj[p(x) sum_(upperBound) p(upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(x)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'x' as the random arguments are varied.
            The formula is <c>proj[p(x) sum_(lowerBound) p(lowerBound) factor(isBetween,x,lowerBound,upperBound)]/p(x)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'upperBound' as the random arguments are varied.
            The formula is <c>proj[p(upperBound) sum_(isBetween,lowerBound) p(isBetween,lowerBound) factor(isBetween,x,lowerBound,upperBound)]/p(upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'upperBound' as the random arguments are varied.
            The formula is <c>proj[p(upperBound) sum_(isBetween,x) p(isBetween,x) factor(isBetween,x,lowerBound,upperBound)]/p(upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'upperBound' as the random arguments are varied.
            The formula is <c>proj[p(upperBound) sum_(isBetween) p(isBetween) factor(isBetween,x,lowerBound,upperBound)]/p(upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'upperBound' as the random arguments are varied.
            The formula is <c>proj[p(upperBound) sum_(x,lowerBound) p(x,lowerBound) factor(isBetween,x,lowerBound,upperBound)]/p(upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'upperBound' as the random arguments are varied.
            The formula is <c>proj[p(upperBound) sum_(lowerBound) p(lowerBound) factor(isBetween,x,lowerBound,upperBound)]/p(upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'upperBound' as the random arguments are varied.
            The formula is <c>proj[p(upperBound) sum_(x) p(x) factor(isBetween,x,lowerBound,upperBound)]/p(upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(System.Boolean,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'upperBound' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'lowerBound'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'lowerBound' as the random arguments are varied.
            The formula is <c>proj[p(lowerBound) sum_(isBetween,upperBound) p(isBetween,upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(lowerBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'lowerBound'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'lowerBound' as the random arguments are varied.
            The formula is <c>proj[p(lowerBound) sum_(isBetween,x) p(isBetween,x) factor(isBetween,x,lowerBound,upperBound)]/p(lowerBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'lowerBound'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'lowerBound' as the random arguments are varied.
            The formula is <c>proj[p(lowerBound) sum_(isBetween) p(isBetween) factor(isBetween,x,lowerBound,upperBound)]/p(lowerBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'lowerBound'
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'lowerBound' as the random arguments are varied.
            The formula is <c>proj[p(lowerBound) sum_(x,upperBound) p(x,upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(lowerBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'lowerBound'
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'lowerBound' as the random arguments are varied.
            The formula is <c>proj[p(lowerBound) sum_(upperBound) p(upperBound) factor(isBetween,x,lowerBound,upperBound)]/p(lowerBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'lowerBound'
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'lowerBound' as the random arguments are varied.
            The formula is <c>proj[p(lowerBound) sum_(x) p(x) factor(isBetween,x,lowerBound,upperBound)]/p(lowerBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'lowerBound'
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'lowerBound' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'isBetween'
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing VMP message to the 'isBetween' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isBetween' as the random arguments are varied.
            The formula is <c>proj[sum_(x,lowerBound,upperBound) p(x,lowerBound,upperBound) factor(isBetween,x,lowerBound,upperBound)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing VMP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'x'.
            Because the factor is deterministic, 'isBetween' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(lowerBound,upperBound) p(lowerBound,upperBound) log(sum_isBetween p(isBetween) factor(isBetween,x,lowerBound,upperBound)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'lowerBound'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing VMP message to the 'lowerBound' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'lowerBound'.
            Because the factor is deterministic, 'isBetween' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(x,upperBound) p(x,upperBound) log(sum_isBetween p(isBetween) factor(isBetween,x,lowerBound,upperBound)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'upperBound'
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing VMP message to the 'upperBound' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'upperBound'.
            Because the factor is deterministic, 'isBetween' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(x,lowerBound) p(x,lowerBound) log(sum_isBetween p(isBetween) factor(isBetween,x,lowerBound,upperBound)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <param name="to_X">Previous outgoing message to 'X'.</param>
            <returns>The outgoing VMP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <param name="to_X">Previous outgoing message to 'X'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double,System.Double)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="X">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing VMP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageLogarithm">
            <summary>
            VMP message to 'lowerBound'
            </summary>
            <returns>The outgoing VMP message to the 'lowerBound' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'lowerBound' conditioned on the given values.
            </para><para>
            Variational Message Passing does not support ConstrainBetween with Gaussian distributions, since the factor is not conjugate to the Gaussian.
            This method will throw an exception.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageLogarithm">
            <summary>
            VMP message to 'upperBound'
            </summary>
            <returns>The outgoing VMP message to the 'upperBound' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'upperBound' conditioned on the given values.
            </para><para>
            Variational Message Passing does not support ConstrainBetween with Gaussian distributions, since the factor is not conjugate to the Gaussian.
            This method will throw an exception.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Factor">
            <summary>
            A repository of commonly used factor methods.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Random``1(MicrosoftResearch.Infer.Distributions.Sampleable{``0})">
            <summary>
            Random factor - samples from a given distribution
            </summary>
            <typeparam name="DomainType">Domain type</typeparam>
            <param name="dist">Distribution to sample from</param>
            <returns>Sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Bernoulli(System.Double)">
            <summary>
            Sample from a Bernoulli distribution.
            </summary>
            <param name="probTrue">The probability that the result is true.</param>
            <returns>A random boolean value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromLogOdds(System.Double)">
            <summary>
            Sample from a Bernoulli distribution with specified log odds
            </summary>
            <param name="logOdds"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GammaFromShapeAndRate(System.Double,System.Double)">
            <summary>
            Sample from a Gamma with specified shape and scale
            </summary>
            <param name="shape"></param>
            <param name="rate"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromDiscrete(System.Int32,System.Double[])">
            <summary>
            Sample from one of many Bernoulli distributions. This factor is DEPRECATED.
            Use Gates instead.
            </summary>
            <param name="index">The index of the distribution to sample from.</param>
            <param name="probTrue">The probability that the result is true, for each index.</param>
            <returns>A random boolean value.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromBoolean(System.Boolean,System.Double[])">
            <summary>
            Sample from one of two Bernoulli distributions. This factor is DEPRECATED.
            Use Gates instead.
            </summary>
            <param name="choice">Indicates which distribution to sample from.</param>
            <param name="probTrue">The probability that the result is true, for each choice.</param>
            <returns>A random boolean value.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromBoolean(System.Boolean,System.Double,System.Double)">
            <summary>
            Sample from one of two Bernoulli distributions. This factor is DEPRECATED.
            Use Gates instead.
            </summary>
            <param name="choice">Indicates which distribution to sample from.</param>
            <param name="probTrueElseChoice">The probability that the result is true, if <paramref name="choice"/> is false.</param>
            <param name="probTrueIfChoice">The probability that the result is true, if <paramref name="choice"/> is true.</param>
            <returns>A random boolean value.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BetaFromMeanAndTotalCount(System.Double,System.Double)">
            <summary>
            Sample from a Beta distribution
            </summary>
            <param name="mean">Mean of the distribution.</param>
            <param name="totalCount">Total count (precision) of the distribution.</param>
            <returns>A sample from the distribution, i.e. a value in [0,1]. </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DirichletFromMeanAndTotalCount(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sample from a Dirichlet distribution
            </summary>
            <param name="mean">Mean of the distribution.</param>
            <param name="totalCount">Total count (precision) of the distribution.</param>
            <returns>A sample from the distribution, a probability vector. </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DirichletSymmetric(System.Int32,System.Double)">
            <summary>
            Sample from a symmetric Dirichlet distribution Dir(alpha,...,alpha)
            </summary>
            <param name="K">Dimension of the distribution.</param>
            <param name="alpha">The hyperparameter.</param>
            <returns>A sample from the distribution, a probability vector. </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Discrete(System.Int32,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sample from one of several discrete distributions.
            </summary>
            <param name="probs">Matrix holding discrete distributions as rows.</param>
            <param name="selector">Integer selecting which row of probs to sample from.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Discrete(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a discrete distribution.
            </summary>
            <param name="probs">The probability of each outcome.</param>
            <returns>A random integer from 0 to <c>probs.Length-1</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DiscreteUniform(System.Int32)">
            <summary>
            Sample from a uniform discrete distribution
            </summary>
            <param name="size">The dimension of the distribution (how many possibke distinct values</param>
            <returns>A random integer from 0 to <c>size-1</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DiscreteFromLogProbs(System.Double[])">
            <summary>
            Sample from a discrete distribution, specified by unnormalized log probabilities.
            </summary>
            <param name="logProbs">The log-probability of each outcome, plus an arbitrary constant.</param>
            <returns>A random integer from 0 to <c>logProbs.Length-1</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DiscreteFromStickBreaking(System.Double[])">
            <summary>
            Sample from a DP stick breaking prior
            </summary>
            <param name="v">Stick lengths</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Gaussian(System.Double,System.Double)">
            <summary>
            Sample from a Gaussian distribution.
            </summary>
            <param name="mean">The mean of the distribution.</param>
            <param name="precision">The precision of the distribution.  The variance will be 1/precision.</param>
            <returns>A random real number.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GaussianFromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sample from a Gaussian distribution.
            </summary>
            <param name="mean">The mean of the distribution.</param>
            <param name="variance">The variance of the distribution.  The precision will be 1/variance.</param>
            <returns>A random real number.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.VectorGaussian(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sample from a VectorGaussian distribution.
            </summary>
            <param name="mean">The mean vector of the distribution.</param>
            <param name="precision">The precision matrix of the distribution.  The variance matrix will be inv(precision).</param>
            <returns>A random real vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Poisson(System.Double)">
            <summary>
            Sample from a Poisson distribution with a specified mean
            </summary>
            <param name="mean">The mean of the Poisson distribution</param>
            <returns>An integer sample &gt;= 0</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.PoissonFromLogRate(System.Double)">
            <summary>
            Sample from a Poisson distribution with specified log mean
            </summary>
            <param name="logRate">The log mean of the Poisson distribution</param>
            <returns>An integer sample &gt;= 0</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Binomial(System.Int32,System.Double)">
            <summary>
            Sample from a Binomial distribution with specified probability of success per trial and number of trials.
            </summary>
            <param name="trialCount"></param>
            <param name="probSuccess"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Multinomial(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a Multinomial distribution with specified probabilities and number of trials.
            </summary>
            <param name="trialCount">Number of trials, >= 0</param>
            <param name="probs">Must sum to 1</param>
            <returns>An array of length <c>probs.Count</c> of integers between 0 and trialCount, whose sum is trialCount.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.MultinomialList(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a Multinomial distribution with specified probabilities and number of trials.
            </summary>
            <param name="trialCount">Number of trials, >= 0</param>
            <param name="probs">Must sum to 1</param>
            <returns>A list of length <c>probs.Count</c> of integers between 0 and trialCount, whose sum is trialCount.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Not(System.Boolean)">
            <summary>
            Negate a boolean
            </summary>
            <param name="b">The bool</param>
            <returns>The negation of a boolean argument</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Or(System.Boolean,System.Boolean)">
            <summary>
            Logical or of two booleans
            </summary>
            <param name="a">First bool</param>
            <param name="b">Second bool</param>
            <returns>a|b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.And(System.Boolean,System.Boolean)">
            <summary>
            Logical and of two booleans
            </summary>
            <param name="a">First bool</param>
            <param name="b">Second bool</param>
            <returns>a&amp;b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.Boolean,System.Boolean)">
            <summary>
            Test if two booleans are equal.
            </summary>
            <param name="a">First bool</param>
            <param name="b">Second bool</param>
            <returns>True if a==b.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.Int32,System.Int32)">
            <summary>
            Test if two integers are equal.
            </summary>
            <param name="a">First integer</param>
            <param name="b">Second integer</param>
            <returns>True if a==b.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.IsPositive(System.Double)">
            <summary>
            Test if a real number is positive.
            </summary>
            <param name="x">Any number besides NaN.</param>
            <returns>True if x>0.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.IsBetween(System.Double,System.Double,System.Double)">
            <summary>
            Test if a number is between two bounds.
            </summary>
            <param name="x">Any number besides NaN.</param>
            <param name="lowerBound">Any number besides NaN.</param>
            <param name="upperBound">Any number besides NaN.</param>
            <returns>True if (lowerBound &lt;= x) and (x &lt; upperBound)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Max(System.Double,System.Double)">
            <summary>
            Returns the maximum of the two arguments: max(a,b)
            </summary>
            <returns>a*b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.IsGreaterThan(System.Int32,System.Int32)">
            <summary>
            Test if A is greater than B.
            </summary>
            <param name="a">First integer</param>
            <param name="b">Second integer</param>
            <returns>True if a &gt; b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Int32,System.Int32)">
            <summary>
            Returns the sum of the two arguments: (a + b).
            </summary>
            <returns>a+b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Double,System.Double)">
            <summary>
            Returns the sum of the two arguments: (a + b).
            </summary>
            <returns>a+b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Difference(System.Double,System.Double)">
            <summary>
            Returns the difference of the two arguments: (a - b).
            </summary>
            <returns>a-b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Difference(System.Int32,System.Int32)">
            <summary>
            Returns the difference of the two arguments: (a - b).
            </summary>
            <returns>a-b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)">
            <summary>
            Returns the product of the two arguments a * b.
            </summary>
            <returns>a*b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Product_SHG09(System.Double,System.Double)">
            <summary>
            Returns the product of the two arguments a * b.
            </summary>
            <returns>a*b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.ProductExp(System.Double,System.Double)">
            <summary>
            Returns the product  a * exp(b).
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)">
            <summary>
            Returns the ratio of the two arguments a / b.
            </summary>
            <returns>a-b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.InnerProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product between two vectors.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>sum_i a[i]*b[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.InnerProductPartialCovariance(System.Double[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product between two vectors.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>sum_i a[i]*b[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.SumWhere(System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product between two vectors, the first of which is binary.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>sum_i a[i]*b[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Product(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Multiply matrix times vector
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>sum_j a[i,j]*b[j]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Product(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Multiply posdef matrix times scalar
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>a[i,j]*b</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Multiply scalar times posdef matrix
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>a*b[i,j]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.MatrixMultiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
            Returns the product of two matrices.
            </summary>
            <param name="A">A two-dimensional array indexed by [row,col].</param>
            <param name="B">A two-dimensional array indexed by [row,col].</param>
            <returns>A two-dimensional array indexed by [row,col].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Sum(System.Collections.Generic.IList{System.Double})">
            <summary>
            Sum the numbers in an array.
            </summary>
            <param name="array"></param>
            <returns><c>sum_i array[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.CountTrue(System.Boolean[])">
            <summary>
            Count the number of true values in the given boolean array.
            </summary>
            <param name="array">The array of booleans.</param>
            <returns>Number of true values in the given array.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.AllTrue(System.Collections.Generic.IList{System.Boolean})">
            <summary>
            True if all array elements are true.
            </summary>
            <param name="array"></param>
            <returns><c>AND_i array[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GetItem``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Get an element of an array.
            </summary>
            <typeparam name="T">Type of element in the array</typeparam>
            <param name="array">The array</param>
            <param name="index">The index to get</param>
            <returns>The item</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GetItems``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Get multiple elements of an array.
            </summary>
            <typeparam name="T">Type of element in the array</typeparam>
            <param name="array">The array</param>
            <param name="indices">Array of indices for items we want to get</param>
            <returns>The items</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Subarray``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Get multiple different elements of an array.
            </summary>
            <typeparam name="T">Type of element in the array</typeparam>
            <param name="array">The array</param>
            <param name="indices">Array of indices for items we want to get.  Must all be different.</param>
            <returns>The items</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GetItem2D``1(``0[0:,0:],System.Int32,System.Int32)">
            <summary>
            Get an element of a 2D array.
            </summary>
            <typeparam name="T">Type of element in the array</typeparam>
            <param name="array">The array</param>
            <param name="index1">The first index</param>
            <param name="index2">The second index</param>
            <returns>The item</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.ArrayFromVector(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Convert a Vector into an array of doubles.
            </summary>
            <param name="vector"></param>
            <returns>A new array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Variable``1(``0,``0@)">
            <summary>
            An internal factor.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="def"></param>
            <param name="marginal"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariable``1(``0,``0@)">
            <summary>
            An internal factor.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="def"></param>
            <param name="marginal"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)">
            <summary>
            Create an array filled with a single value.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="Def">The value to fill with.</param>
            <param name="Marginal">Dummy argument for inferring marginals.</param>
            <returns>A new array with all entries set to value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Replicate``1(``0,System.Int32)">
            <summary>
            Create an array filled with a single value. For reference types,
            the replicates all reference the same instance
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="value">The value to fill with.</param>
            <param name="count">Number of replicates</param>
            <returns>A new array with all entries set to value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.ReplicateNd``1(``0)">
            <summary>
            Create a multidimensional array filled with a single value.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="value">The value to fill with.</param>
            <returns>A new array with all entries set to value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.ReplicateWithMarginal``1(``0,System.Int32,``0@)">
            <summary>
            Create an array filled with a single value.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="Def">The value to fill with.</param>
            <param name="Marginal">Dummy argument for inferring marginals.</param>
            <returns>A new array with all entries set to value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Copy``1(``0)">
            <summary>
            Passes the input through to the output.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="value">The value to return.</param>
            <returns>The supplied value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.OffsetCopy``1(``0)">
            <summary>
            Passes the input through to the output.  Used to support offset indices.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="value">The value to return.</param>
            <returns>The supplied value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.FunctionEvaluate(MicrosoftResearch.Infer.Distributions.IFunction,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Function evaluate factor
            </summary>
            <param name="func">Function</param>
            <param name="x">Function input</param>
            <returns>Function output</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Rotate(System.Double,System.Double,System.Double)">
            <summary>
            Rotate a 2D vector about the origin
            </summary>
            <param name="x1">First coordinate of vector</param>
            <param name="x2">Second coordinate of vector</param>
            <param name="angle">Counter-clockwise rotation angle in radians</param>
            <returns>The rotated vector</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`1">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`2">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`3">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`4">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`5">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainMethod`1">
            <summary>
            Delegate definition for constraint method with one argument
            </summary>
            <typeparam name="T1">Argument type for the constraint method</typeparam>
            <param name="arg1">Argument for the constraint method</param>
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainMethod`2">
            <summary>
            Delegate definition for constraint method with two arguments
            </summary>
            <typeparam name="T1">First argument type for the constraint method</typeparam>
            <typeparam name="T2">Second argument type for the constraint method</typeparam>
            <param name="arg1">First argument for the constraint method</param>
            <param name="arg2">Second argument for the constraint method</param>
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainMethod`3">
            <summary>
            Delegate definition for constraint method with three arguments
            </summary>
            <typeparam name="T1">First argument type for the constraint method</typeparam>
            <typeparam name="T2">Second argument type for the constraint method</typeparam>
            <typeparam name="T3">Third argument type for the constraint method</typeparam>
            <param name="arg1">First argument for the constraint method</param>
            <param name="arg2">Second argument for the constraint method</param>
            <param name="arg3">Third argument for the constraint method</param>
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainMethod`4">
            <summary>
            Delegate definition for constraint method with four arguments
            </summary>
            <typeparam name="T1">First argument type for the constraint method</typeparam>
            <typeparam name="T2">Second argument type for the constraint method</typeparam>
            <typeparam name="T3">Third argument type for the constraint method</typeparam>
            <typeparam name="T4">Fourth argument type for the constraint method</typeparam>
            <param name="arg1">First argument for the constraint method</param>
            <param name="arg2">Second argument for the constraint method</param>
            <param name="arg3">Third argument for the constraint method</param>
            <param name="arg4">Fourth argument for the constraint method</param>
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseGaussianList">
            <summary>
            Represents a sparse list of Gaussian distributions, optimised for the case where many share 
            the same parameterisation.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGaussianList.DefaultTolerance">
            <summary>
            Default tolerance for sparsity approximation
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.#ctor(System.Int32)">
            <summary>
            Constructs a sparse Gaussian with the specified number of elements
            all of which are set to uniform
            </summary>
            <param name="size">The size of the list</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.#ctor(System.Int32,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Constructs a sparse Gaussian list of the given size, and assigns all
            elements to the specified common value
            </summary>
            <param name="size">The size of the list</param>
            <param name="commonValue">The common value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.#ctor(System.Int32,MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{MicrosoftResearch.Infer.Distributions.Gaussian}})">
            <summary>
            Constructs a sparse Gaussian list of a given length and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list</param>
            <param name="commonValue">The common value</param>
            <param name="sortedSparseValues">The sorted list of non-common values</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.#ctor(MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.#ctor(System.Double)">
            <summary>
            Constructs a sparse Gaussian list with the given tolerance
            </summary>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs a sparse Gaussian with the specified number of elements
            all of which are set to uniform
            </summary>
            <param name="size">The size of the list</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.#ctor(System.Int32,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Constructs a sparse Gaussian list of the given size, and assigns all
            elements to the specified common value
            </summary>
            <param name="size">The size of the list</param>
            <param name="commonValue">The common value</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.#ctor(System.Int32,MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{MicrosoftResearch.Infer.Distributions.Gaussian}},System.Double)">
            <summary>
            Constructs a sparse Gaussian list of a given length and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list</param>
            <param name="commonValue">The common value</param>
            <param name="sortedSparseValues">The sorted list of non-common values</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromSize(System.Int32,System.Double)">
            <summary>
            Constructs a sparse Gaussian with the specified number of elements
            all of which are set to uniform
            </summary>
            <param name="size"></param>
            <param name="tolerance">The tolerance for the approximation</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromGaussian(System.Int32,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Constructs a sparse Gaussian with the specified number of elements
            all of which are set to the specified Gaussian
            </summary>
            <param name="size">Size</param>
            <param name="commonValue">The common value</param>
            <param name="tolerance">The tolerance for the approximation</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromSparseValues(System.Int32,MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{MicrosoftResearch.Infer.Distributions.Gaussian}},System.Double)">
            <summary>
            Returns a sparse Gaussian list of a given length and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list</param>
            <param name="commonValue">The common value</param>
            <param name="sortedSparseValues">The sorted list of non-common values</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromMeanAndVariance(System.Int32,System.Double,System.Double,System.Double)">
             <summary>
            Creates a sparse Gaussian list of a given size, with each
             element having a given mean and variance.
             </summary>
             <param name="size">The size of the list</param>
             <param name="mean">The desired mean.</param>
             <param name="variance">The desired variance.</param>
             <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromMeanAndPrecision(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Creates a sparse Gaussian list of a given size, with each
            element having a given mean and precision.
            </summary>
            <param name="size">The size of the list</param>
            <param name="mean">The desired mean.</param>
            <param name="precision">The desired precision.</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromMeanAndPrecision(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Creates a sparse Gaussian list of a given size, with given mean and precision vectors.
            </summary>
            <param name="mean">The desired mean.</param>
            <param name="precision">The desired precision.</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromNatural(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Creates a sparse Gaussian list of a given size, with each
            element having the specified natural parameters
            </summary>
            <param name="size">The size of the list</param>
            <param name="meanTimesPrecision">Mean time precision</param>
            <param name="precision">Precision</param>
            <param name="tolerance">The tolerance for the approximation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromSize(System.Int32)">
            <summary>
            Constructs a sparse Gaussian with the specified number of elements
            all of which are set to uniform
            </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromGaussian(System.Int32,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Constructs a sparse Gaussian with the specified number of elements
            all of which are set to the specified Gaussian
            </summary>
            <param name="size">Size</param>
            <param name="commonValue">The common value</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromSparseValues(System.Int32,MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{MicrosoftResearch.Infer.Distributions.Gaussian}})">
            <summary>
            Returns a sparse Gaussian list of a given length and assigns all elements the given value,
            except for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally after being passed in.
            </summary>
            <param name="size">The size of the list</param>
            <param name="commonValue">The common value</param>
            <param name="sortedSparseValues">The sorted list of non-common values</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromMeanAndVariance(System.Int32,System.Double,System.Double)">
             <summary>
            Creates a sparse Gaussian list of a given size, with each
             element having a given mean and variance.
             </summary>
             <param name="size">The size of the list</param>
             <param name="mean">The desired mean.</param>
             <param name="variance">The desired variance.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromMeanAndPrecision(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a sparse Gaussian list of a given size, with each
            element having a given mean and precision.
            </summary>
            <param name="size">The size of the list</param>
            <param name="mean">The desired mean.</param>
            <param name="precision">The desired precision.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromMeanAndPrecision(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Creates a sparse Gaussian list of a given size, with given mean and precision vectors.
            </summary>
            <param name="mean">The desired mean.</param>
            <param name="precision">The desired precision.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.FromNatural(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a sparse Gaussian list of a given size, with each
            element having the specified natural parameters
            </summary>
            <param name="size">The size of the list</param>
            <param name="meanTimesPrecision">Mean time precision</param>
            <param name="precision">Precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.MaxDiff(System.Object)">
            <summary>
            Returns the maximum difference between the parameters of this sparse Gaussian list
            and another
            </summary>
            <param name="thatd">The other sparse Gaussian list</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.SetToUniform">
            <summary>
            Sets this sparse Gaussian list to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.IsUniform">
            <summary>
            Asks whether this sparse Gaussian list is uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.GetLogProb(System.Collections.Generic.IList{System.Double})">
            <summary>
            Evaluates the log of the density function
            </summary>
            <param name="value">The point at which to evaluate the density</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.Sample">
            <summary>
            Samples from this sparse Gaussian list
            </summary>
            <returns></returns>
            <remarks>This method is inefficient in that the result will be dense even though the return type is sparse.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.Sample(System.Collections.Generic.IList{System.Double})">
            <summary>
            Samples from this sparse Gaussian list
            </summary>
            <param name="result">Where to put the result</param>
            <returns></returns>
            <remarks>This method is inefficient in that the result will be dense even though the return type is sparse.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.Sample(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Samples from a list of Gaussian distributions with the specified vectors
            of means and precisions
            </summary>
            <param name="means">Vector of means</param>
            <param name="precs">Vector of precisions</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.SetTo(MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            Sets this sparse Gaussian list to another sparse Gaussian list
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.Clone">
            <summary>
            Clones this sparse Gaussian list.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.SetToProduct(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            Sets this sparse Gaussian list to the product of two other sparse Gaussian lists
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.SetToPower(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Double)">
            <summary>
            Sets this sparse Gaussian list to the power of another sparse Gaussian list
            </summary>
            <param name="value"></param>
            <param name="exponent"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.SetToRatio(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Boolean)">
            <summary>
            Sets this sparse Gaussian list to the ratio of two other sparse Gaussian lists
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Double,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            Creates a sparse Gaussian list whose elements match the means and variances
            of the weighted sums of the elements of two other sparse Gaussian lists.
            </summary>
            <param name="weight1">The first weight</param>
            <param name="value1">The first sparse Gaussian list</param>
            <param name="weight2">The second weight</param>
            <param name="value2">The second sparse Gaussian list</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            Returns the log of the integral of the product of this sparse Gaussian list and another sparse Gaussian list
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Double)">
            <summary>
            Returns the log of the integral of the product of this sparse Gaussian list and another sparse Gaussian list raised to a power
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGaussianList.GetAverageLog(MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            The expected logarithm of that sparse Gaussian list under this sparse Gaussian list.
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGaussianList.Dimension">
            <summary>
            The dimension of the SparseGaussianList domain
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGaussianList.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGaussianList.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Poisson">
            <summary>
            A Poisson distribution over the integers [0,infinity).
            </summary>
            <remarks><para>
            The Poisson is often used as a distribution on counts.
            The formula for the distribution is <c>p(x) = rate^x exp(-rate) / x!</c>
            where rate is the rate parameter.
            In this implementation, we use a generalization called the Conway-Maxwell Poisson or "Com-Poisson", which
            has an extra precision parameter nu.  
            The formula for the distribution is <c>p(x) =propto rate^x / x!^nu</c>.
            With this extension, we can represent a uniform distribution via (rate=1,nu=0) and 
            a point mass via rate=0 or nu=infinity.  
            This family is closed under multiplication, while the standard Poisson is not.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Poisson.Rate">
            <summary>
            The rate parameter of the COM-Poisson distribution, always >= 0.
            </summary>
            <remarks>
            The natural parameter of the distribution is log(rate).  
            However, since rate remains >= 0 under multiplication, there
            is no harm in using rate as the parameter.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Poisson.Precision">
            <summary>
            The precision parameter of the COM-Poisson distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetMean">
            <summary>
            Gets the expected value E(x)
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetVariance">
            <summary>
            Gets the variance
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Clone">
            <summary>
            Clones this COM-Poisson. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Poisson type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.MaxDiff(System.Object)">
            <summary>
            Returns the maximum difference between the parameters of this COM-Poisson
            and another COM-Poisson
            </summary>
            <param name="that">The other COM-Poisson</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_Equality(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_Inequality(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToUniform">
            <summary>
            Sets this COM-Poisson instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.IsProper">
            <summary>
            Asks whether this instance is proper or not. A COM-Poisson distribution
            is proper if Rate >= 0 and (Precision > 0 or (Precision == 0 and Rate &lt; 1)).
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogProb(System.Int32)">
            <summary>
            Evaluates the log of of the density function of this COM-Poisson at the given value
            </summary>
            <param name="value">The value at which to calculate the density</param>
            <returns>log p(x=value)</returns>
            <remarks>
            The formula for the distribution is <c>p(x) = rate^x exp(-rate) / x!</c>
            when nu=1.  In the general case, it is <c>p(x) =propto rate^x / x!^nu</c>.
            If the distribution is improper, the normalizer is omitted.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetTo(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Sets this COM-Poisson instance to have the parameter values of another COM-Poisson instance
            </summary>
            <param name="value">The other COM-Poisson</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToProduct(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Sets the parameters to represent the product of two COM-Poissons.
            </summary>
            <param name="a">The first COM-Poisson</param>
            <param name="b">The second COM-Poisson</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_Multiply(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Creates a new COM-Poisson which is the product of two other COM-Poissons
            </summary>
            <param name="a">The first COM-Poisson</param>
            <param name="b">The second COM-Poisson</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToRatio(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two COM-Poisson distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <param name="forceProper">If true, the result has precision >= 0 and rate &lt;= 1</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_Division(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Creates a new Poisson which is the ratio of two other COM-Poissons
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToPower(MicrosoftResearch.Infer.Distributions.Poisson,System.Double)">
            <summary>
            Sets the parameters to represent the power of a COM-Poisson to some exponent.
            </summary>
            <param name="dist">The source Poisson</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Poisson,System.Double)">
            <summary>
            Raises a COM-Poisson to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Poisson,System.Double,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Set the parameters to match the moments of a mixture distribution.
            </summary>
            <param name="dist1">The first distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Gets the log of the integral of the product of this COM-Poisson with another COM-Poisson.
            </summary>
            <param name="that">The other COM-Poisson</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Poisson,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetAverageLog(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Gets the expected logarithm of a COM-Poisson under this COM-Poisson.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.FromMeanAndMeanLogFactorial(System.Double,System.Double)">
            <summary>
            Create a COM-Poisson distribution with the given sufficient statistics.
            </summary>
            <param name="mean">E[x]</param>
            <param name="meanLogFactorial">E[log(x!)]</param>
            <returns>A new COM-Poisson distribution</returns>
            <remarks>
            This routine implements maximum-likelihood estimation of a COM-Poisson distribution, as described by
            Thomas P. Minka, Galit Shmueli, Joseph B. Kadane, Sharad Borle, and Peter Boatwright,
            "Computing with the COM-Poisson distribution", CMU Tech Report 776.
            http://www.stat.cmu.edu/tr/tr776/tr776.html
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetMeanLogFactorial">
            <summary>
            Computes (sum_{x=0..infinity} log(x!) Rate^x / x!^Precision) / (sum_{x=0..infinity} Rate^x / x!^Precision )
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetSumLogFactorial(System.Double,System.Double)">
            <summary>
            Computes sum_{x=0..infinity} log(x!) lambda^x / x!^nu
            </summary>
            <param name="lambda">Rate.</param>
            <param name="nu">Precision.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetSumLogFactorial2(System.Double,System.Double)">
            <summary>
            Computes sum_{x=0..infinity} log(x!)^2 lambda^x / x!^nu
            </summary>
            <param name="lambda">Rate.</param>
            <param name="nu">Precision.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetSumXLogFactorial(System.Double,System.Double)">
            <summary>
            Computes sum_{x=0..infinity} x log(x!) lambda^x / x!^nu
            </summary>
            <param name="lambda">Rate.</param>
            <param name="nu">Precision.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogNormalizer">
            <summary>
            Gets the log normalizer of the distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogNormalizer(System.Double,System.Double)">
            <summary>
            Computes log(sum_{x=0..infinity} lambda^x / x!^nu)
            </summary>
            <param name="lambda">Rate.</param>
            <param name="nu">Precision.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogPowerSum(System.Double,System.Double,System.Double)">
            <summary>
            Computes log(sum_{x=0..infinity} x^p lambda^x / x!^nu)
            </summary>
            <param name="lambda">Rate.</param>
            <param name="nu">Precision.</param>
            <param name="p">Exponent.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample">
            <summary>
            Samples from a Poisson distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample(System.Int32)">
            <summary>
            Sample from a Poisson - use <see cref="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample"/> instead
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample(System.Double)">
            <summary>
            Samples from a Poisson distribution with given mean
            </summary>
            <param name="mean">Must be >= 0</param>
            <returns>An integer in [0,infinity)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample(System.Double,System.Double)">
            <summary>
            Samples from a COM-Poisson distribution
            </summary>
            <param name="rate">Rate.</param>
            <param name="precision">Precision.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.#ctor(System.Double)">
            <summary>
            Creates a Poisson distribution with the given mean.
            </summary>
            <param name="mean"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.#ctor(System.Double,System.Double)">
            <summary>
            Create a Com-Poisson distribution with the given rate and precision.
            </summary>
            <param name="rate"></param>
            <param name="precision"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.#ctor(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Uniform">
            <summary>
            Instantiates a uniform Com-Poisson distribution
            </summary>
            <returns>A new uniform Com-Poisson distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.PointMass(System.Int32)">
            <summary>
            Creates a Com-Poisson distribution which only allows one value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Poisson.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Poisson.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel">
            <summary>
            Linear kernel
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction">
            <summary>
            Base class for all kernel functions
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams">
            <summary>
            Interface for Kernel functions with parameters
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction">
            <summary>
            Interface for all Kernel functions
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel for a single vector
            </summary>
            <param name="x">Vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors and, optionally, returns derivatives
            with respect to the parameters
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors and, optionally, returns derivatives
            with respect to each vector, and with respect to the parameters
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector, and optionally, returns the derivatives
            with respect to the parameters
            </summary>
            <param name="x">Vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector, and optionally, returns the derivatives
            with respect to the vector and with respect to the parameters
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.NameToIndex(System.String)">
            <summary>
            Gets the index of a specified hyperparameter name
            </summary>
            <param name="thetaName">The hyper-parameter name</param>
            <returns>The index</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.IndexToName(System.Int32)">
            <summary>
            Gets the name of a specified hyperparameter index
            </summary>
            <param name="thetaIndex">The hyper-parameter index</param>
            <returns>The name</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.Write(System.IO.StreamWriter)">
            <summary>
            Writes the function parameters out to a stream
            </summary>
            <param name="sw">String Writer</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.Read(System.IO.StreamReader)">
            <summary>
            Reads the function parameters in from a stream
            </summary>
            <param name="sr">String Reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index">Index of the log hyper-parameter</param>
            <returns>The log hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.Item(System.String)">
            <summary>
            Sets or gets a log hyper-parameter by name
            </summary>
            <param name="name">Name of the hyper-parameter</param>
            <returns>The log hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.ThetaCount">
            <summary>
            Hyper-parameter count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams.TypeVersion">
            <summary>
            The version for the derived class
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.thetaNames">
            <summary>
            Hyper-parameter names
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.thetaValues">
            <summary>
            Hyper-parameter values
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.thetaName2Index">
            <summary>
            Dictionary that allows look-up of index from hype-parameter name
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.#ctor(System.Collections.Generic.IList{System.String})">
            <summary>
            Protected constructor - derived classes pass down their list
            of hyper-parameter names
            </summary>
            <param name="hyperNames"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors and, optionally, returns derivatives
            with respect to the parameters
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors and, optionally, returns derivatives
            with respect to each vector, and with respect to the parameters
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel for a single vector
            </summary>
            <param name="x">Vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector, and optionally, returns the derivatives
            with respect to the parameters
            </summary>
            <param name="x">Vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector, and optionally, returns the derivatives
            with respect to the vector and with respect to the parameters
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.NameToIndex(System.String)">
            <summary>
            Gets the index of a specified hyperparameter name
            </summary>
            <param name="thetaName">The hyper-parameter name</param>
            <returns>The index</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.IndexToName(System.Int32)">
            <summary>
            Gets the index of a specified hyperparameter name
            </summary>
            <param name="thetaIndex">The hyper-parameter index</param>
            <returns>The index</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Write(System.IO.StreamWriter)">
            <summary>
            Writes the parameters out to a stream
            </summary>
            <param name="sw">Stream writer</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Read(System.IO.StreamReader)">
            <summary>
            Read the parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Cholesky(MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction,System.Collections.Generic.Dictionary{System.Int32,MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Cholesky of Kernel matrix
            </summary>
            <param name="kf">Kernel function</param>
            <param name="xData">Data with which to build the matrix</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.HyperNames">
            <summary>
            Sets the names of the hyper-parameters. Note that this destroys any values
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index">Index of the log hyper-parameter</param>
            <returns>The log hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Item(System.String)">
            <summary>
            Sets or gets hyper-parameter by name. This indexer is not over-rideable
            </summary>
            <param name="name">Mame of the hyper-parameter</param>
            <returns>The hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.ThetaCount">
            <summary>
            Hyper-parameter count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.SetupParams(System.Double[])">
            <summary>
            Sets up names and values of parameters
            </summary>
            <param name="logVariances">Log of the weight variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.#ctor(System.Double[])">
            <summary>
            Constructs a linear kernel from vector of log variances
            </summary>
            <param name="logVariances">Log of the weight variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.InitialiseFromData(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Initialises the parameters from data. The variance is
            set as the square of the inverse of the 'length' of the
            input feature. Note that the variance we are trying to set
            up here corresponds to the variance of the weight parameters
            in a linear model, not to the variance of the input feature.
            </summary>
            <param name="X">X data - initialises variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.Read(System.IO.StreamReader)">
            <summary>
            Reads the parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ReducibleTo`1.ReduceTo(System.Int32[],MicrosoftResearch.Infer.Collections.ICursorArray{`0})">
            <summary>
            Remove dimensions via multiplication.
            </summary>
            <param name="keep">The dimensions to keep.</param>
            <param name="result">A distribution or distribution array.</param>
            <returns>An action which will perform the reduction.</returns>
            <remarks>Each element of result will be a product over the dimensions not kept.
            Result must already be the correct size.
            If keep is empty, no dimensions are kept so the result is a single distribution.
            Otherwise, result is a distribution array whose dimensions are the kept dimensions.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2">
            <summary>
            The distribution of an array of independent variables, or equivalently
            an array of distributions.
            </summary>
            <typeparam name="DistributionType"></typeparam>
            <typeparam name="DomainType"></typeparam>
            <remarks>
            This class supports all of the IDistribution methods, as well as 
            being a CursorArray<typeparamref name="DistributionType"/>.
            To support plates, it implements a ReduceTo method which removes 
            dimensions via multiplication.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.CursorArray`1">
            <summary>
            A multidimensional array of objects which share a single storage block.
            </summary>
            <remarks><para>
            A CursorArray is meant to behave like an ordinary Array, while being
            more memory-efficient.  Instead of storing multiple instances of the
            same object type, it uses a single instance as a cursor over a block
            of data.  The cursor acts like a pointer which is targeted at
            the desired part of the array (via its Start property).
            </para><para>
            The CursorArray object does not hold a pointer to the actual source data.
            It is agnostic about the actual type and layout of the 
            data that the cursor is walking over, providing a large degree of 
            flexibility in the implementation of the cursor.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ICursor.CreateSourceArray(System.Int32)">
            <summary>
            Point the cursor at a new source array.
            </summary>
            <remarks>
            The source array is allocated to have nRecords * Count positions.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ICursor.ReferenceClone">
            <summary>
            Make a new cursor object having the same source array, at the same position.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ICursor.Start">
            <summary>
            The position of the cursor in its source array.
            </summary>
            <remarks>
            Position is measured in the same units as Count.
            The instance data spans locations <c>Start, ..., Start+Count-1</c> in 
            the source array.
            </remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ICursor.Count">
            <summary>
            The number of positions in the source array that one instance consumes.
            </summary>
            <remarks>
            The cursor can be advanced to the next instance via
            <c>Start = Start + Count</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.MoveTo(System.Int32[])">
            <summary>
            Position the cursor at a multidimensional index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.MoveTo(System.Int32)">
            <summary>
            Position the cursor at a linear index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.ForEach(System.Action)">
            <summary>
            Invoke an action for each element of an array.
            </summary>
            <param name="action">A delegate which accesses the array cursor.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.ForEach(MicrosoftResearch.Infer.Collections.ICursorArray,System.Action)">
            <summary>
            Invoke an element-wise action across two arrays.
            </summary>
            <param name="that">An array of the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="action">A delegate which accesses the array cursors.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.ForEach(MicrosoftResearch.Infer.Collections.ICursorArray,MicrosoftResearch.Infer.Collections.ICursorArray,System.Action)">
            <summary>
            Invoke an element-wise action across three arrays.
            </summary>
            <param name="a">An array of the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="b">An array of the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="action">A delegate which accesses the array cursors.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Item(System.Int32[])">
            <summary>
            Retrieve an object by multidimensional index.
            </summary>
            <remarks>
            The result is a volatile cursor object, which becomes invalid
            on the next indexer call.  This can be a source of bugs, e.g.
            <c>f(a[i],a[j])</c> will not work.  If you want to save a result 
            across calls, you must make a ReferenceClone, as in:
            <c>f(a[i].ReferenceClone(), a[j])</c>.
            </remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Item(System.Int32)">
            <summary>
            Retrieve an object by linear index.
            </summary>
            <remarks><para>
            If the array is multidimensional, this will index the elements 
            sequentially in row-major order, i.e. the rightmost dimension varies
            fastest.
            </para><para>
            The result is a volatile cursor object, which becomes invalid
            on the next indexer call.  This can be a source of bugs, e.g.
            <c>f(a[i],a[j])</c> will not work.  If you want to save a result 
            across calls, you must make a ReferenceClone, as in:
            <c>f(a[i].ReferenceClone(), a[j])</c>.
            </para></remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Count">
            <summary>
            The total number of structures across all dimensions
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Lengths">
            <summary>
            The size of each dimension of the array.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Rank">
            <summary>
            The number of dimensions of the array.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.ReduceTo(System.Int32[],MicrosoftResearch.Infer.Collections.ICursorArray{`0})">
            <summary>
            Apply a reduction action to produce a smaller array.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.ReduceTo(`0)">
            <summary>
            Apply a reduction action to produce a single element distribution.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.Replicate(System.Int32[],System.Int32[])">
            <summary>
            Add dimensions to an array by replication.
            </summary>
            <param name="lengths">The result array dimensions.</param>
            <param name="newPosition">For each original dimension d, newPosition[d] is its index in the 
            result dimensions.  Length == this.Rank.</param>
            <returns>A new array which uses the same storage but a different cursor.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.Split(System.Collections.Generic.IList{System.Boolean})">
            <summary>
            Make a jagged array from a multidimensional array.
            </summary>
            <param name="isOuterDimension">For each original dimension d, 
            indicates whether it will be in the outer array. Length == this.Rank.</param>
            <returns>A jagged array [outer][inner] which uses the same storage but a different cursor.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.ToString">
            <summary>
            Overrides ToString method
            </summary>
            <returns>String representation of instance</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.IsPointMass">
            <summary>
            True if all elements are constant.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.HashedList`1">
            <summary>
            Hash-indexed list.
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            The user can supply a list and it will be automatically indexed.
            However, only changes made through this interface will be indexed properly.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray">
            <summary>
            Class that provides useful static methods for jagged arrays
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetInnermostType(System.Type)">
            <summary>
            Gets the innermost non-array type
            </summary>
            <param name="jaggedType">Jagged array type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetInnermostType``1">
            <summary>
            Gets the innermost non-array type
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetRanks(System.Type,System.Type)">
            <summary>
            Gets the ranks of a jagged array type when considered an array 
            </summary>
            <param name="jaggedType">The jagged array type</param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetRanks``2">
            <summary>
            Gets the ranks of a jagged array type when considered an array 
            over the specified leaf type
            </summary>
            <typeparam name="JaggedType">The jagged array type</typeparam>
            <typeparam name="LeafType">The leaf type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetRanks(System.Type)">
            <summary>
            Gets the ranks of a jagged array down to the first non-array type
            </summary>
            <param name="jaggedType">The jagged array type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetRanks``1">
            <summary>
            Gets the ranks of a jagged array down to the first non-array type
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetDepth(System.Type,System.Type)">
            <summary>
            Gets the depth of the jagged array when considered an
            array over the specified leaf type
            </summary>
            <param name="jaggedType"></param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetDepth``2">
            <summary>
            Gets the depth of the jagged array when considered an
            array over the specified leaf type
            </summary>
            <typeparam name="JaggedType">Jagge array type</typeparam>
            <typeparam name="LeafType">The leaf type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetDepth(System.Type)">
            <summary>
            Gets the depth of the jagged array
            </summary>
            <param name="jaggedType"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetDepth``1">
            <summary>
            Gets the depth of the jagged array
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes(System.Type,System.Type)">
            <summary>
            Gets the types at each depth of a jagged array when
            considered as a jagged array over the specified leaf type
            </summary>
            <param name="jaggedType">Jagged array type</param>
            <param name="leafType">Leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes(System.Type)">
            <summary>
            Gets the types at each depth of a jagged array
            </summary>
            <param name="jaggedType">Jagged array type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes(System.Type,System.Type,System.Type)">
            <summary>
            Gets jagged array types for the target leaf type to match
            the given jagged array considered as an array over the specified
            leaf type
            </summary>
            <param name="jaggedType">Jagged array type</param>
            <param name="leafType">Leaf type</param>
            <param name="targetLeafType">Desired leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes``2">
            <summary>
            Gets the types at each depth of a jagged array when
            considered as a jagged array over the specified leaf type
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <typeparam name="LeafType">Leaf type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes``1">
            <summary>
            Gets the types at each depth of a jagged array
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes``3">
            <summary>
            Gets jagged array types for the target leaf type to match
            the given jagged array considered as an array over the specified
            leaf type
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <typeparam name="LeafType">Leaf type</typeparam>
            <typeparam name="TargetLeafType">Target leaf type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ElementIterator(System.Collections.IEnumerable,System.Type)">
            <summary>
            Iterates over the elements of a jagged array when considered as
            an array over the specified leaf type
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ElementIterator``1(System.Collections.IEnumerable)">
            <summary>
            Iterates over the elements of a jagged array when considered as
            an array over the specified leaf type
            </summary>
            <typeparam name="LeafType">Leaf type</typeparam>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ElementIterator(System.Collections.IEnumerable)">
            <summary>
            Iterates over the elements of a jagged array
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLength(System.Collections.IEnumerable,System.Type)">
            <summary>
            Gets the total length of the jagged array when considered as
            an array over the specified leaf type.
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLongLength(System.Collections.IEnumerable,System.Type)">
            <summary>
            Gets the total long length of the jagged array when considered as
            an array over the specified leaftype.
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLength``1(System.Collections.IEnumerable)">
            <summary>
            Gets the total length of the jagged array when considered as
            an array over the specified leaf type.
            </summary>
            <typeparam name="LeafType">The leaf type</typeparam>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLongLength``1(System.Collections.IEnumerable)">
            <summary>
            Gets the total long length of the jagged array when considered as
            an array over the specified leaf type.
            </summary>
            <typeparam name="LeafType">The leaf type</typeparam>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLength(System.Collections.IEnumerable)">
            <summary>
            Gets the total length of the jagged array
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLongLength(System.Collections.IEnumerable)">
            <summary>
            Gets the total long length of the jagged array
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertToNew(System.Array,System.Type,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter)">
            <summary>
            Creates a jagged array with the same structure as another jagged array
            </summary>
            <param name="sourceArray">The source jagged array</param>
            <param name="sourceLeafType">The leaf type of the source jagged array</param>
            <param name="targetLeafType">The leaf type of the target jagged array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertToNew(System.Array,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter)">
            <summary>
            Creates a jagged array with the same structure as another jagged array
            </summary>
            <param name="sourceArray">The source jagged array</param>
            <param name="targetLeafType">The leaf type of the target jagged array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertToNew``2(System.Array,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter{``0,``1})">
            <summary>
            Creates a jagged array with the same structure as another jagged array
            </summary>
            <typeparam name="SourceLeafType">Leaf type of the source jagged array</typeparam>
            <typeparam name="TargetLeafType">Leaf type of the target jagged array</typeparam>
            <param name="sourceArray">The source array</param>
            <param name="converter">The converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertElements(System.Array,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter)">
            <summary>
            Sets the elements of a jagged array
            </summary>
            <param name="jaggedArray">The source jagged array</param>
            <param name="leafType">The leaf type of the jagged array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertElements(System.Array,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter)">
            <summary>
            Sets the elements of a jagged array
            </summary>
            <param name="jaggedArray">The source jagged array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertElements2(System.Array,System.Array,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter2)">
            <summary>
            Sets the elements of a jagged array given another jagged
            </summary>
            <param name="targetArray">The target array - also acts as a source</param>
            <param name="sourceArray">The source array</param>
            <param name="leafType">The leaf type of the target array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertElements2(System.Array,System.Array,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter2)">
            <summary>
            Sets the elements of a jagged array given another jagged
            </summary>
            <param name="targetArray">The target array - also acts as a source</param>
            <param name="sourceArray">The source array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.VisitElements(System.Collections.IEnumerable,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction)">
            <summary>
            Visits all elements with the specified leaf type, and perform the action
            </summary>
            <param name="jaggedArray">Jagged array</param>
            <param name="leafType">Element type</param>
            <param name="action">Action delegate</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.VisitElements(System.Collections.IEnumerable,MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction)">
            <summary>
            Visits all elements and perform the action
            </summary>
            <param name="jaggedArray">Jagged array</param>
            <param name="action">Action delegate</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.VisitElements2(System.Collections.IEnumerable,System.Collections.IEnumerable,System.Type,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction2)">
            <summary>
            Visits all elements oftwo jagged arrays, and perform the action
            </summary>
            <param name="jaggedArray1">First jagged array</param>
            <param name="jaggedArray2">Second jagged array</param>
            <param name="leafType1">Leaf type of first jagged array element</param>
            <param name="leafType2">Leaf type of second jagged array element</param>
            <param name="action">The action to take</param>
            <remarks>There is no checking of compatibility between the two jagged arrays</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.VisitElements2(System.Collections.IEnumerable,System.Collections.IEnumerable,MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction2)">
            <summary>
            Visits all elements oftwo jagged arrays, and perform the action
            </summary>
            <param name="jaggedArray1">First jagged array</param>
            <param name="jaggedArray2">Second jagged array</param>
            <param name="action">The action to take</param>
            <remarks>There is no checking of compatibility between the two jagged arrays</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter">
            <summary>
            Delegate for jagged array element converter
            </summary>
            <param name="elt">Jagged array element</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter`2">
            <summary>
            Delegate for jagged array element converter
            </summary>
            <typeparam name="SourceLeafType">Type of leaf elements in source array</typeparam>
            <typeparam name="TargetLeafType">Type of leaf elements in target array</typeparam>
            <param name="elt"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter2">
            <summary>
            Delegate for jagged array element converter
            </summary>
            <param name="elt1">Jagged array element 1</param>
            <param name="elt2">Jagged array element 2</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction">
            <summary>
            Delegate for jagged array element visitor
            </summary>
            <param name="elt">Jagged array element</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction2">
            <summary>
            Delegate for generic jagged array element visitor
            </summary>
            <param name="elt1">Jagged array element 1</param>
            <param name="elt2">Jagged array element 2</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SparseGPOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.FunctionEvaluate(MicrosoftResearch.Infer.Distributions.IFunction,MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="y">Constant value for 'y'.</param>
            <param name="func">Incoming message from 'func'.</param>
            <param name="x">Constant value for 'x'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(func) p(func) factor(y,func,x))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="y">Constant value for 'y'.</param>
            <param name="func">Incoming message from 'func'.</param>
            <param name="x">Constant value for 'x'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(func) p(func) factor(y,func,x))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="y">Incoming message from 'y'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(y) p(y) factor(y,func,x) / sum_y p(y) messageTo(y))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.YAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            EP message to 'y'
            </summary>
            <param name="func">Incoming message from 'func'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Constant value for 'x'.</param>
            <returns>The outgoing EP message to the 'y' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'y' as the random arguments are varied.
            The formula is <c>proj[p(y) sum_(func) p(func) factor(y,func,x)]/p(y)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="func"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.FuncAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            EP message to 'func'
            </summary>
            <param name="y">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="func">Incoming message from 'func'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Constant value for 'x'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'func' as the random arguments are varied.
            The formula is <c>proj[p(func) sum_(y) p(y) factor(y,func,x)]/p(func)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="y"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="func"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.FuncAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            EP message to 'func'
            </summary>
            <param name="y">Constant value for 'y'.</param>
            <param name="func">Incoming message from 'func'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Constant value for 'x'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'func' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="func"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LogisticOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Logistic(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogAverageFactor(System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="logistic">Constant value for 'logistic'.</param>
            <param name="x">Constant value for 'x'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(logistic,x))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogEvidenceRatio(System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="logistic">Constant value for 'logistic'.</param>
            <param name="x">Constant value for 'x'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(logistic,x))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.AverageLogFactor(System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="logistic">Constant value for 'logistic'.</param>
            <param name="x">Constant value for 'x'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(logistic,x))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="logistic">Incoming message from 'logistic'.</param>
            <param name="x">Constant value for 'x'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(logistic) p(logistic) factor(logistic,x))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="logistic">Constant value for 'logistic'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(x) p(x) factor(logistic,x))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="logistic">Constant value for 'logistic'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(x) p(x) factor(logistic,x))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="logistic">Incoming message from 'logistic'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <param name="falseMsg">Buffer 'falseMsg'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(logistic,x) p(logistic,x) factor(logistic,x))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="logistic">Incoming message from 'logistic'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <param name="to_logistic">Outgoing message to 'logistic'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(logistic,x) p(logistic,x) factor(logistic,x) / sum_logistic p(logistic) messageTo(logistic))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogisticAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'logistic'
            </summary>
            <param name="logistic">Incoming message from 'logistic'.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="falseMsg">Buffer 'falseMsg'.</param>
            <returns>The outgoing EP message to the 'logistic' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'logistic' as the random arguments are varied.
            The formula is <c>proj[p(logistic) sum_(x) p(x) factor(logistic,x)]/p(logistic)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.BetaFromMeanAndIntegral(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Find a Beta distribution with given integral and mean times a Beta weight function.
            </summary>
            <param name="mean">The desired value of the mean</param>
            <param name="logZ">The desired value of the integral</param>
            <param name="a">trueCount-1 of the weight function</param>
            <param name="b">falseCount-1 of the weight function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.XAverageConditional(System.Double)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="logistic">Constant value for 'logistic'.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.FalseMsgInit">
            <summary>
            Initialise the buffer 'falseMsg'
            </summary>
            <returns>Initial value of buffer 'falseMsg'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.FalseMsg(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Update the buffer 'falseMsg'
            </summary>
            <param name="logistic">Incoming message from 'logistic'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="falseMsg">Buffer 'falseMsg'.</param>
            <returns>New value of buffer 'falseMsg'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logistic"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="logistic">Incoming message from 'logistic'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="falseMsg">Buffer 'falseMsg'.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'x' as the random arguments are varied.
            The formula is <c>proj[p(x) sum_(logistic) p(logistic) factor(logistic,x)]/p(x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logistic"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(logistic,x))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogisticAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'logistic'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'logistic' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'logistic' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(logistic,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="logistic">Incoming message from 'logistic'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_X">Previous outgoing message to 'X'.</param>
            <returns>The outgoing VMP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'logistic' integrated out.
            The formula is <c>sum_logistic p(logistic) factor(logistic,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logistic"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.XAverageLogarithm(System.Double)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="logistic">Constant value for 'logistic'.</param>
            <returns>The outgoing VMP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LogisticOp_JJ96">
            <summary>
            Approximate inference for logistic using the Jaakkola and Jordan (1996) bound
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_JJ96.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from sample</param>
            <param name="logOdds">Incoming message from logOdds</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_JJ96.LogisticAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'logistic'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'logistic' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'logistic' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(logistic,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_JJ96.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="logistic">Incoming message from 'logistic'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'logistic' integrated out.
            The formula is <c>sum_logistic p(logistic) factor(logistic,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logistic"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99">
            <summary>
            Approximate inference for logistic using the Saul and Jordan (1999) bound
            \langle log(1+exp(x)) \rangle \leq a^2*v/2 + log(1+exp(m+(1-2a)v/2))
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from sample</param>
            <param name="logOdds">Incoming message from logOdds</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99.AInit">
            <summary>
            Initialise the buffer 'A'
            </summary>
            <returns>Initial value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99.A(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Update the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>New value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99.LogisticAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'logistic'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>The outgoing VMP message to the 'logistic' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'logistic' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(logistic,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp_SJ99.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="logistic">Incoming message from 'logistic'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_x">Previous outgoing message to 'X'.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>The outgoing VMP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'logistic' integrated out.
            The formula is <c>sum_logistic p(logistic) factor(logistic,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logistic"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CopyOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Copy``1(``0)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.LogAverageFactor(`0,`0)">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(copy,value))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.LogEvidenceRatio``1(``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="copy">Incoming message from 'copy'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(copy) p(copy) factor(copy,value) / sum_copy p(copy) messageTo(copy))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.LogEvidenceRatio``1(`0,``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="copy">Constant value for 'copy'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(value) p(value) factor(copy,value))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageConditional``1(``0)">
            <summary>
            EP message to 'value'
            </summary>
            <param name="copy">Incoming message from 'copy'.</param>
            <returns>The outgoing EP message to the 'value' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'value' as the random arguments are varied.
            The formula is <c>proj[p(value) sum_(copy) p(copy) factor(copy,value)]/p(value)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageConditional(`0)">
            <summary>
            EP message to 'value'
            </summary>
            <param name="copy">Constant value for 'copy'.</param>
            <returns>The outgoing EP message to the 'value' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'value' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageConditional``1(`0,``0)">
            <summary>
            EP message to 'value'
            </summary>
            <param name="copy">Constant value for 'copy'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'value' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.CopyAverageConditional``1(``0)">
            <summary>
            EP message to 'copy'
            </summary>
            <param name="Value">Incoming message from 'value'.</param>
            <returns>The outgoing EP message to the 'copy' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'copy' as the random arguments are varied.
            The formula is <c>proj[p(copy) sum_(value) p(value) factor(copy,value)]/p(copy)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.CopyAverageConditional(`0)">
            <summary>
            EP message to 'copy'
            </summary>
            <param name="Value">Constant value for 'value'.</param>
            <returns>The outgoing EP message to the 'copy' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'copy' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.AverageLogFactor``1(``0,``0)">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(copy,value))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.AverageLogFactor``1(``0,`0)">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(copy,value))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.AverageLogFactor``1(`0,``0)">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(copy,value))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'value'
            </summary>
            <param name="copy">Incoming message from 'copy'.</param>
            <returns>The outgoing VMP message to the 'value' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'value' with 'copy' integrated out.
            The formula is <c>sum_copy p(copy) factor(copy,value)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageLogarithm``1(`0,``0)">
            <summary>
            VMP message to 'value'
            </summary>
            <param name="copy">Constant value for 'copy'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'value' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.CopyAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'copy'
            </summary>
            <param name="Value">Incoming message from 'value'.</param>
            <returns>The outgoing VMP message to the 'copy' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'copy' as the random arguments are varied.
            The formula is <c>proj[sum_(value) p(value) factor(copy,value)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'value'
            </summary>
            <param name="copy">Incoming message from 'copy'.</param>
            <returns>The outgoing VMP message to the 'value' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'value' with 'copy' integrated out.
            The formula is <c>sum_copy p(copy) factor(copy,value)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.CopyAverageLogarithm(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            VMP message to 'copy'
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <returns>The outgoing VMP message to the 'copy' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'copy' as the random arguments are varied.
            The formula is <c>proj[sum_(value) p(value) factor(copy,value)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageLogarithm(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'value'
            </summary>
            <param name="copy">Incoming message from 'copy'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="to_value">Previous outgoing message to 'value'.</param>
            <returns>The outgoing VMP message to the 'value' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'value' with 'copy' integrated out.
            The formula is <c>sum_copy p(copy) factor(copy,value)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.AverageLogFactor(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="copy">Message from copy</param>
            <param name="value">Message from value</param>
            <param name="to_value">Message to value</param>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            This factor is implicitly maintaining the truncated Gaussian variational posterior. Therefore
            we need to remove the entropy of the Gaussian representation, and add the entropy for the
            truncated Gaussian
            <returns>Evidence</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.CopyAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'copy'
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_value">Previous outgoing message to 'value'.</param>
            <returns>The outgoing VMP message to the 'copy' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'copy' as the random arguments are varied.
            The formula is <c>proj[sum_(value) p(value) factor(copy,value)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.ValueAverageLogarithm(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'value'
            </summary>
            <param name="copy">Incoming message from 'copy'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="to_value">Previous outgoing message to 'value'.</param>
            <returns>The outgoing VMP message to the 'value' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'value' with 'copy' integrated out.
            The formula is <c>sum_copy p(copy) factor(copy,value)</c>.
            </para><para>We reverse the direction of factor to get the behaviour we want here</para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.CopyAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'copy'
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <param name="copy">Incoming message from 'copy'.</param>
            <param name="to_value">Previous outgoing message to 'value'.</param>
            <returns>The outgoing VMP message to the 'copy' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'copy' as the random arguments are varied.
            The formula is <c>proj[sum_(value) p(value) factor(copy,value)]</c>.
            </para><para>This message should include the previous contribution.</para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxProductCopyOp`1.ValueMaxConditional``1(``0,``0)">
            <summary>
            Max product message to 'value'
            </summary>
            <param name="copy">Constant value for 'copy'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'value' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxProductCopyOp`1.CopyMaxConditional``1(``0)">
            <summary>
            Max product message to 'copy'
            </summary>
            <param name="Value">Incoming message from 'value'.</param>
            <returns>The outgoing VMP message to the 'copy' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'copy' as the random arguments are varied.
            The formula is <c>proj[sum_(value) p(value) factor(copy,value)]</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.VectorGaussian">
            <summary>
            Represents a multivariate Gaussian distribution.
            </summary>
            <remarks><para>
            The distribution is parameterized by MeanTimesPrecision and Precision.
            Precision is the inverse of the variance, so a Gaussian with mean m and variance v is
            represented as Precision = inv(v), MeanTimesPrecision = inv(v)*m.
            </para><para>
            Some special cases:
            If the precision is zero, then the distribution is uniform.
            If the precision is infinite along the diagonal, then the distribution is a point mass.  The Point property
            gives the location of the point mass.
            If precision[i,i] is infinite, then the distribution is a point mass along dimension i.  Point[i] gives the mean.
            The rest of the row and column of precision must be zero.
            </para><para>
            The formula for the distribution is:
            <c>N(x;m,v) = |2*pi*v|^(-d/2) * exp(-0.5 (x-m)' inv(v) (x-m))</c>.
            When v=0, this reduces to delta(x-m).
            When v=infinity, the density is redefined to be 1.
            When v is singular, the density is redefined to be <c>exp(-0.5 x' inv(v) x + x' inv(v) m)</c>, 
            i.e. we drop the terms <c>|2*pi*v|^(-d/2) * exp(-0.5 m' inv(v) m)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanSamplePrep`2">
            <summary>
            Whether the distribution supports preallocation of a workspace for sampling
            </summary>
            <typeparam name="DistributionType">The distribution type</typeparam>
            <typeparam name="T">The domain type of the distribution</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanSamplePrep`2.SamplePrep">
            <summary>
            Return an sampler delegate which owns an sampling workspace
            </summary>
            <returns>An sampler delegate</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogProbPrep`2">
            <summary>
            Whether the distribution supports preallocation of a workspace for density evaluation
            </summary>
            <typeparam name="DistributionType">The distribution type</typeparam>
            <typeparam name="T">The domain type of the distribution</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogProbPrep`2.GetLogProbPrep">
            <summary>
            Return an evaluator delegate which owns an evaluation workspace
            </summary>
            <returns>An evaluator delegate</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVariance`2">
            <summary>
            Whether the distribution supports the joint getting of mean and variance
            where the mean and variance are reference types
            </summary>
            <typeparam name="MeanType">Mean type</typeparam>
            <typeparam name="VarType">Variance type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVariance`2.GetMeanAndVariance(`0,`1)">
            <summary>
            Get the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the mean and variance of the distribution.
            </summary>
            <param name="mean">Modified to contain the mean.  Must already be the correct size.</param>
            <param name="variance">Modified to contain the covariance matrix.  Must already be the correct size.</param>
            <remarks>Because the Gaussian stored its parameters in exponential form, it is more efficient
            to compute the mean and variance at the same time rather than separately.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMeanAndPrecision(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the mean vector and precsion matrix of the distribution
            </summary>
            <param name="mean">Modified to contain the mean.  Must already be the correct size.</param>
            <param name="precision">Modified to contain the precision matrix.  Must already be the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the mean and variance of the distribution.
            </summary>
            <param name="mean">The mean vector</param>
            <param name="variance">The covariance matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetMeanAndPrecision(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the mean and precision of the distribution.
            </summary>
            <param name="mean">The mean vector</param>
            <param name="precision">The precision matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetNatural(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the natural parameters of the distribution (mean times precision, and precision)
            </summary>
            <param name="meanTimesPrecision">Mean times precision</param>
            <param name="precision">The precision matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMean">
            <summary>
            Gets the mean of the distribution.
            </summary>
            <returns>A new Vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the mean of the distribution
            </summary>
            <param name="result">Where to place the mean value</param>
            <returns>mean</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMean(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Get the mean of the distribution
            </summary>
            <param name="result">Where to place the mean vector</param>
            <param name="variance">The pre-computed inverse of this.Precision</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetVariance">
            <summary>
            Gets the variance-covariance matrix of the distribution.
            </summary>
            <returns>A new PositiveDefiniteMatrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetVariance(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the variance-covariance matrix of the distribution.
            </summary>
            <param name="variance">Where to place the variance-covariance</param>
            <returns>variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing mean vector
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToUniform">
            <summary>
            Sets this VectorGaussian instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProb(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evaluate the log of multivariate Gaussian density with specified mean vector
            and covariance matrix
            </summary>
            <param name="x">Where to evaluate the density function</param>
            <param name="mean">The mean vector</param>
            <param name="variance">A non-singular covariance matrix.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogNormalizer">
            <summary>
            Gets the normalizer for the VectorGaussian density function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProb(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the log of the multivariate Gaussian density.
            </summary>
            <param name="x">Point to evaluate the density at.</param>
            <param name="meanTimesPrecision">Precision matrix times the mean vector.</param>
            <param name="precision">A non-singular precision matrix (inverse of covariance matrix).</param>
            <param name="L">Same size as precision.</param>
            <param name="iLb">Same size as x.</param>
            <returns>log p(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProb(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the log of the multivariate Gaussian density.
            </summary>
            <param name="x">Point to evaluate the density at.</param>
            <param name="L">Work matrix - same size as Precision</param>
            <param name="iLb">Work vector - same size as x</param>
            <returns>log p(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProb(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the log of the multivariate Gaussian density.
            </summary>
            <param name="x">Point to evaluate the density at.</param>
            <returns>log p(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProbPrep">
            <summary>
            Returns an Evaluator delegate which has a pre-allocated workspace
            for efficient evaluation calculation. If you are generating many
            evaluations, call this method to get an Evaluator, then use the Evaluator
            delegate to calculate the evaluations
            </summary>
            <returns>Evaluator delegate</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetAverageLog(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Log-integral of the product of this VectorGaussian with that VectorGaussian
            </summary>
            <param name="that">That VectorGaussian</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples from a VectorGaussian distribution with the specified mean and precision
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SampleFromMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples from a VectorGaussian distribution with the specified mean and variance
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Samples from this VectorGaussian distribution
            </summary>
            <param name="result">Where to put the result</param>
            <param name="precL">A DxD workspace</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Samples from this VectorGaussian distribution
            </summary>
            <param name="result">Where to put the result</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample">
            <summary>
            Sample from this VectorGaussian distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SamplePrep">
            <summary>
            Returns a sampler delegate which has a pre-allocated workspace
            for efficient sample calculation. If you are generating many
            samples, call this method to get a sampler, then use the sampler
            delegate to generate samples.
            </summary>
            <returns>Sampler delegate</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetTo(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Sets this VectorGaussian instance to have the parameter values of that VectorGaussian instance
            </summary>
            <param name="that">That VectorGaussian</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToProduct(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Sets the parameters to represent the product of two VectorGaussians.
            </summary>
            <param name="g1">The first VectorGaussian.  May refer to <c>this</c>.</param>
            <param name="g2">The second VectorGaussian.  May refer to <c>this</c>.</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.op_Multiply(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Creates a new VectorGaussian which the product of two other VectorGaussians
            </summary>
            <param name="a">First VectorGaussian</param>
            <param name="b">Second VectorGaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Boolean)">
            <summary>
            Sets the parameters to represent the product of two VectorGaussians.
            </summary>
            <param name="numerator">The numerator VectorGaussian</param>
            <param name="denominator">The denominator VectorGaussian</param>
            <param name="forceProper">If true, the precision of the result is made non-negative definite, under the constraint that result*denominator has the same mean as numerator</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.op_Division(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Creates a new VectorGaussian which the ratio of two other VectorGaussians
            </summary>
            <param name="numerator">numerator VectorGaussian</param>
            <param name="denominator">denominator VectorGaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToPower(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source VectorGaussian to some exponent.
            </summary>
            <param name="dist">The source VectorGaussian</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Sets the mean and covariance to match a VectorGaussian mixture.
            </summary>
            <param name="weight1">First weight</param>
            <param name="dist1">First VectorGaussian</param>
            <param name="weight2">Second weight</param>
            <param name="dist2">Second VectorGaussian</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.WeightedSum``1(``0,System.Int32,System.Double,``0,System.Double,``0)">
            <summary>
            Creates a distribution of the specified type which matchs the mean and variance/covariance
            of a VectorGaussian mixture. The distribution type must implement <see cref="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVariance`2"/> and
            <see cref="T:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2"/>
            </summary>
            <typeparam name="T">Distribution type for the mixture</typeparam>
            <param name="dimension">The dimension of the domain</param>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second distribution</param>
            <param name="result">Resulting distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this VectorGaussian
            and that VectorGaussian
            </summary>
            <param name="thatd">That VectorGaussian</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Clone">
            <summary>
            Clones this VectorGaussian. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a VectorGaussian type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor">
            <summary>
            Constructs a new VectorGaussian
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor(System.Int32)">
            <summary>
            Creates a uniform VectorGaussian of a given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Sets this VectorGaussian to the value of another
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Copy(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Creates a copy of a given VectorGaussian
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Uniform(System.Int32)">
            <summary>
            Creates a uniform VectorGaussian of a given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromCursors(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a Gaussian from Cursor objects.
            </summary>
            <param name="meanTimesPrecision">Mean times precision</param>
            <param name="precision">Precision</param>
            <remarks>The cursors will use their existing source array.
            The Gaussian will reference the given cursors.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a Gaussian with given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new Gaussian instance.</returns>
            <remarks>The mean and variance objects are copied into the Gaussian and not referenced afterwards.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.PointMass(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a VectorGaussian point mass at the specified location
            </summary>
            <param name="mean">Where to position the point mass</param>
            <returns>A new point mass VectorGaussian</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.PointMass(System.Double)">
            <summary>
            Creates a VectorGaussian point mass where the location is a
            vector of identical values
            </summary>
            <param name="mean">The value for the mean vector</param>
            <returns>A new point mass VectorGaussian</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor(System.Double,System.Double)">
            <summary>
            Creates a 1D VectorGaussian with given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromNatural(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Create a new VectorGaussian from its natural parameters (Mean times precision, and precision)
            </summary>
            <param name="meanTimesPrecision">Mean times precision</param>
            <param name="precision">Precision matrix</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a 1D VectorGaussian with given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Create a Gaussian with given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new Gaussian instance.</returns>
            <remarks>The mean and variance objects are copied into the Gaussian and not referenced afterwards.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromMeanAndPrecision(System.Double,System.Double)">
            <summary>
            Creates a 1D VectorGaussian with given mean and precision.
            </summary>
            <param name="mean">Mean</param>
            <param name="precision">Precision</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromMeanAndPrecision(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Create a VectorGaussian with given mean and precision matrix.
            </summary>
            <param name="mean">Mean</param>
            <param name="precision">Precision</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.IsProper">
            <summary>
            Asks whether this VectorGaussian instance is proper or not. A VectorGaussian distribution
            is proper only if its precision matrix is positive definite.
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMarginal(System.Int32)">
            <summary>
            The marginal distribution of one dimension.
            </summary>
            <param name="dim"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMarginal(System.Int32,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            The marginal distribution of a subvector.
            </summary>
            <param name="firstDim">The first dimension of the subvector</param>
            <param name="result">A VectorGaussian receiving the result, whose Dimension specifies the length of the subvector.</param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.MeanTimesPrecision">
            <summary>
            Gets/Sets Mean times precision
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.Precision">
            <summary>
            Gets/sets precision value
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.Dimension">
            <summary>
            The dimension of the VectorGaussian domain
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Matrix">
            <summary>
            Two-dimensional container of doubles.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.RowVector(System.Int32)">
            <summary>
            A row of the matrix.
            </summary>
            <param name="row">An integer in [0,Rows-1].</param>
            <returns>If colStride == 1, then a Vector object pointing at one row of this matrix.  Otherwise a copy of the row.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.GetEnumerator">
            <summary>
            Gets a typed enumerator for this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Contains(System.Double)">
            <summary>
            Returns true if this matrix contains the given value
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies the values in this matrix to an array starting at a given index in the destination array
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.IndexOf(System.Double)">
            <summary>
            Returns the first index of the given item if it exists in the matrix,
            otherwise returns -1
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>
            Throws an exception.  Provided only to allow serialization of derived classes.
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <summary>
            Throws an exception.  Provided only to allow serialization of derived classes.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Construct a zero matrix of the given dimensions.
            </summary>
            <param name="rows">Number of rows >= 0.</param>
            <param name="cols">Number of columns >= 0.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor(System.Double[0:,0:])">
            <summary>
            Construct a matrix from data in a 2D array.
            </summary>
            <param name="data">2D array of elements.</param>
            <remarks>The 2D array is copied into new storage.
            The size of the matrix is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor(System.Int32,System.Int32,System.Double[])">
            <summary>
            Construct a matrix by referencing an array.
            </summary>
            <param name="data">Storage for the matrix elements.</param>
            <param name="nRows">Number of rows.</param>
            <param name="nCols">Number of columns.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Clone">
            <summary>
            Fully clones this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ToArray">
            <summary>
            Creates a 2-D arrays from this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CopyTo(System.Double[0:,0:])">
            <summary>
            Copies matrix values to a two-dimensional array.
            </summary>
            <param name="values">An array whose <c>GetLength(0) >= Rows</c> and <c>GetLength(1) >= Cols</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Copies values from another matrix.
            </summary>
            <param name="that">The second matrix, which must have the same size as this.</param>
            <returns>The mutated this matrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetAllElementsTo(System.Double)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.EqualsAll(System.Double)">
            <summary>
            Tests if all elements are equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(System.Double[])">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length is at least <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(System.Double[],System.Int32)">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="values"/>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(System.Double[0:,0:])">
            <summary>
            Copies values from a two-dimensional array.
            </summary>
            <param name="values">An array whose <c>GetLength(0) >= Rows</c> and <c>GetLength(1) >= Cols</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SymmetryError">
            <summary>
            max | this[i,j] - this[j,i] |
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToIdentity">
            <summary>
            Sets the matrix to the identity.
            </summary>
            <remarks>The matrix must be square.</remarks>
            <returns>The mutated matrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToIdentityScaledBy(System.Double)">
            <summary>
            Sets the matrix to the identity times a number.
            </summary>
            <param name="scale"></param>
            <returns>The mutated matrix.</returns>
            <remarks>The matrix must be square.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Identity(System.Int32)">
            <summary>
            Creates an identity matrix of the specified size
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.IdentityScaledBy(System.Int32,System.Double)">
            <summary>
            Creates an identity matrix of the specified size, scaled by the specified value
            </summary>
            <param name="dimension"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Transpose">
            <summary>
            Transposes the matrix.
            </summary>
            <returns>The transposed matrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToTranspose(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets the matrix to the transpose of another.
            </summary>
            <param name="that">The matrix to transpose.  Can be the same object as <c>this</c>.  <c>that.Count</c> must equal <c>this.Count</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the transposed matrix, and must already
            be the correct size.
            If <c>this</c> and <paramref name="that"/> are different objects but occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToSubmatrix(MicrosoftResearch.Infer.Maths.Matrix,System.Int32,System.Int32)">
            <summary>
            Sets the matrix to a submatrix of another.
            </summary>
            <param name="that">Size must be at least <c>this.Rows+firstRow</c> by <c>this.Cols+firstColumn</c>.</param>
            <param name="firstRow">Index of the first row in <paramref name="that"/> to copy.</param>
            <param name="firstColumn">Index of the first column in <paramref name="that"/> to copy.</param>
            <returns><c>this</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetSubmatrix(System.Int32,System.Int32,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Set a submatrix of this matrix to match another matrix.
            </summary>
            <param name="firstRow">Index of the first row in <c>this</c> to copy to.</param>
            <param name="firstColumn">Index of the first column in <c>this</c> to copy to.</param>
            <param name="that">Size is at most <c>this.Rows-thisRow</c> by <c>this.Cols-thisColumn</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetSubmatrix(System.Int32,System.Int32,MicrosoftResearch.Infer.Maths.Matrix,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets a submatrix of this matrix to match another matrix.
            </summary>
            <param name="thisRow">Index of the first row in <c>this</c> to copy to.</param>
            <param name="thisColumn">Index of the first column in <c>this</c> to copy to.</param>
            <param name="that">Size is at most <c>this.Rows-firstRow</c> by <c>this.Cols-firstColumn</c>.</param>
            <param name="thatRow">Index of the first row in <paramref name="that"/> to copy.</param>
            <param name="thatColumn">Index of the first column in <paramref name="that"/> to copy.</param>
            <param name="numRows">The number of rows to copy</param>
            <param name="numColumns">The number of columns to copy</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToDiagonal(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this matrix to a diagonal matrix with diagonal values specified in the given vector
            </summary>
            <param name="diag"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetDiagonal(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the diagonal elements to the values specified in the given vector
            </summary>
            <param name="diag"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Diagonal">
            <summary>
            Creates a vector from the diagonal values in the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.EnumerateDiagonal">
            <summary>
            Enumerator which yields the diagonal elements of the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.TraceOfProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The sum of diagonal elements of a matrix product.
            </summary>
            <param name="a">A matrix of size n by m.</param>
            <param name="b">A matrix of size m by n.</param>
            <returns><c>sum_i sum_k a[i,k]*b[k,i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.DiagonalOfProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The diagonal elements of a matrix product.
            </summary>
            <param name="a">A matrix of size n by m.</param>
            <param name="b">A matrix of size m by n.</param>
            <returns><c>v[i] = sum_k a[i,k]*b[k,i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Scale(System.Double)">
            <summary>
            Multiplies this matrix by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns>this</returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ScaleRows(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Multiplies each row of this matrix by a different scalar.
            </summary>
            <param name="rowScale">The ith element scales row i.</param>
            <returns>this</returns>
            <remarks>this receives the product.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ScaleCols(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Multiplies each column of this matrix by a different scalar.
            </summary>
            <param name="colScale">The ith element scales column i.</param>
            <returns>this</returns>
            <remarks>this receives the product.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Median">
            <summary>
            Returns the median of the values in the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToElementwiseProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The element-wise product of two matrices.
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this[i,j] = a[i,j] * b[i,j]</c>.  <c>this</c> receives the product, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToElementwiseRatio(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The element-wise ratio of two matrices.
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this[i,j] = a[i,j] / b[i,j]</c>.  <c>this</c> receives the ratio, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,System.Double)">
            <summary>
            Gets a matrix times a scalar.
            </summary>
            <param name="m">A matrix, which must have the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="s">A scalar.</param>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="m"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Multiply(MicrosoftResearch.Infer.Maths.Matrix,System.Double)">
            <summary>
            Multiplies every element of a matrix by a scalar.
            </summary>
            <param name="m">A matrix.</param>
            <param name="s">A scalar.</param>
            <returns>A new matrix with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Modify <c>this</c> to be the product of two matrices.
            </summary>
            <param name="A">First matrix.  Cannot be <c>this</c>.</param>
            <param name="B">Second matrix.  Cannot be <c>this</c>.</param>
            <remarks><paramref name="A"/> and <paramref name="B"/> must have compatible dimensions.
            <c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="B"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToOuter(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Modify <c>this</c> to be the product of a matrix and its transpose (A*A').
            </summary>
            <param name="A">Matrix.  Cannot be <c>this</c>.</param>
            <remarks>
            <c>this</c> receives A*A' and must already be the correct size.
            If <c>this</c> and <paramref name="A"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
            <returns><c>this</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Outer">
            <summary>
            Returns the product of this matrix and its transpose
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToOuterTranspose(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Modify <c>this</c> to be the product of the transpose of a matrix and the matrix (A'*A).
            </summary>
            <param name="A">Matrix.  Cannot be <c>this</c>.</param>
            <remarks>
            <c>this</c> receives A'*A and must already be the correct size.
            If <c>this</c> and <paramref name="A"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
            <returns><c>this</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.OuterTranspose">
            <summary>
            Returns the transpose of this matrix times this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Multiply(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Matrix product.
            </summary>
            <param name="A">First matrix.</param>
            <param name="B">Second matrix.</param>
            <returns>A new matrix with their product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Multiply(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Premultiplies a vector by a matrix (i.e. A*x).
            </summary>
            <param name="A">A matrix.</param>
            <param name="x">A vector.</param>
            <returns>A new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Multiply(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Postmultiplies a vector by a matrix (i.e. x*A).
            </summary>
            <param name="x">A vector.</param>
            <param name="A">A matrix.</param>
            <returns>The new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToOuter(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the outer product of two vectors.
            </summary>
            <param name="a">First vector, of length <c>this.Rows</c>.</param>
            <param name="b">Second vector, of length <c>this.Cols</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToSumWithOuter(MicrosoftResearch.Infer.Maths.Matrix,System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a matrix plus the scaled outer product of two vectors.
            </summary>
            <param name="m">A matrix with the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="scale"></param>
            <param name="a">A vector with <c>a.Count == this.Rows</c></param>
            <param name="b">A vector with <c>b.Count == this.Cols</c></param>
            <returns>this[i,j] = m[i,j] + scale*a[i]*b[j]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.QuadraticForm(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the product x'Ax (where ' is transposition).
            </summary>
            <param name="x">A vector whose length equals Rows.</param>
            <remarks><c>this</c> must be a square matrix with Rows == x.Count.</remarks>
            <returns>The above product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.QuadraticForm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the product x'Ay (where ' is transposition).
            </summary>
            <param name="x">A vector whose length equals Rows.</param>
            <param name="y">A vector whose length equals Cows.</param>
            <returns>The above product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToSum(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this matrix to sum of two other matrices. Assumes compatible matrices.
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this[i,j] = a[i,j] + b[i,j]</c>.  <c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToSum(System.Double,MicrosoftResearch.Infer.Maths.Matrix,System.Double,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The sum of two matrices with scale factors.
            </summary>
            <param name="aScale">A scale factor.</param>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="bScale">A scale factor.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this[i,j] = aScale*a[i,j] + bScale*b[i,j]</c>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Addition(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Returns the sum of two matrices. Assumes compatible matrices.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <returns>Their sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToDifference(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this matrix to the difference of two matrices. Assumes compatible matrices.
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the difference, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToDifference(MicrosoftResearch.Infer.Maths.Matrix,System.Double,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this matrix to a - bScale*b
            </summary>
            <param name="a"></param>
            <param name="bScale"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Subtraction(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Returns the difference of two matrices. Assumes compatible matrices.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <returns>Their difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_UnaryNegation(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Returns the negation of a matrix.
            </summary>
            <param name="a">The matrix to negate.</param>
            <returns>The negation -a.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Equality(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Equality operator.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second Matrix.</param>
            <returns>True if the matrices have the same size and element values.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Inequality(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Inequality operator.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <returns>True if matrices are not equal.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Equals(System.Object)">
            <summary>
            Object comparator.
            </summary>
            <param name="obj">An object - must be an IntMatrix.</param>
            <returns>True if objects are equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.GetHashCode">
            <summary>
            Hash code generator.
            </summary>
            <returns>The hash code for the instance.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CheckCompatible(MicrosoftResearch.Infer.Maths.Matrix,System.String)">
            <summary>
            Checks that a given matrix is the same size as this matrix.
            Throws an exception if not with the given string
            </summary>
            <param name="that">The matrix to check</param>
            <param name="paramName"></param>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CheckSymmetry(System.String)">
            <summary>
            Checks this matrix for symmetry
            </summary>
            <param name="paramName"></param>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.MaxDiff(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Returns the maximum absolute difference between matrix elements.
            </summary>
            <param name="that">The second matrix.</param>
            <returns>max(abs(this[i,j] - that[i,j])).  
            Matching infinities or NaNs do not count.  
            If this and that are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of Equals, since Equals is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.MaxDiff(MicrosoftResearch.Infer.Maths.Matrix,System.Double)">
            <summary>
            Returns the maximum relative difference between matrix elements.
            </summary>
            <param name="that">The second matrix.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns>max(abs(this[i,j] - that[i,j])/(abs(this[i,j]) + rel)).  
            Matching infinities or NaNs do not count.  
            If this and that are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of Equals, since Equals is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ToString">
            <summary>
            ToString override
            </summary>
            <returns></returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ToString(System.String)">
            <summary>
            Convert the matrix to a string, using a specified number format
            </summary>
            <param name="format">The format string for each matrix entry</param>
            <returns>A string</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Parse(System.String)">
            <summary>
            Parse a string (in the format produced by ToString) to recover a Matrix
            </summary>
            <param name="s">The string to parse</param>
            <returns>A matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.IsPositiveDefinite">
            <summary>
            Tests for positive-definiteness.
            </summary>
            <returns>True if the matrix is positive-definite, i.e. all eigenvalues > 0.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Trace">
            <summary>
            The trace of a square matrix.
            </summary>
            <returns>The trace.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Determinant">
            <summary>
            Return the determinant of this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Inverse">
            <summary>
            Return the inverse of this matrix - not implemented yet
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Inner(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Inner product of matrices.
            </summary>
            <param name="A">A matrix with the same size as this.</param>
            <returns>sum_ij A[i,j]*this[i,j].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.PredivideBy(MicrosoftResearch.Infer.Maths.UpperTriangularMatrix)">
            <summary>
            Gets the solution to AX=B, where A is an upper triangular matrix and
            B is a matrix of right-hand sides.	It is equivalent to the left-division X = A\B.
            </summary>
            <param name="A">An upper triangular matrix with A.Rows == this.Rows.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side matrix B, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.PredivideByTranspose(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to A'X=B, where A is a lower triangular matrix.
            Equivalent to the left-division X = A'\B.
            </summary>
            <param name="A">A lower triangular matrix with A.Cols == this.Rows.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side matrix B, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.PredivideBy(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to AX=B, where A is a lower triangular matrix.
            Equivalent to the left-division X = A\B.
            </summary>
            <param name="A">A lower triangular matrix with A.Rows == this.Rows.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side matrix B, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToEigenvectorsOfSymmetric(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Set the columns to the eigenvectors of a symmetric matrix, modifying the input matrix to contain its eigenvalues on the diagonal
            </summary>
            <param name="symmetricMatrix">A symmetric matrix, modified on return to contain its eigenvalues on the diagonal</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.GetColumn(System.Int32)">
            <summary>
            Returns the specified column as an array of doubles
            </summary>
            <param name="col"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.GetRow(System.Int32)">
            <summary>
            Returns the specified row as an array of doubles
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Item(System.Int32,System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Item(System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Rows">
            <summary>
            The number of rows of the matrix.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Cols">
            <summary>
            The number of columns of the matrix.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.SourceArray">
            <summary>
            Gets/sets the matrix's source array
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Count">
            <summary>
            Number of elements in the matrix
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MatrixSingularException">
            <summary>
            Exception thrown when a singular matrix is encountered.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixSingularException.#ctor(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Construct the exception.
            </summary>
            <param name="m">The offending matrix.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MatrixSingularException.Offender">
            <summary>Gets the singular matrix that caused the exception.</summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.Hash">
            <summary>
            Utilities for implementing GetHashCode().
            </summary>
            <remarks><para>
            To hash an object with two fields x and y:
            <code>return Hash.Combine(x.GetHashCode(), y.GetHashCode());</code>
            </para><para>
            To hash an array:
            <example><code>
            int hash = Hash.Start;
            for(int i = 0; i &lt; Count; i++)
            	hash = Hash.Combine(hash, this[i].GetHashCode());
            return hash;
            </code></example>
            </para><para>
            Algorithm: FNV hash from http://www.isthe.com/chongo/tech/comp/fnv/
            </para><para>
            Note: You should not use xor to combine hash codes, even though it is
            recommended by MSDN.  xor is invariant to permutation, which means
            "abc" and "bac" and "cba" will hash to the same value (bad).
            Also xoring a hash value with itself produces 0, so "aab" and "b"
            will hash to the same value (bad).
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Utils.Hash.Start">
            <summary>
            The recommended start value for a combined hash value
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Hash.Combine(System.Int32,System.Byte)">
            <summary>
            Combines an existing hash key with a new byte value
            </summary>
            <param name="hash">Current hash code</param>
            <param name="key">New byte of the new hash code to be integrated</param>
            <returns>A new hash-count that is neither order invariant nor "idempotent"</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            Combines two int32 hash keys
            </summary>
            <param name="hash">First hash key</param>
            <param name="key">Second hash key</param>
            <returns>Incorporates the second hash key into the first hash key and returns the new, combined hash key</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Hash.Combine(System.Int32,System.Double)">
            <summary>
            Incorporates the hash key of a double into an existing hash key
            </summary>
            <param name="hash">Exisiting hash key</param>
            <param name="number">Floating point number to incorporate</param>
            <returns>The new, combined hash key</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IArray`1.GetLength(System.Int32)">
            <summary>
            Get the size of a specified dimension of a multidimensional array.
            </summary>
            <param name="dimension">Zero-based dimension of the array.</param>
            <returns>The size of the specified dimension of the array.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.IArray`1.Rank">
            <summary>
            Get the number of dimensions of the array.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array`1.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array`1.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array`1.Clone">
            <summary>
            Clone the array but not the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Array2D`1">
            <summary>
            A two-dimensional array with value equality.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.IArray2D`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or set an element of a two-dimensional array.
            </summary>
            <param name="row"></param>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array2D`1.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array2D`1.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array2D`1.Clone">
            <summary>
            Clone the array but not the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.DenseVector">
            <summary>
            1-dimensional dense container of double precision data that supports vector operations.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.FromXml(System.Xml.XmlReader)">
            <summary>
            Read a DenseVector from XML of the form <example>&lt;DenseVector&gt;&lt;double&gt;1.2&lt;/double&gt;...&lt;/DenseVector&gt;</example>
            </summary>
            <param name="reader"></param>
            <returns>DenseVector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writer XML of the form <example>&lt;DenseVector&gt;&lt;double&gt;1.2&lt;/double&gt;...&lt;/DenseVector&gt;</example>
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Zero(System.Int32)">
            <summary>
            Create a dense vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Constant(System.Int32,System.Double)">
            <summary>
            Create a dense vector of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Copy(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a dense vector as a copy of another vector
            </summary>
            <param name="that">The source vector - can be dense or sparse</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.FromArray(System.Double[])">
            <summary>
            Constructs a dense vector from an array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.FromArray(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector from part of an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.FromArrayReference(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector by referencing an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            The vector will not copy the array but only reference it, 
            so any numerical changes to the array will also apply to the vector.
            If the array grows larger, the extra elements are ignored.
            The array must not shrink or else the vector will become inconsistent.
            </para><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.IndexOf(System.Double)">
            <summary>
            Returns the index of the first occurence of the given value in the vector.
            Returns -1 if the value is not in the array
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Contains(System.Double)">
            <summary>
            Returns true if the Vector contains the specified item value
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies this vector to the given array starting at the specified index
            in the target array
            </summary>
            <param name="array">The target array</param>
            <param name="index">The start index in the target array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GetEnumerator">
            <summary>
            Gets a typed enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.All(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if all elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Any(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if any elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.IndexOfAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns an enumeration of the indices of all elements which satisfy the specified condition.
            Indices are returned in sorted order.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.CreateSourceArray(System.Int32)">
            <summary>
            Creates a source array with a given number of records
            </summary>
            <param name="nRecords"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.ReferenceClone">
            <summary>
            Creates a clone of this instance which references the source array
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.ToArray">
            <summary>
            Converts this vector to an array of doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.#ctor(System.Int32)">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.#ctor(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.#ctor(System.Double[])">
            <summary>
            Constructs a vector from an array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.#ctor(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector by referencing an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            The vector will not copy the array but only reference it, 
            so any numerical changes to the array will also apply to the vector.
            If the array grows larger, the extra elements are ignored.
            The array must not shrink or else the vector will become inconsistent.
            </para><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value
            </summary>
            <param name="count"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Append(System.Double)">
            <summary>
            Appends an item to a vector - returns a new vector
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Append(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a new vector which appends a second vector to this vector
            </summary>
            <param name="second">Second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Append(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Returns a new vector which appends a second dense vector to this dense vector
            </summary>
            <param name="second">Second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Clone">
            <summary>
            Clones this vector - return as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.System#ICloneable#Clone">
            <summary>
            Clones this vector - return as an object
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetAllElementsTo(System.Double)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetTo(System.Double[])">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length matches <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetTo(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copies values from a vector to this vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetTo(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Copies values from a dense vector to this dense vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetTo(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Copies values from an Enumerable to this vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSubarray(System.Double[],System.Int32)">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="values"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>
            Copies value from a vector.
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.DenseVector,System.Int32)">
            <summary>
            Copies value from a vector.
            </summary>
            <param name="that">A dense vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Subvector(System.Int32,System.Int32)">
            <summary>
            Create a subvector of this vector
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetSubvector(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set a subvector of this to another vector.
            </summary>
            <param name="startIndex">The index of the first element of this to copy to.</param>
            <param name="that">A vector whose length is at most <c>this.Count - startIndex</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetSubvector(System.Int32,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Set a subvector of this to another vector.
            </summary>
            <param name="startIndex">The index of the first element of to copy to.</param>
            <param name="that">A dense vector whose length is at most <c>this.Count - startIndex</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of a given vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The given vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToFunction(MicrosoftResearch.Infer.Maths.DenseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of a given vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The given vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of two vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToFunction(MicrosoftResearch.Infer.Maths.DenseVector,MicrosoftResearch.Infer.Maths.DenseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of two vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToPower(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to the elementwise power of another vector.
            </summary>
            <param name="that">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="exponent">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="that"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToPower(MicrosoftResearch.Infer.Maths.DenseVector,System.Double)">
            <summary>
            Sets this vector to the elementwise power of another vector.
            </summary>
            <param name="that">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="exponent">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="that"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this dense vector to the elementwise product of two other vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.DenseVector,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Sets this dense vector to the elementwise product of two other dense vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSum(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to a linear combination of two other vectors
            </summary>
            <param name="aScale">The multiplier for vector a</param>
            <param name="a">Vector a</param>
            <param name="bScale">The multiplier for vector b</param>
            <param name="b">Vector b</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSum(System.Double,MicrosoftResearch.Infer.Maths.DenseVector,System.Double,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Set this vector to a linear combination of two other vectors
            </summary>
            <param name="aScale">The multiplier for vector a</param>
            <param name="a">Vector a</param>
            <param name="bScale">The multiplier for vector b</param>
            <param name="b">Vector b</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSum(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the elementwise sum of two other vectors.
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSum(MicrosoftResearch.Infer.Maths.DenseVector,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Sets this dense vector to the elementwise sum of two other dense vectors.
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSum(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to another vector plus a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToSum(MicrosoftResearch.Infer.Maths.DenseVector,System.Double)">
            <summary>
            Sets this dense vector to another dense vector plus a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDifference(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the difference of two vectors
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> receives the difference, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDifference(MicrosoftResearch.Infer.Maths.DenseVector,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Sets this dense vector to the difference of two othe dense vectors
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> receives the difference, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDifference(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Set this vector to another vector minus a constant
            </summary>
            <param name="a">The other vector</param>
            <param name="b">The constant</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDifference(MicrosoftResearch.Infer.Maths.DenseVector,System.Double)">
            <summary>
            Set this dense vector to another dense vector minus a constant
            </summary>
            <param name="a">The other vector</param>
            <param name="b">The constant</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDifference(System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to a constant minus another vector
            </summary>
            <param name="a">The constant</param>
            <param name="b">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDifference(System.Double,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Set this dense vector to a constant minus another dense vector
            </summary>
            <param name="a">The constant</param>
            <param name="b">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to a vector times a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.DenseVector,System.Double)">
            <summary>
            Sets this dense vector to a dense vector times a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the product of a vector by a matrix (i.e. x*A).
            </summary>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <param name="A">A matrix.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.DenseVector,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this dense vector to the product of a dense vector by a matrix (i.e. x*A).
            </summary>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <param name="A">A matrix.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to the product of a matrix by a vector (i.e. A*x).
            </summary>
            <param name="A">A matrix.</param>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Set this dense vector to the product of a matrix by a dense vector (i.e. A*x).
            </summary>
            <param name="A">A matrix.</param>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the elementwise ratio of two other vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToRatio(MicrosoftResearch.Infer.Maths.DenseVector,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Sets this dense vector to the elementwise ratio of two other dense vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Reduce(System.Double,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this dense vector and that dense vector
            </summary>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.DenseVector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and that vector
            </summary>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and two other vectors
            </summary>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <param name="initial">Initial value</param>
            <param name="a">A second vector</param>
            <param name="b">A third vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Sum">
            <summary>
            Returns the sum of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Sum(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the sum of a function of all elements.
            </summary>
            <param name="fun">Conversion function</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this vector filtered by a function of a second vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.DenseVector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this dense vector filtered by a function of a second dense vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SumI">
            <summary>
            Returns the sum of over zero-based index times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SumISq">
            <summary>
            Returns the sum of over square of index^2 times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Max">
            <summary>
            Returns the maximum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Max(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the maximum of a function of the elements in the vector
            </summary>
            <param name="fun">Conversion function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Median">
            <summary>
            Returns the median of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Min">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Min(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <param name="fun">Conversion function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LogSumExp">
            <summary>
            Returns the log of the sum of exponentials of the elements of the vector
            computed to high accuracy
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.IndexOfMinimum">
            <summary>
            Returns the index of the minimum element.
            </summary>
            <returns>The index of the minimum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.IndexOfMaximum">
            <summary>
            Returns the index of the maximum element.
            </summary>
            <returns>The index of the maximum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.IndexAtCumulativeSum(System.Double)">
            <summary>
            Returns the index of the first element at which the sum of all elements so far is greater
            than a particular value. Useful for finding the median of a Discrete distribution.
            </summary>
            <param name="targetSum">The sum of interest</param>
            <returns>
            The index of the element where <paramref name="targetSum"/> is exceeded 
            or -1 if <paramref name="targetSum"/> cannot be exceeded.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Inner(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product of this vector with another vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Inner(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Returns the inner product of this dense vector with another dense vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Inner(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of this vector with a function of a second vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Inner(MicrosoftResearch.Infer.Maths.DenseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of this dense vector with a function of a second dense vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this vector with a function of a second vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.DenseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this dense vector with a function of a second dense vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Outer(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the outer product of this vector with another vector.
            </summary>
            <param name="that">Second vector.</param>
            <returns>Their outer product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Outer(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Returns the outer product of this dense vector with another dense vector.
            </summary>
            <param name="that">Second vector.</param>
            <returns>Their outer product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.SetToDiagonal(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the diagonal of a matrix.
            </summary>
            <param name="m">A matrix with Rows==Cols==this.Count.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Scale(System.Double)">
            <summary>
            Multiplies this vector by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns></returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another (DenseVector) object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.EqualsAll(System.Double)">
            <summary>
            Tests if all elements are equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GreaterThan(System.Double)">
            <summary>
            Tests if all elements are strictly greater than a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are strictly greater than <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LessThan(System.Double)">
            <summary>
            Tests if all elements are strictly less than a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are strictly less than <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GreaterThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly greater than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly greater than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GreaterThan(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Tests if this dense vector is strictly greater than a second dense vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly greater than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LessThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly less than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LessThan(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Tests if this dense vector is strictly less than a second dense vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GreaterThanOrEqual(System.Double)">
            <summary>
            Tests if all elements are greater than or equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are greater than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LessThanOrEqual(System.Double)">
            <summary>
            Tests if all elements are less than or equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are less than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is greater than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is greater than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Tests if this dense vector is greater than or equal to a second dense vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is greater than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LessThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is less than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.LessThanOrEqual(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Tests if this dense vector is less than or equal to a second dense vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the maximum absolute difference between this vector and another vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.MaxDiff(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Returns the maximum absolute difference between this dense vector and another dense vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the maximum relative difference between this vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.MaxDiff(MicrosoftResearch.Infer.Maths.DenseVector,System.Double)">
            <summary>
            Returns the maximum relative difference between this dense vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.ToString(System.String,System.String)">
            <summary>
            String representation of vector with a specified format and delimiter
            </summary>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.ToString(System.String,System.String,System.Func{System.Int32,System.String})">
            <summary>
            String representation of vector with a specified format and delimiter
            and a function for converting integers to display strings.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.PredivideBy(MicrosoftResearch.Infer.Maths.UpperTriangularMatrix)">
            <summary>
            Gets the solution to Ax=b, where A is an upper triangular matrix, and b is this vector.
            Equivalent to the left-division x = A\b.
            </summary>
            <param name="A">An upper triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.PredivideByTranspose(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to A'x=b, where A is a lower triangular matrix, and b is this vector.
            Equivalent to the left-division x = A'\b.
            </summary>
            <param name="A">A lower triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.PredivideBy(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to Ax=b, where A is a lower triangular matrix, and b is this vector.
            Equivalent to the left-division x = A\b.
            </summary>
            <param name="A">A lower triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DenseVector.PredivideBy(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Premultiply this vector by the inverse of the given positive definite matrix
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.DenseVector.Item(System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.DenseVector.SourceArray">
            <summary>
            Gets/sets source array for the vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.DenseVector.IsReadOnly">
            <summary>
            Is read only
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.DenseVector.Count">
            <summary>
            Number of elements in vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.DenseVector.Start">
            <summary>
            Gets/sets the start index in the source array
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VariableOp">
            <summary>
            Provides outgoing EP messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Variable``1(``0,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableOp.LogEvidenceRatio">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(use,def,marginal))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableOp.MarginalAverageConditional``1(``0,``0,``0)">
            <summary>
            EP message to 'marginal'
            </summary>
            <param name="use">Incoming message from 'use'.</param>
            <param name="def">Incoming message from 'def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'marginal' as the random arguments are varied.
            The formula is <c>proj[p(marginal) sum_(use,def) p(use,def) factor(use,def,marginal)]/p(marginal)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableOp.UseAverageConditional``1(``0)">
            <summary>
            EP message to 'use'
            </summary>
            <param name="Def">Incoming message from 'def'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'use' as the random arguments are varied.
            The formula is <c>proj[p(use) sum_(def) p(def) factor(use,def,marginal)]/p(use)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableOp.DefAverageConditional``1(``0)">
            <summary>
            EP message to 'def'
            </summary>
            <param name="use">Incoming message from 'use'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'def' as the random arguments are varied.
            The formula is <c>proj[p(def) sum_(use) p(use) factor(use,def,marginal)]/p(def)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VariableGibbsOp">
            <summary>
            Provides outgoing Gibbs messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Variable``1(``0,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableGibbsOp.GibbsEvidence``2(``0,``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1})">
            <summary>
            Gibbs evidence
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableGibbsOp.MarginalGibbs``2(``0,``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1})">
            <summary>
            Gibbs message to 'Marginal'.
            </summary>
            <param name="Use">Incoming message from 'use'.</param>
            <param name="Def">Incoming message from 'def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of 'Def' and 'Uses' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableGibbsOp.UseGibbs``2(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1},``1)">
            <summary>
            Gibbs sample message to 'Use'
            </summary>
            <param name="marginal">Incoming message from 'marginal'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="marginal"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableGibbsOp.UseGibbs``2(``0,``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <param name="Def">Incoming message from 'def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of the 'Def' message with all 'Uses' messages except the current
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableGibbsOp.DefGibbs``2(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1},``1)">
            <summary>
            Gibbs sample message to 'Def'
            </summary>
            <param name="marginal">Incoming message from 'marginal'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="marginal"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VariableMaxOp">
            <summary>
            Provides outgoing max product messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Variable``1(``0,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VariableVmpOp">
            <summary>
            Provides outgoing VMP messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Variable``1(``0,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableVmpOp.AverageLogFactor``1(``0)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="marginal">Outgoing message to 'marginal'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Uses,Def,Marginal))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableVmpOp.UseAverageLogarithm``1(``0,``0)">
            <summary>
            VMP message to 'use'
            </summary>
            <param name="marginal">Current 'marginal'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'use' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VariableVmpOp.DefAverageLogarithm``1(``0,``0)">
            <summary>
            VMP message to 'def'
            </summary>
            <param name="marginal">Current 'marginal'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'def' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DerivedVariableOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariable``1(``0,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableOp.LogAverageFactor">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(use,def,marginal))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableOp.LogEvidenceRatio">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(use,def,marginal))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableOp.MarginalAverageConditional``1(``0,``0,``0)">
            <summary>
            EP message to 'marginal'
            </summary>
            <param name="Use">Incoming message from 'use'.</param>
            <param name="Def">Incoming message from 'def'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'marginal' as the random arguments are varied.
            The formula is <c>proj[p(marginal) sum_(use,def) p(use,def) factor(use,def,marginal)]/p(marginal)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableOp.UseAverageConditional``1(``0)">
            <summary>
            EP message to 'use'
            </summary>
            <param name="Def">Incoming message from 'def'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'use' as the random arguments are varied.
            The formula is <c>proj[p(use) sum_(def) p(def) factor(use,def,marginal)]/p(use)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableOp.DefAverageConditional``1(``0)">
            <summary>
            EP message to 'def'
            </summary>
            <param name="Use">Incoming message from 'use'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'def' as the random arguments are varied.
            The formula is <c>proj[p(def) sum_(use) p(use) factor(use,def,marginal)]/p(def)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.GibbsEvidence">
            <summary>
            Evidence message for Gibbs.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.UseGibbs``2(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1},``0,``1)">
            <summary>
            Gibbs sample message to 'Uses'
            </summary>
            <typeparam name="TMarginalDist">Gibbs marginal type</typeparam>
            <typeparam name="TDef">Definition distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="marginal">The Gibbs marginal</param>
            <param name="resultIndex">'Uses' index for result (unused)</param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.UseGibbs``1(``0,``0)">
            <summary>
            Gibbs sample message to 'Uses'
            </summary>
            <typeparam name="T">Domain type</typeparam>
            <param name="def"></param>
            <param name="resultIndex">'Uses' index for result (unused)</param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.DefGibbs``2(``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of all the 'Uses' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.MarginalGibbs``2(``0,``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1})">
            <summary>
            Gibbs message to 'Marginal' for distribution Def
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <returns><paramref name="to_marginal"/></returns>
            <remarks><para>
            The outgoing message is the product of 'Def' and 'Uses' messages.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.MarginalGibbs``2(``1,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1})">
            <summary>
            Gibbs message to 'Marginal' for sample Def
            </summary>
            <typeparam name="TDist"></typeparam>
            <param name="Def"></param>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <returns><paramref name="to_marginal"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableGibbsOp.MarginalGibbs``2(``1,``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,``1})">
            <summary>
            Gibbs message to 'Marginal' for sample Use
            </summary>
            <typeparam name="TDist"></typeparam>
            <param name="Use"></param>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <returns><paramref name="to_marginal"/></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DerivedVariableVmpOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.DerivedVariable``1(``0,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableVmpOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(use,def,marginal))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableVmpOp.MarginalAverageLogarithm``2(``1,``0)">
            <summary>
            VMP message to 'marginal'
            </summary>
            <param name="Def">Incoming message from 'def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'marginal'.
            The formula is <c>exp(sum_(def) p(def) log(factor(use,def,marginal)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableVmpOp.UseAverageLogarithm``2(``1,``0)">
            <summary>
            VMP message to 'use'
            </summary>
            <param name="Def">Incoming message from 'def'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'use' as the random arguments are varied.
            The formula is <c>proj[sum_(def) p(def) factor(use,def,marginal)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DerivedVariableVmpOp.DefAverageLogarithm``1(``0,``0)">
            <summary>
            VMP message to 'def'
            </summary>
            <param name="Use">Incoming message from 'use'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'def' with 'use' integrated out.
            The formula is <c>sum_use p(use) factor(use,def,marginal)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefOp">
            <summary>
            Provides outgoing EP messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.LogEvidenceRatio1``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,Marginal) / sum_Uses p(Uses) messageTo(Uses))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IList{``0})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,Marginal) / sum_Uses p(Uses) messageTo(Uses))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.MarginalAverageConditional``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            EP message to 'Marginal'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Marginal' as the random arguments are varied.
            The formula is <c>proj[p(Marginal) sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,Marginal)]/p(Marginal)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.MarginalAverageConditional``1(``0[],``0,``0)">
            <summary>
            EP message to 'Marginal'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Marginal' as the random arguments are varied.
            The formula is <c>proj[p(Marginal) sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,Marginal)]/p(Marginal)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.UsesAverageConditional``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Uses' as the random arguments are varied.
            The formula is <c>proj[p(Uses) sum_(Def) p(Def) factor(Uses,Def,Marginal)]/p(Uses)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.UsesAverageConditional``1(``0[],``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Uses' as the random arguments are varied.
            The formula is <c>proj[p(Uses) sum_(Def) p(Def) factor(Uses,Def,Marginal)]/p(Uses)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.DefAverageConditional``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            EP message to 'Def'
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Def' as the random arguments are varied.
            The formula is <c>proj[p(Def) sum_(Uses) p(Uses) factor(Uses,Def,Marginal)]/p(Def)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1">
            <summary>
            Provides outgoing Gibbs messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.GibbsEvidence``1(System.Collections.Generic.IList{``0},``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0})">
            <summary>
            Evidence message for Gibbs
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.MarginalGibbs``1(System.Collections.Generic.IList{``0},``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0})">
            <summary>
            Gibbs message to 'Marginal'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the product of 'Def' and 'Uses' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.UsesGibbs``1(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0},System.Int32,`0)">
            <summary>
            Gibbs sample message to 'Uses'
            </summary>
            <param name="to_marginal">Incoming message from 'Marginal'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="to_marginal"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.UsesGibbs``1(System.Collections.Generic.ICollection{``0},``0,System.Int32,``0)">
            <summary>
            Gibbs distribution message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of the 'Def' message with all 'Uses' messages except the current
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.DefGibbs``1(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0},`0)">
            <summary>
            Gibbs sample message to 'Def'
            </summary>
            <param name="to_marginal">Incoming message from 'Marginal'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="to_marginal"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp`1.DefGibbs``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of all the 'Uses' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1">
            <summary>
            Provides outgoing Gibbs messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.GibbsEvidence``1(System.Collections.Generic.IList{``0},``0,`0)">
            <summary>
            Evidence message for Gibbs
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.UsesGibbs``1(``0,`0,System.Int32,`0)">
            <summary>
            Gibbs sample message to 'Uses'
            </summary>
            <param name="sample">Current sample.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="marginal"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.UsesGibbs``1(System.Collections.Generic.ICollection{``0},``0,System.Int32,``0)">
            <summary>
            Gibbs distribution message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of the 'Def' message with all 'Uses' messages except the current
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.DefGibbs``1(``0,`0)">
            <summary>
            Gibbs sample message to 'Def'
            </summary>
            <param name="sample">Current sample.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="marginal"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefGibbsOp2`1.DefGibbs``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of all the 'Uses' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefMaxOp">
            <summary>
            Provides outgoing max product messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefMaxOp.UsesMaxConditional``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>
            Max product message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefMaxOp.DefMaxConditional``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Max product message to 'Def'
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefMaxOp.MarginalMaxConditional``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            Max product message to 'Marginal'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpBufferOp">
            <summary>
            Provides outgoing VMP messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpBufferOp.MarginalAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            VMP message to 'Marginal'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'Marginal'.
            The formula is <c>exp(sum_(Uses,Def) p(Uses,Def) log(factor(Uses,Def,Marginal)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpBufferOp.UsesAverageLogarithm``1(``0,System.Int32,``0)">
            <summary>
            VMP message to 'Uses'
            </summary>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Uses' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpBufferOp.DefAverageLogarithm``1(``0,``0)">
            <summary>
            VMP message to 'Def'
            </summary>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Def' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpOp">
            <summary>
            Provides outgoing VMP messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpOp.AverageLogFactor``1(``0)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="to_marginal">Outgoing message to 'marginal'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Uses,Def,Marginal))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpOp.MarginalAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            VMP message to 'Marginal'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'Marginal'.
            The formula is <c>exp(sum_(Uses,Def) p(Uses,Def) log(factor(Uses,Def,Marginal)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpOp.UsesAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>
            VMP message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'Uses'.
            The formula is <c>exp(sum_(Def) p(Def) log(factor(Uses,Def,Marginal)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefVmpOp.DefAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            VMP message to 'Def'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'Def'.
            The formula is <c>exp(sum_(Uses) p(Uses) log(factor(Uses,Def,Marginal)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsGreaterThanOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.IsGreaterThan(System.Int32,System.Int32)"/>, given random arguments to the function.
            </summary>
            <remarks>A and B need not have the same dimension.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(isGreaterThan,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogEvidenceRatio(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(isGreaterThan,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(isGreaterThan,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isGreaterThan) p(isGreaterThan) factor(isGreaterThan,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="to_isGreaterThan">Outgoing message to 'isGreaterThan'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isGreaterThan,a) p(isGreaterThan,a) factor(isGreaterThan,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <param name="to_isGreaterThan">Outgoing message to 'isGreaterThan'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isGreaterThan,b) p(isGreaterThan,b) factor(isGreaterThan,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isGreaterThan) p(isGreaterThan) factor(isGreaterThan,a,b) / sum_isGreaterThan p(isGreaterThan) messageTo(isGreaterThan))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(isGreaterThan,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(isGreaterThan,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(isGreaterThan,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(isGreaterThan,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogEvidenceRatio(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(isGreaterThan,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(isGreaterThan,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'isGreaterThan'
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'isGreaterThan' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isGreaterThan' as the random arguments are varied.
            The formula is <c>proj[p(isGreaterThan) sum_(b) p(b) factor(isGreaterThan,a,b)]/p(isGreaterThan)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            EP message to 'isGreaterThan'
            </summary>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'isGreaterThan' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isGreaterThan' as the random arguments are varied.
            The formula is <c>proj[p(isGreaterThan) sum_(a) p(a) factor(isGreaterThan,a,b)]/p(isGreaterThan)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'isGreaterThan'
            </summary>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'isGreaterThan' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isGreaterThan' as the random arguments are varied.
            The formula is <c>proj[p(isGreaterThan) sum_(a,b) p(a,b) factor(isGreaterThan,a,b)]/p(isGreaterThan)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(isGreaterThan,b) p(isGreaterThan,b) factor(isGreaterThan,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isGreaterThan"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(isGreaterThan) p(isGreaterThan) factor(isGreaterThan,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isGreaterThan"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(b) p(b) factor(isGreaterThan,a,b)]/p(a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageConditional(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="b">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(isGreaterThan,a) p(isGreaterThan,a) factor(isGreaterThan,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isGreaterThan"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(isGreaterThan) p(isGreaterThan) factor(isGreaterThan,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isGreaterThan"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(a) p(a) factor(isGreaterThan,a,b)]/p(b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageConditional(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,System.Int32)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'isGreaterThan'
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'isGreaterThan' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isGreaterThan' as the random arguments are varied.
            The formula is <c>proj[sum_(b) p(b) factor(isGreaterThan,a,b)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            VMP message to 'isGreaterThan'
            </summary>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'isGreaterThan' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isGreaterThan' as the random arguments are varied.
            The formula is <c>proj[sum_(a) p(a) factor(isGreaterThan,a,b)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'isGreaterThan'
            </summary>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'isGreaterThan' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isGreaterThan' as the random arguments are varied.
            The formula is <c>proj[sum_(a,b) p(a,b) factor(isGreaterThan,a,b)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            Because the factor is deterministic, 'isGreaterThan' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(b) p(b) log(sum_isGreaterThan p(isGreaterThan) factor(isGreaterThan,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isGreaterThan"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            Because the factor is deterministic, 'isGreaterThan' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(a) p(a) log(sum_isGreaterThan p(isGreaterThan) factor(isGreaterThan,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isGreaterThan"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' with 'isGreaterThan' integrated out.
            The formula is <c>sum_isGreaterThan p(isGreaterThan) factor(isGreaterThan,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isGreaterThan"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="isGreaterThan">Incoming message from 'isGreaterThan'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' with 'isGreaterThan' integrated out.
            The formula is <c>sum_isGreaterThan p(isGreaterThan) factor(isGreaterThan,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isGreaterThan"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(isGreaterThan,a,b)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            The formula is <c>exp(sum_(a) p(a) log(factor(isGreaterThan,a,b)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageLogarithm(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="b">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageLogarithm(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="isGreaterThan">Constant value for 'isGreaterThan'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExpOp">
            <summary>
            Provides outgoing messages for <see cref="M:System.Math.Exp(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ExpOp.QuadratureNodeCount">
            <summary>
            The number of quadrature nodes used to compute the messages.
            Reduce this number to save time in exchange for less accuracy.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ExpOp.QuadratureIterations">
            <summary>
            Number of quadrature iterations
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ExpOp.QuadratureShift">
            <summary>
            Quadrature shift
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ExpOp.ForceProper">
            <summary>
             Forces proper messages when set to true. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor(System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="exp">Constant value for 'exp'.</param>
            <param name="d">Constant value for 'd'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(exp,d))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogEvidenceRatio(System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="exp">Constant value for 'exp'.</param>
            <param name="d">Constant value for 'd'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(exp,d))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.AverageLogFactor(System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="exp">Constant value for 'exp'.</param>
            <param name="d">Constant value for 'd'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(exp,d))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="exp">Incoming message from 'exp'.</param>
            <param name="d">Constant value for 'd'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(exp) p(exp) factor(exp,d))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="exp">Constant value for 'exp'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(d) p(d) factor(exp,d))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="exp">Incoming message from 'exp'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <param name="to_d">Previous outgoing message to 'd'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(exp,d) p(exp,d) factor(exp,d))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor_slow(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="exp">Incoming message from 'exp'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(exp,d) p(exp,d) factor(exp,d))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="exp">Incoming message from 'exp'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <param name="to_exp">Outgoing message to 'exp'.</param>
            <param name="to_d">Previous outgoing message to 'd'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(exp,d) p(exp,d) factor(exp,d) / sum_exp p(exp) messageTo(exp))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="exp">Constant value for 'exp'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(d) p(d) factor(exp,d))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.ExpAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'exp'
            </summary>
            <param name="exp">Incoming message from 'exp'.</param>
            <param name="d">Incoming message from 'd'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_d">Previous outgoing message to 'd'.</param>
            <returns>The outgoing EP message to the 'exp' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'exp' as the random arguments are varied.
            The formula is <c>proj[p(exp) sum_(d) p(d) factor(exp,d)]/p(exp)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="d"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageConditional(System.Double)">
            <summary>
            EP message to 'd'
            </summary>
            <param name="exp">Constant value for 'exp'.</param>
            <returns>The outgoing EP message to the 'd' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'd' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'd'
            </summary>
            <param name="exp">Incoming message from 'exp'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="d">Incoming message from 'd'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'd' as the random arguments are varied.
            The formula is <c>proj[p(d) sum_(exp) p(exp) factor(exp,d)]/p(d)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exp"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="d"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(exp,d))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.ExpAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'exp'
            </summary>
            <param name="d">Incoming message from 'd'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'exp' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'exp' as the random arguments are varied.
            The formula is <c>proj[sum_(d) p(d) factor(exp,d)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="d"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.ExpAverageLogarithm(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            VMP message to 'exp'
            </summary>
            <param name="d">Incoming message from 'd'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'exp' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'exp' as the random arguments are varied.
            The formula is <c>proj[sum_(d) p(d) factor(exp,d)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="d"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            VMP message to 'd'
            </summary>
            <param name="exp">Incoming message from 'exp'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="d">Incoming message from 'd'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'd' with 'exp' integrated out.
            The formula is <c>sum_exp p(exp) factor(exp,d)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exp"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="d"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DNonconjugateAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            Nonconjugate VMP message to 'd'.
            </summary>
            <param name="exp">Incoming message from 'exp'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="d"></param>
            <param name="result"></param>
            <returns>The outgoing nonconjugate VMP message to the 'd' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'd'.
            The formula is <c>int log(f(d,x)) q(x) dx</c> where <c>x = (exp)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exp"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'd'.
            </summary>
            <param name="exp">Incoming message from 'exp'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="d"></param>
            <param name="to_d"></param>
            <returns>The outgoing VMP message to the 'd' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'd'.
            The formula is <c>int log(f(d,x)) q(x) dx</c> where <c>x = (exp)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exp"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageLogarithm(System.Double)">
            <summary>
            VMP message to 'd'.
            </summary>
            <param name="exp">Constant value for 'exp'.</param>
            <returns>The outgoing VMP message to the 'd' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'd'.
            The formula is <c>int log(f(d,x)) q(x) dx</c> where <c>x = (exp)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.ExpAverageLogarithm(System.Double)">
            <summary>
            VMP message to 'exp'.
            </summary>
            <param name="d">Constant value for 'd'.</param>
            <returns>The outgoing VMP message to the 'd' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'd'.
            The formula is <c>int log(f(d,x)) q(x) dx</c> where <c>x = (d)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExpOp_BFGS">
            <summary>
            Provides outgoing messages for <see cref="M:System.Math.Exp(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp_BFGS.DAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'd'
            </summary>
            <param name="exp">Incoming message from 'exp'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="d">Incoming message from 'd'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_d">Previous outgoing message to 'd'.</param>
            <returns>The outgoing VMP message to the 'd' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'd' with 'exp' integrated out.
            The formula is <c>sum_exp p(exp) factor(exp,d)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exp"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="d"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConcatOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.Vector.Concat(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="first">Constant value for 'first'.</param>
            <param name="second">Constant value for 'second'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(concat,first,second))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="concat">Incoming message from 'concat'.</param>
            <param name="first">Constant value for 'first'.</param>
            <param name="second">Constant value for 'second'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(concat) p(concat) factor(concat,first,second))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="first">Incoming message from 'first'.</param>
            <param name="second">Incoming message from 'second'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(first,second) p(first,second) factor(concat,first,second))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="first">Constant value for 'first'.</param>
            <param name="second">Incoming message from 'second'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(second) p(second) factor(concat,first,second))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="first">Incoming message from 'first'.</param>
            <param name="second">Constant value for 'second'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(first) p(first) factor(concat,first,second))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="first">Incoming message from 'first'.</param>
            <param name="second">Incoming message from 'second'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(first,second) p(first,second) factor(concat,first,second))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="first">Constant value for 'first'.</param>
            <param name="second">Incoming message from 'second'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(second) p(second) factor(concat,first,second))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="first">Incoming message from 'first'.</param>
            <param name="second">Constant value for 'second'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(first) p(first) factor(concat,first,second))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="concat">Incoming message from 'concat'.</param>
            <param name="to_concat">Outgoing message to 'concat'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(concat) p(concat) factor(concat,first,second))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="concat">Incoming message from 'concat'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(concat) p(concat) factor(concat,first,second) / sum_concat p(concat) messageTo(concat))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'concat'
            </summary>
            <param name="first">Incoming message from 'first'.</param>
            <param name="second">Incoming message from 'second'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'concat' as the random arguments are varied.
            The formula is <c>proj[p(concat) sum_(first,second) p(first,second) factor(concat,first,second)]/p(concat)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'concat'
            </summary>
            <param name="first">Constant value for 'first'.</param>
            <param name="second">Incoming message from 'second'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'concat' as the random arguments are varied.
            The formula is <c>proj[p(concat) sum_(second) p(second) factor(concat,first,second)]/p(concat)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'concat'
            </summary>
            <param name="first">Incoming message from 'first'.</param>
            <param name="second">Constant value for 'second'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'concat' as the random arguments are varied.
            The formula is <c>proj[p(concat) sum_(first) p(first) factor(concat,first,second)]/p(concat)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.FirstAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'first'
            </summary>
            <param name="concat">Incoming message from 'concat'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="second">Constant value for 'second'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'first' as the random arguments are varied.
            The formula is <c>proj[p(first) sum_(concat) p(concat) factor(concat,first,second)]/p(first)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="concat"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.FirstAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'first'
            </summary>
            <param name="concat">Incoming message from 'concat'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="second">Incoming message from 'second'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'first' as the random arguments are varied.
            The formula is <c>proj[p(first) sum_(concat,second) p(concat,second) factor(concat,first,second)]/p(first)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="concat"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'second'
            </summary>
            <param name="concat">Incoming message from 'concat'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="first">Constant value for 'first'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'second' as the random arguments are varied.
            The formula is <c>proj[p(second) sum_(concat) p(concat) factor(concat,first,second)]/p(second)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="concat"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'second'
            </summary>
            <param name="concat">Incoming message from 'concat'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="first">Incoming message from 'first'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'second' as the random arguments are varied.
            The formula is <c>proj[p(second) sum_(concat,first) p(concat,first) factor(concat,first,second)]/p(second)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="concat"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.FirstAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'first'
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'first' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'second'
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="first">Constant value for 'first'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'second' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'second'
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="first">Incoming message from 'first'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'second' as the random arguments are varied.
            The formula is <c>proj[p(second) sum_(first) p(first) factor(concat,first,second)]/p(second)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(concat,first,second))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'concat'
            </summary>
            <param name="first">Incoming message from 'first'.</param>
            <param name="second">Incoming message from 'second'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'concat' as the random arguments are varied.
            The formula is <c>proj[sum_(first,second) p(first,second) factor(concat,first,second)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'concat'
            </summary>
            <param name="first">Constant value for 'first'.</param>
            <param name="second">Incoming message from 'second'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'concat' as the random arguments are varied.
            The formula is <c>proj[sum_(second) p(second) factor(concat,first,second)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.ConcatAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'concat'
            </summary>
            <param name="first">Incoming message from 'first'.</param>
            <param name="second">Constant value for 'second'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'concat' as the random arguments are varied.
            The formula is <c>proj[sum_(first) p(first) factor(concat,first,second)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.FirstAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'first'
            </summary>
            <param name="concat">Incoming message from 'concat'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="second">Constant value for 'second'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'first' with 'concat' integrated out.
            The formula is <c>sum_concat p(concat) factor(concat,first,second)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="concat"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.FirstAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'first'
            </summary>
            <param name="concat">Incoming message from 'concat'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="second">Incoming message from 'second'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'first'.
            Because the factor is deterministic, 'concat' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(second) p(second) log(sum_concat p(concat) factor(concat,first,second)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="concat"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'second'
            </summary>
            <param name="concat">Incoming message from 'concat'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="first">Constant value for 'first'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'second' with 'concat' integrated out.
            The formula is <c>sum_concat p(concat) factor(concat,first,second)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="concat"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'second'
            </summary>
            <param name="concat">Incoming message from 'concat'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="first">Incoming message from 'first'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'second'.
            Because the factor is deterministic, 'concat' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(first) p(first) log(sum_concat p(concat) factor(concat,first,second)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="concat"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.FirstAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'first'
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'first' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'second'
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="first">Constant value for 'first'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'second' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConcatOp.SecondAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'second'
            </summary>
            <param name="concat">Constant value for 'concat'.</param>
            <param name="first">Incoming message from 'first'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'second'.
            The formula is <c>exp(sum_(first) p(first) log(factor(concat,first,second)))</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Bernoulli(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogAverageFactor(System.Boolean,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,probTrue))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,probTrue))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue">Incoming message from 'probTrue'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(probTrue) p(probTrue) factor(sample,probTrue))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,probTrue) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue">Incoming message from 'probTrue'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(probTrue) p(probTrue) factor(sample,probTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogEvidenceRatio(System.Boolean,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,probTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue">Incoming message from 'probTrue'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,probTrue) p(sample,probTrue) factor(sample,probTrue) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.SampleConditional(System.Double)">
            <summary>
            Gibbs message to 'sample'
            </summary>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing Gibbs message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.SampleAverageConditional(System.Double)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.ProbTrueConditional(System.Boolean)">
            <summary>
            Gibbs message to 'probTrue'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <returns>The outgoing Gibbs message to the 'probTrue' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'probTrue' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.ProbTrueAverageConditional(System.Boolean)">
            <summary>
            EP message to 'probTrue'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <returns>The outgoing EP message to the 'probTrue' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'probTrue' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="probTrue">Incoming message from 'probTrue'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(probTrue) p(probTrue) factor(sample,probTrue)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.ProbTrueAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            EP message to 'probTrue'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="probTrue">Incoming message from 'probTrue'.</param>
            <returns>The outgoing EP message to the 'probTrue' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'probTrue' as the random arguments are varied.
            The formula is <c>proj[p(probTrue) sum_(sample) p(sample) factor(sample,probTrue)]/p(probTrue)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="probTrue">Incoming message from 'probTrue'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,probTrue) p(sample,probTrue) log(factor(sample,probTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,probTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue">Incoming message from 'probTrue'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(probTrue) p(probTrue) log(factor(sample,probTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.AverageLogFactor(System.Boolean,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,probTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.SampleAverageLogarithm(System.Double)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="probTrue">Incoming message from 'probTrue'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(probTrue) p(probTrue) log(factor(sample,probTrue)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.ProbTrueAverageLogarithm(System.Boolean)">
            <summary>
            VMP message to 'probTrue'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <returns>The outgoing VMP message to the 'probTrue' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'probTrue' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBetaOp.ProbTrueAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'probTrue'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'probTrue' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'probTrue'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,probTrue)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DiscreteEstimator">
            <summary>
            Estimates a discrete distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.N">
            <summary>
            Number of samples
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.NProb">
            <summary>
            Vector of counts for each domain value
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Gets the estimated distribution
            </summary>
            <param name="result">Where to put the estimated distribution</param>
            <returns>The estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Add(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Adds a discrete distribution item to the estimator
            </summary>
            <param name="distribution">A Discrete instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Add(MicrosoftResearch.Infer.Distributions.Discrete,System.Double)">
            <summary>
            Adds a weighted discrete distribution item to the estimator
            </summary>
            <param name="distribution">A Discrete instance</param>
            <param name="weight">Weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Add(System.Int32)">
            <summary>
            Adds an discrete sample to the estimator
            </summary>
            <param name="sample">The sample value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new discrete distribution estimator
            </summary>
            <param name="dimension">Dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.SetTo(MicrosoftResearch.Infer.Distributions.DiscreteEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Dimension">
            <summary>
            Dimension of the discrete distribution
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator">
            <summary>
            Class for accumulating weighted noisy scalar observations,
            and computing sample count, mean, and variance
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Mean">
            <summary>
            The sample mean
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Variance">
            <summary>
            Sample variance
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Count">
            <summary>
            Sample count
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Add(System.Double)">
            <summary>
            Adds an observation
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Add(System.Double,System.Double)">
            <summary>
            Adds a weighted observation.
            </summary>
            <param name="x"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Add(System.Double,System.Double,System.Double)">
            <summary>
            Adds a noisy observation.
            </summary>
            <param name="x"></param>
            <param name="noiseVariance"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.SetTo(MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2">
            <summary>
            Class for accumulating weighted noisy scalar observations,
            and computing sample count, mean, and variance
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Mean">
            <summary>
            The sample mean
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Variance">
            <summary>
            Sample variance
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.LogCount">
            <summary>
            Sample count
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Add(System.Double)">
            <summary>
            Adds an observation
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Add(System.Double,System.Double)">
            <summary>
            Adds a weighted observation.
            </summary>
            <param name="x"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Add(System.Double,System.Double,System.Double)">
            <summary>
            Adds a noisy observation.
            </summary>
            <param name="x"></param>
            <param name="noiseVariance"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.SetTo(MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator2.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix">
            <summary>
            Class for lower triangular matrices
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a zero matrix of the given dimensions.
            </summary>
            <param name="nRows">Number of rows >= 0.</param>
            <param name="nCols">Number of columns >= 0.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.#ctor(System.Int32,System.Int32,System.Double[])">
            <summary>
            Constructs a matrix by referencing an array.
            </summary>
            <param name="data">Storage for the matrix elements.</param>
            <param name="nRows">Number of rows.</param>
            <param name="nCols">Number of columns.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Constructs a matrix from data in a 2D array.
            </summary>
            <param name="data">2D array of elements.</param>
            <remarks>The 2D array is copied into new storage.
            The size of the matrix is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.Clone">
            <summary>
            Creates a full clone of this instance (including the data)
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.CheckLowerTriangular">
            <summary>
            Checks that this instance is lower triangular
            </summary>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.SetToInverse(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Modifies <c>this</c> to be the inverse of A.
            </summary>
            <param name="A">Can be the same object as <c>this</c></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.Inverse">
            <summary>
            Returns the inverse of this lower triangular matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.Transpose">
            <summary>
            Returns the transpose of this lower triangular matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.ProdDiag">
            <summary>
            Returns the product of diagonal elements of this lower triangular matrix
            </summary>
            <returns><c>prod(diag(this))</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.Determinant">
            <summary>
            Returns the determinant of this lower-triangular matrix.
            </summary>
            <returns>The determinant of this.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.TraceLn(System.Boolean)">
            <summary>
            Returns the sum of the logarithm of diagonal elements.
            </summary>
            <param name="ignoreInfinity">If true, +infinity on the diagonal is treated as 1.</param>
            <returns><c>sum(log(diag(this)))</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.LogDeterminant(System.Boolean)">
            <summary>
            Returns the natural logarithm of the determinant of a lower-triangular matrix.
            </summary>
            <param name="ignoreInfinity">If true, +infinity on the diagonal is treated as 1.</param>
            <returns>The log-determinant of this.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.SetToCholesky(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Gets the Cholesky decomposition of another matrix.
            </summary>
            <param name="A">A symmetric matrix to decompose.</param>
            <returns>True if <paramref name="A"/> is positive definite, otherwise false.</returns>
            <remarks>
            The decomposition is a lower triangular matrix L, returned in <c>this</c>.
            <paramref name="A"/> must be symmetric, but need not be positive definite.
            If <paramref name="A"/> is positive semidefinite, 
            then L will satisfy L*L' = A.
            Otherwise, L will only approximately satisfy L*L' = A.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.FunctionEval">
            <summary>
            Delegate type for function evaluation
            </summary>
            <param name="x">Independent value</param>
            <param name="dX">If reference is not null, calculate the deriv here</param>
            <returns>Function evaluation</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.IterationEventHandler">
            <summary>
            Event delegate for handling iteration event
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.OptimiserIterationEventArgs">
            <summary>
            Optimiser iteration event
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.OptimiserIterationEventArgs.#ctor(System.Int32,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="iteration"></param>
            <param name="objVal"></param>
            <param name="rmsDeriv"></param>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.OptimiserIterationEventArgs.iteration">
            <summary>
            Iteration
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.OptimiserIterationEventArgs.objVal">
            <summary>
            Objective value
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.OptimiserIterationEventArgs.rmsDeriv">
            <summary>
            Root mean square derivative
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.DerivativeChecker">
            <summary>
            Class used to check analytic derivatives using finite difference approximation
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.DerivativeChecker.CheckDerivatives(MicrosoftResearch.Infer.Maths.FunctionEval,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Check whether "func" correctly calculates derivatives
            </summary>
            <param name="func">Return the objective and calculates gradients</param>
            <param name="x0">The point to perform the check around</param>
            <returns>Whether the derivatives are correctly calculated. </returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.IEnumerableExensions">
            <summary>
            Provides extension methods for IEnumerable that support sparse collections.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IEnumerableExensions.EnumerableReduce``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``0,System.Int32,``1})">
            <summary>
            Reduces across an enumerable, supporting sparse enumerables
            </summary>
            <typeparam name="T">Type of this collection</typeparam>
            <typeparam name="TRes">Type of result</typeparam>
            <param name="source">This collection</param>
            <param name="initial">Initial value for reduction</param>
            <param name="fun">The function</param>		
            <param name="repeatedFun">The function when the same value enters the reduction several times.</param>		
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Wishart.SampleFromShapeAndScale(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="scale">Constant value for 'scale'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,shape,scale))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="scale">Constant value for 'scale'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,shape,scale))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="scale">Constant value for 'scale'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,shape,scale))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,shape,scale))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.SampleAverageLogarithm(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="scale">Constant value for 'scale'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndScaleOp.SampleAverageConditional(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="scale">Constant value for 'scale'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Wishart.SampleFromShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,shape,rate))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,shape,rate))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,shape,rate))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,shape,scale))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.SampleAverageLogarithm(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="scale">Constant value for 'rate'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.WishartFromShapeAndRateOp.SampleAverageConditional(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="scale">Constant value for 'rate'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Discrete(MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,probs))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Incoming message from 'probs'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(probs) p(probs) factor(sample,probs))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,probs))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Incoming message from 'probs'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(probs) p(probs) factor(sample,probs))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,probs))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probs">Incoming message from 'probs'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,probs) p(sample,probs) factor(sample,probs) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,probs) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Gibbs message to 'sample'
            </summary>
            <param name="probs">Constant value for 'probs'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="probs">Constant value for 'probs'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="probs">Constant value for 'probs'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.ProbsConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Gibbs message to 'probs'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'probs' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.ProbsAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'probs'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'probs' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.ProbsAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'probs'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'probs' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="probs">Incoming message from 'probs'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(probs) p(probs) factor(sample,probs)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probs"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="probs">Incoming message from 'probs'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(probs) p(probs) log(factor(sample,probs)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probs"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.ProbsAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'probs'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'probs'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,probs)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.ProbsAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'probs'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'probs' as the random arguments are varied.
            The formula is <c>proj[p(probs) sum_(sample) p(sample) factor(sample,probs)]/p(probs)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.ProbsAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'probs'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="probs">Incoming message from 'probs'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'probs' as the random arguments are varied.
            The formula is <c>proj[p(probs) sum_(sample) p(sample) factor(sample,probs)]/p(probs)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probs"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="probs">Incoming message from 'probs'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,probs) p(sample,probs) log(factor(sample,probs))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probs"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,probs))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Incoming message from 'probs'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(probs) p(probs) log(factor(sample,probs))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probs"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichletOp.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,probs))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SumWhereOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.SumWhere(System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.LogAverageFactor(System.Double,System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Sum,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.LogEvidenceRatio(System.Double,System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Sum,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.AverageLogFactor(System.Double,System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Sum,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Incoming message from 'Sum'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'B'
            </summary>
            <param name="sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'B' as the random arguments are varied.
            The formula is <c>proj[p(B) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.SumAverageConditional(System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            EP message to 'Sum'
            </summary>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanOfB">Buffer 'MeanOfB'.</param>
            <param name="CovarianceOfB">Buffer 'CovarianceOfB'.</param>
            <returns>The outgoing EP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[p(Sum) sum_(B) p(B) factor(Sum,A,B)]/p(Sum)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Incoming message from 'Sum'.</param>
            <param name="to_sum">Outgoing message to 'sum'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.LogAverageFactor(System.Double,System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanOfB">Buffer 'MeanOfB'.</param>
            <param name="CovarianceOfB">Buffer 'CovarianceOfB'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(B) p(B) factor(Sum,A,B))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Sum,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.CovarianceOfB(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Update the buffer 'CovarianceOfB'
            </summary>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>New value of buffer 'CovarianceOfB'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.MeanOfB(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Update the buffer 'MeanOfB'
            </summary>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="CovarianceOfB">Buffer 'CovarianceOfB'.</param>
            <returns>New value of buffer 'MeanOfB'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            VMP message to 'Sum'
            </summary>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanOfB">Buffer 'MeanOfB'.</param>
            <param name="CovarianceOfB">Buffer 'CovarianceOfB'.</param>
            <returns>The outgoing VMP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[sum_(A,B) p(A,B) factor(Sum,A,B)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            VMP message to 'Sum'
            </summary>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns>The outgoing VMP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[sum_(A) p(A) factor(Sum,A,B)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.SumAverageLogarithm(System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            VMP message to 'Sum'
            </summary>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanOfB">Buffer 'MeanOfB'.</param>
            <param name="CovarianceOfB">Buffer 'CovarianceOfB'.</param>
            <returns>The outgoing VMP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[sum_(B) p(B) factor(Sum,A,B)]</c>.
            </para><para>
            Uses John Winn's rule for deterministic factors.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.SumAverageLogarithm(System.Boolean[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            VMP message to 'Sum'
            </summary>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns>The outgoing VMP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Sum' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'B' with 'Sum' integrated out.
            The formula is <c>sum_Sum p(Sum) factor(Sum,A,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'B'.
            Because the factor is deterministic, 'Sum' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(A) p(A) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean})">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanOfB">Buffer 'MeanOfB'.</param>
            <param name="CovarianceOfB">Buffer 'CovarianceOfB'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'A'.
            Because the factor is deterministic, 'Sum' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(B) p(B) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean})">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'A' with 'Sum' integrated out.
            The formula is <c>sum_Sum p(Sum) factor(Sum,A,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'A'.
            The formula is <c>exp(sum_(B) p(B) log(factor(Sum,A,B)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns>The outgoing VMP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'A' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SumWhereOp.BAverageLogarithm(System.Double,System.Boolean[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'B' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'B' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BetaOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BetaFromMeanAndTotalCount(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.BetaOp.damping">
            <summary>
            How much damping to use to avoid improper messages. A higher value implies more damping. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (prob,mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'Prob'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'Prob' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            VMP message to 'Prob'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'Prob' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'Prob'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'Prob' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_mean">Previous outgoing message to 'Mean'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(totalCount) p(totalCount) log(factor(prob,mean,totalCount)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Beta,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <param name="to_mean">Previous outgoing message to 'Mean'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <param name="to_mean">Previous outgoing message to 'Mean'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(prob) p(prob) log(factor(prob,mean,totalCount)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_mean">Previous outgoing message to 'Mean'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(totalCount,prob) p(totalCount,prob) log(factor(prob,mean,totalCount)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'totalCount'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="to_totalCount">Previous outgoing message to 'TotalCount'.</param>
            <returns>The outgoing VMP message to the 'totalCount' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'totalCount'.
            The formula is <c>exp(sum_(mean) p(mean) log(factor(prob,mean,totalCount)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'totalCount'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_totalCount">Previous outgoing message to 'TotalCount'.</param>
            <returns>The outgoing VMP message to the 'totalCount' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'totalCount'.
            The formula is <c>exp(sum_(mean,prob) p(mean,prob) log(factor(prob,mean,totalCount)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_() p() factor(prob,mean,totalCount))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="prob">Incoming message from 'prob'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(prob) p(prob) factor(prob,mean,totalCount))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'prob'.
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>The outgoing EP message to the 'prob' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'prob' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'prob'.
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'prob' argument.</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'prob' as the random arguments are varied.
            The formula is <c>proj[p(prob) sum_(mean,totalCount) p(mean,totalCount) factor(prob,mean,totalCount)]/p(prob)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            EP message to 'prob'.
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>The outgoing EP message to the 'prob' argument.</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'prob' as the random arguments are varied.
            The formula is <c>proj[p(prob) sum_(mean) p(mean) factor(prob,mean,totalCount)]/p(prob)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'prob'.
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'prob' argument.</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'prob' as the random arguments are varied.
            The formula is <c>proj[p(prob) sum_(totalCount) p(totalCount) factor(prob,mean,totalCount)]/p(prob)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            EP message to 'mean'.
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,System.Double,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            EP message to 'mean'.
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(prob) p(prob) factor(prob,mean,totalCount)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            EP message to 'mean'.
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(totalCount,prob) p(totalCount,prob) factor(prob,mean,totalCount)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.TotalCountAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'totalCount'.
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'totalCount' as the random arguments are varied.
            The formula is <c>proj[p(totalCount) sum_(mean) p(mean) factor(prob,mean,totalCount)]/p(totalCount)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.TotalCountAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'totalCount'.
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'totalCount' as the random arguments are varied.
            The formula is <c>proj[p(totalCount) sum_(mean,prob) p(mean,prob) factor(prob,mean,totalCount)]/p(totalCount)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Beta.Sample(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="trueCount">Constant value for 'trueCount'.</param>
            <param name="falseCount">Constant value for 'falseCount'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,trueCount,falseCount))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="trueCount">Constant value for 'trueCount'.</param>
            <param name="falseCount">Constant value for 'falseCount'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,trueCount,falseCount) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="trueCount">Constant value for 'trueCount'.</param>
            <param name="falseCount">Constant value for 'falseCount'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,trueCount,falseCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="trueCount">Constant value for 'trueCount'.</param>
            <param name="falseCount">Constant value for 'falseCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,trueCount,falseCount))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="trueCount">Constant value for 'trueCount'.</param>
            <param name="falseCount">Constant value for 'falseCount'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,trueCount,falseCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="trueCount">Constant value for 'trueCount'.</param>
            <param name="falseCount">Constant value for 'falseCount'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,trueCount,falseCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="trueCount">Constant value for 'trueCount'.</param>
            <param name="falseCount">Constant value for 'falseCount'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromTrueAndFalseCountsOp.SampleAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="trueCount">Constant value for 'trueCount'.</param>
            <param name="falseCount">Constant value for 'falseCount'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Beta.SampleFromMeanAndVariance(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,mean,variance))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaFromMeanAndVarianceOp.SampleAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.TruncatedGaussian">
            <summary>
            A distribution over real numbers between an upper and lower bound.  If both bounds are infinite, it reduces to an ordinary Gaussian distribution.
            </summary>
            <remarks>
            The distribution is parameterized by a Gaussian and two real numbers (LowerBound, UpperBound).
            Between the bounds, the density is proportional to the Gaussian.  Outside of the bounds, the density is zero.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Gaussian">
            <summary>
            Untruncated Gaussian
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.LowerBound">
            <summary>
            Lower bound
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.UpperBound">
            <summary>
            Upper bound
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.#ctor(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Create a new TruncatedGaussian distribution equal to that
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.#ctor(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Create a truncated Gaussian equivalent to a Gaussian, i.e. with no truncation.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.FromGaussian(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Create a truncated Gaussian equivalent to a Gaussian, i.e. with no truncation.
            </summary>
            <param name="gaussian"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.#ctor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Create a truncated Gaussian from a Gaussian and bounds
            </summary>
            <param name="gaussian"></param>
            <param name="lowerBound"></param>
            <param name="upperBound"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a truncated Gaussian from untruncated (mean, variance) and bounds
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
            <param name="lowerBound"></param>
            <param name="upperBound"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Uniform">
            <summary>
            Construct a uniform truncated Gaussian. This is mathematically equivalent to
            a uniform Gaussian. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.PointMass(System.Double)">
            <summary>
            Create a point mass distribution.
            </summary>
            <param name="point">The location of the point mass</param>
            <returns>A new TruncatedGaussian with all probability concentrated on the given point.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.ToGaussian">
            <summary>
            Get the Gaussian with the same moments as this truncated Gaussian. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this distribution and that
            </summary>
            <param name="thatd"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Equals(System.Object)">
            <summary>
            True if this distribution has the same parameters as that
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns></returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetHashCode">
            <summary>
            A hash of the distribution parameter values
            </summary>
            <returns></returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.op_Equality(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.op_Inequality(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Clone">
            <summary>
            Make a deep copy of this distribution. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetLogProb(System.Double)">
            <summary>
            Get the log probability density at value. 
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetLogNormalizer">
            <summary>
            Gets the log of the normalizer for the Gaussian density function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.IsProper">
            <summary>
            Returns true if this distribution is proper
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.SetTo(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Set this distribution equal to value. 
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.SetToProduct(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Set this distribution equal to the product of a and b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.op_Multiply(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Operator overload for product. 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.SetToUniform">
            <summary>
            Set the distribution to uniform with infinite bounds
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.IsUniform">
            <summary>
            Asks whether this instance is uniform. If the upper and lower bounds are finite the distribution
            is not uniform. 
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.SetToRatio(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Boolean)">
            <summary>
            Set this equal to numerator/denominator
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
            <param name="forceProper"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.op_Division(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Operator overload for division
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.SetToPower(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double)">
            <summary>
            Set this equal to (dist)^exponent
            </summary>
            <param name="dist"></param>
            <param name="exponent"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double)">
            <summary>
            Operator overload for exponentation
            </summary>
            <param name="dist"></param>
            <param name="exponent"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Sample(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Sample from a TruncatedGaussian distribution with the specified parameters
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Sample">
            <summary>
            Sample from the distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Sample(System.Double)">
            <summary>
            Sample from the distribution
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetMean">
            <summary>
            Returns the mean (first moment) of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Get the mean and variance after truncation.
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetVariance">
            <summary>
            Get the variance of this distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Get the logarithm of the average value of that distribution under this distribution, i.e. log(int this(x) that(x) dx)
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.ToString">
            <summary>
            A human-readable string containing the parameters of the distribution
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian,System.Double,MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Set the parameters to match the moments of a mixture distribution.
            </summary>
            <param name="dist1">The first distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.GetAverageLog(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Get the average logarithm of that distribution under this distribution, i.e. int this(x) log( that(x) ) dx
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.Point">
            <summary>
            Set this distribution to a point mass, or get its location
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.TruncatedGaussian.IsPointMass">
            <summary>
            True if the distribution is a point mass. 
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseBetaList">
            <summary>
            Represents a list of Beta distributions, optimised for the case where many share 
            the same pseudocount values.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.#ctor">
            <summary>
            Parameterless constructor required for serialization 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.#ctor(System.Int32)">
            <summary>
            Creates a list of Betas of the specified size, each set to uniform.
            </summary>
            <param name="size">The size of the list</param>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseBetaList.DefaultSparsity">
            <summary>
            The default sparsity settings.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.#ctor(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a list of Betas of the specified size, each set to have the specified true and false counts.
            </summary>
            <param name="size">The size of the list</param>
            <param name="trueCount">The true count for each Beta distribution</param>
            <param name="falseCount">The false count for each Beta distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.#ctor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a list of Betas using the supplied vectors of true and false counts.
            </summary>
            <param name="trueCounts">The vector of true counts</param>
            <param name="falseCounts">The vector of false counts</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.PointMass(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Creates a point mass SparseBetaList
            </summary>
            <param name="probsTrue"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.GetMean">
            <summary>
            The expected value E[p].
            </summary>
            <returns>Sparse vector of the means of the elements</returns>
            <remarks>Elements of the result must be between 0 and 1.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.GetMeanLog">
            <summary>
            The expected value E[log(p)].
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.GetMeanLogOneMinus">
            <summary>
            The expected value E[log(1-p)].
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.MaxDiff(System.Object)">
            <summary>
            The maximum 'difference' between corresponding Beta elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.SetToUniform">
            <summary>
            Sets all Beta elements to uniform.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.IsUniform">
            <summary>
            Tests if all Bernoulli elements are uniform.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.GetLogProb(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Evaluates the logarithm of the density function
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.SetToProduct(MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            Sets to the product of two sparse lists of Betas.
            </summary>
            <param name="a">The first sparse list of Betas</param>
            <param name="b">The second sparse list of Betas</param>
            <remarks>
            The result may not be proper, i.e. its parameters may be negative.
            For example, if you multiply Beta(0.1,0.1) by itself you get Beta(-0.8, -0.8).
            No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.SetToPower(MicrosoftResearch.Infer.Distributions.SparseBetaList,System.Double)">
            <summary>
            Sets the parameters to represent the list of sparse Betas raised to some power.
            </summary>
            <param name="betaList">The list of Betas</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.SetTo(MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            Sets this Beta list to a copy of another Beta list.
            </summary>
            <param name="value">The list to copy</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.Clone">
            <summary>
            Clones this sparse Beta list.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.Sample">
            <summary>
            Samples a vector from this distribution.
            </summary>
            <returns></returns>
            <remarks>The samples themselves will not be sparse</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.Sample(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Samples a vector from this distribution.
            </summary>
            <param name="sv">Where to put the result</param>
            <returns></returns>
            <remarks>The samples themselves will not be sparse</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.SparseBetaList,System.Double,MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            Sets this sparse Bernoulli list to the weighted sum of two others (which must be of the same size)
            </summary>
            <param name="weight1"></param>
            <param name="value1"></param>
            <param name="weight2"></param>
            <param name="value2"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.SetToRatio(MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Distributions.SparseBetaList,System.Boolean)">
            <summary>
            Sets this sparse Bernoulli list to the ratio of two others (which must be of the same size)
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            Gets the integral of the product of two sparse Beta list distributions.
            </summary>
            <remarks>Not yet implemented</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.GetAverageLog(MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            Gets the expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>Not yet implemented.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.ToString">
            <summary>
            ToString override
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBetaList.ToArray">
            <summary>
            Converts this sparse array to a dense .NET array.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseBetaList.TrueCounts">
            <summary>
            The sparse vector holding the true counts of each Beta in the list
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseBetaList.FalseCounts">
            <summary>
            The sparse vector holding the false counts of each Beta in the list
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseBetaList.Count">
            <summary>
            The number of elements in the list
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseBetaList.Item(System.Int32)">
            <summary>Gets or sets a Beta element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseBetaList.Point">
            <summary>
            Gets/sets the distribution as a point value list of doubles
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseBetaList.IsPointMass">
            <summary>
            Whether all the Beta elements are point masses
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Gamma">
            <summary>
            A Gamma distribution on positive reals.
            </summary>
            <remarks><para>
            The distribution is 
            <c>p(x) = x^(a-1)*exp(-x*b)*b^a/Gamma(a)</c>.
            In this code, the <c>a</c> parameter is called the "Shape" and the <c>b</c> parameter
            is called the "Rate".  The distribution is sometimes also parameterized by (shape,scale)
            where scale = 1/rate.
            The mean of the distribution is <c>shape/rate</c> and the variance is 
            <c>shape/rate^2</c>.
            </para><para>
            Special cases:
            When the shape is 1 and rate is 0, the distribution is uniform.
            When the shape is infinity, the distribution is a point mass and the density is delta(x-Point)
            where the Point property gives the mean.
            When a &lt;= 0 or b &lt;= 0 the <c>b^a/Gamma(a)</c> term is dropped.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Gamma.Rate">
            <summary>
            Rate parameter for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Gamma.Shape">
            <summary>
            Shape parameter for the distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMean">
            <summary>
            Gets the expected value E(x) - calculated as shape/rate
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetVariance">
            <summary>
            Gets the variance - calculated as shape/rate^2
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean (shape/rate) and variance (shape/rate^2)
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a new Gamma distribution from mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new Gamma instance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetShapeAndRate(System.Double,System.Double)">
            <summary>
            Sets the shape and rate (rate = 1/scale) parameters of the distribution.
            </summary>
            <param name="shape"></param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromShapeAndRate(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and rate parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="rate">rate = 1/scale</param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetScale">
            <summary>
            Gets the scale (1/rate)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetShapeAndScale(System.Double@,System.Double@)">
            <summary>
            Gets the shape and scale (1/rate)
            </summary>
            <param name="shape">Where to put the shape</param>
            <param name="scale">Where to put the scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetShapeAndScale(System.Double,System.Double)">
            <summary>
            Sets the shape and scale for this instance
            </summary>
            <param name="shape">Shape</param>
            <param name="scale">Scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromShapeAndScale(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and scale parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="scale">scale</param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromMeanAndMeanLog(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given mean and mean logarithm.
            </summary>
            <param name="mean">Desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <returns>A new Gamma distribution.</returns>
            <remarks>This function is equivalent to maximum-likelihood estimation of a Gamma distribution
            from data given by sufficient statistics.
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization. The algorithm is a generalized Newton iteration, 
            described in "Estimating a Gamma distribution" by T. Minka, 2002.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromLogMeanAndMeanLog(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given log mean and mean logarithm.
            </summary>
            <param name="logMean">Log of desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <returns>A new Gamma distribution.</returns>
            <remarks>
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization. The algorithm is a generalized Newton iteration, 
            described in "Estimating a Gamma distribution" by T. Minka, 2002.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetNatural(System.Double,System.Double)">
            <summary>
            Sets the natural parameters of the distribution.
            </summary>
            <param name="shapeMinus1">The shape parameter - 1.</param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMeanLog">
            <summary>
            Computes E[log(x)]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMeanInverse">
            <summary>
            Computes E[1/x]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMeanPower(System.Double)">
            <summary>
            Computes E[x^power]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing Rate parameter
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToUniform">
            <summary>
            Sets this Gamma instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogProb(System.Double,System.Double,System.Double)">
            <summary>
            Logarithm of the Gamma density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate parameter</param>
            <returns>log(Gamma(x;shape,rate))</returns>
            <remarks>
            The distribution is <c>p(x) = x^(a-1)*exp(-x*b)*b^a/Gamma(a)</c>.
            When a &lt;= 0 or b &lt;= 0 the <c>b^a/Gamma(a)</c> term is dropped.
            Thus if shape = 1 and rate = 0 the density is 1.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogProb(System.Double)">
            <summary>
            Logarithm of this Gamma density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <returns>log(Gamma(x;shape,rate))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogNormalizer">
            <summary>
            Gets log normalizer
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetAverageLog(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.IsProper">
            <summary>
            Asks whether this Gamma instance is proper or not. A Gamma distribution
            is proper only if Shape > 0 and Rate > 0.
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.IsProper(System.Double,System.Double)">
            <summary>
            Asks whether a Gamma distribution is proper or not. A Gamma distribution
            is proper only if Shape > 0 and Rate > 0.
            </summary>
            <param name="shape">shape parameter for the Gamma</param>
            <param name="rate">rate parameter for the Gamma</param>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            The log of the integral of the product of this Gamma and that Gamma
            </summary>
            <param name="that">That Gamma</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Sample">
            <summary>
            Samples from this Gamma distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Sample(System.Double)">
            <summary>
            Samples from this Gamma distribution
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Sample(System.Double,System.Double)">
            <summary>
            Samples from a Gamma distribution with given shape and scale
            </summary>
            <param name="shape">shape parameter</param>
            <param name="scale">scale parameter</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SampleFromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Samples from a Gamma distribution with given mean and variance
            </summary>
            <param name="mean">mean parameter</param>
            <param name="variance">variance parameter</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetTo(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Sets this Gamma instance to have the parameter values of that Gamma instance
            </summary>
            <param name="that">That Gamma</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToProduct(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Sets the parameters to represent the product of two Gammas.
            </summary>
            <param name="a">The first Gamma</param>
            <param name="b">The second Gamma</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_Multiply(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Creates a new Gamma which the product of two other Gammas
            </summary>
            <param name="a">First Gamma</param>
            <param name="b">Second Gamma</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two Gammas
            </summary>
            <param name="numerator">The numerator Gamma.  Can be the same object as this.</param>
            <param name="denominator">The denominator Gamma.  Can be the same object as this.</param>
            <param name="forceProper">If true, the result has shape >= 1 and rate >= 0, under the constraint that result*denominator has the same mean as numerator</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_Division(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Creates a new Gamma which the ratio of two other Gammas
            </summary>
            <param name="numerator">numerator Gamma</param>
            <param name="denominator">denominator Gamma</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToPower(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source Gamma to some exponent.
            </summary>
            <param name="dist">The source Gamma</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Set the mean and variance to match the moments of a mixture of two Gammas.
            </summary>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first Gamma</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second Gamma</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Gamma
            and that Gamma
            </summary>
            <param name="thatd">That Gamma</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            Array of distribution requiring the distribution type to be a value type.
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_Equality(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_Inequality(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.#ctor(System.Double,System.Double)">
            <summary>
            Creates a Gamma distribution with given shape and scale parameters (scale = 1/rate) 
            </summary>
            <param name="shape"></param>
            <param name="scale">scale = 1/rate</param>
            <remarks>
            The distribution is <c>p(x) = x^(shape-1)*exp(-x/scale)/(scale^shape * Gamma(shape))</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromNatural(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution from its natural parameters.
            </summary>
            <param name="shapeMinus1">shape - 1</param>
            <param name="rate">rate = 1/scale</param>
            <returns>A new Gamma distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.#ctor(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Clone">
            <summary>
            Clones this Gamma. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Gamma type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Uniform">
            <summary>
            Create a uniform Gamma distribution.
            </summary>
            <returns>A new uniform Gamma distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.PointMass(System.Double)">
            <summary>
            Creates a point mass Gamma distribution
            </summary>
            <param name="mean">The location of the point mass</param>
            <returns>A new point mass Gamma distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Gamma.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Gamma.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DirichletEstimator">
            <summary>
            Estimates a Dirichlet distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DirichletEstimator.N">
            <summary>
            Number of samples
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Sum">
            <summary>
            Sum
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Sum2">
            <summary>
            Sum of squares
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new Dirichlet estimator
            </summary>
            <param name="dimension">Dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Gets the estimated distribution
            </summary>
            <param name="result">Where to put the estimated distribution</param>
            <returns>The estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Add(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Adds a Dirichlet item to the estimator
            </summary>
            <param name="item">A Dirichlet instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Add(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Adds a Vector sample to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.SetTo(MicrosoftResearch.Infer.Distributions.DirichletEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Dimension">
            <summary>
            Dimension of the Dirichlet
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2">
            <summary>
            A generic base class for discrete distributions over a type T.
            </summary>
            <remarks>
            This class makes it straightforward to implement discrete distributions
            over types other than int.  It is only necessary to make a subclass of
            this abstract class, add a constructor and implement two methods to convert 
            the desired type T to and from an integer. 
            
            Internally, this class wraps a Discrete distribution and uses it to provide
            all functionality.
            </remarks>
            <typeparam name="T">The domain type of this distribution</typeparam>
            <typeparam name="TThis">The type of the subclass (allows factory methods return the correct type)</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.#ctor(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a discrete
            </summary>
            <param name="dimension">The dimension of the underlying discrete</param>
            <param name="sparsity">The sparsity of the underlying discrete</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Uniform">
            <summary>
            Creates a uniform distribution.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.FromDiscrete(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Creates a distribution using the probabilities from the given discrete distribution.
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.FromProbs(System.Double[])">
            <summary>
            Creates a distribution from the given probabilities.
            </summary>
            <param name="probs"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.FromVector(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a distribution from the given vector of probabilities.
            </summary>
            <param name="probs"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformInRange(`0,`0)">
            <summary>
            Creates a Discrete distribution which is uniform over values from
            start to end inclusive.
            </summary>
            <param name="start">The first value included in the distribution</param>
            <param name="end">The last value included in the distribution</param>
            <returns>Discrete which is uniform over the specified range (and zero elsewhere).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformInRanges(`0[])">
            <summary>
            Creates a Discrete distribution which is uniform over values in
            multiple ranges specified by pairs of start and end values. These pairs
            are specified as adjacent values in an array whose length must therefore be
            even.
            </summary>
            <param name="startEndPairs">Sequence of start and end pairs</param>
            <returns>Discrete which is uniform over the specified range (and zero elsewhere).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.UniformInRanges(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a Discrete distribution which is uniform over values in
            multiple ranges specified by pairs of start and end values. These pairs
            are specified as adjacent values in an enumerable whose length must therefore be
            even.
            </summary>
            <param name="startEndPairs">Sequence of start and end pairs</param>
            <returns>Discrete which is uniform over the specified range (and zero elsewhere).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.PointMass(`0)">
            <summary>
            Creates a point mass distribution.
            </summary>
            <param name="value">The allowed value.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetLogProb(`0)">
            <summary>
            Evaluates the log density at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The log density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetWorkspace">
            <summary>
            Gets a Vector of size this.Dimension.
            </summary>
            <returns>A pointer to the internal probs Vector of the object.</returns>
            <remarks>
            This function is intended to be used with SetProbs, to avoid allocating a new Vector.
            The return value should not be interpreted as a probs vector, but only a workspace filled
            with unknown data that can be overwritten.  Until SetProbs is called, the distribution object 
            is invalid once this workspace is modified.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetInternalDiscrete">
            <summary>
            Gets the internal discrete distribution that this distribution wraps.
            </summary>
            <returns>The internal discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetProbs">
            <summary>
            Gets the probability at each index.
            </summary>
            <returns>The vector of probabilities</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetProbs(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the probability of each index.
            </summary>
            <param name="probs">A vector of non-negative, finite numbers.  Need not sum to 1.</param>
            <remarks>
            Instead of allocating your own Vector to pass to SetProbs, you can call <see cref="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetWorkspace"/>,
            fill in the resulting Vector, and then pass it to SetProbs.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Clone">
            <summary>
            Returns a clone of this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.IsUniform">
            <summary>
            Returns true if the distribution is uniform.
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetToUniform">
            <summary>
            Sets this instance to a uniform discrete (i.e. probabilities all equal)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.MaxDiff(System.Object)">
            <summary>
            Gets the maximum difference between the parameters of this discrete and that discrete
            </summary>
            <param name="that">That discrete</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.ConvertFromInt(System.Int32)">
            <summary>
            Converts an integer to an item of type T.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.ConvertToInt(`0)">
            <summary>
            Converts an item of type T to an integer.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.ToString(`0)">
            <summary>
            Implements a custom ToString() for items of type T.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.MicrosoftResearch#Infer#Distributions#CanGetLogProb{T}#GetLogProb(`0)">
            <summary>
            Returns the log probability of the value under this distribution.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetTo(`1)">
            <summary>
            Sets the parameters of this instance to the parameters of that instance
            </summary>
            <param name="value">That instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetToProduct(`1,`1)">
            <summary>
            Sets the parameters to represent the product of two discrete distributions.
            </summary>
            <param name="a">The first discrete distribution</param>
            <param name="b">The second discrete distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetToRatio(`1,`1,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two discrete distributions.
            </summary>
            <param name="numerator">The numerator discrete distribution</param>
            <param name="denominator">The denominator discrete distribution</param>
            <param name="forceProper">Whether to force the returned distribution to be proper</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetToPower(`1,System.Double)">
            <summary>
            Sets the parameters to represent the power of a discrete distributions.
            </summary>
            <param name="value">The discrete distribution</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.SetToSum(System.Double,`1,System.Double,`1)">
            <summary>
            Sets the parameters to represent the weighted sum of two discrete distributions.
            </summary>
            <param name="value1">The first discrete distribution</param>
            <param name="weight1">The first weight</param>
            <param name="value2">The second discrete distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetLogAverageOf(`1)">
            <summary>
            The log of the integral of the product of this discrete distribution and that discrete distribution
            </summary>
            <param name="that">That discrete distribution</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetLogAverageOfPower(`1,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetAverageLog(`1)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.ToString(System.String,System.String)">
            <summary>
            Returns a string representation of this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Sample">
            <summary>
            Returns a sample from the distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Sample(`0)">
            <summary>
            Returns a sample from the distribution
            </summary>
            <param name="result">Not used</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="that">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Dimension">
            <summary>
            The dimension of this discrete distribution.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Item(`0)">
            <summary>
            Gets the probability of a given value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.Point">
            <summary>
            Point property
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GenericDiscreteBase`2.IsPointMass">
            <summary>
            Returns true if the distribution is a point mass.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Binomial">
            <summary>
            Binomial distribution over the integers [0,n]
            </summary>
            <remarks>
            The formula for the distribution is <c>p(x) = n!/(n-x)!/x! p^x (1-p)^(n-x)</c>.
            In this implementation, we use a generalization that includes two extra shape parameters (a,b)
            The formula for the generalized distribution is <c>p(x) =propto 1/x!^a 1/(n-x)!^b exp(x*logOdds)</c>.
            With this extension, we can represent a uniform distribution via (logOdds=0,a=0,b=0) and
            a point mass via logOdds=+/-infinity or a=infinity or b=infinity.
            This family is closed under multiplication, while the standard Binomial is not.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Binomial.SetToRatio(MicrosoftResearch.Infer.Distributions.Binomial,MicrosoftResearch.Infer.Distributions.Binomial,System.Boolean)">
            <summary>
            Set this distribution to equal the ratio of two distributions
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
            <param name="forceProper">Ignored</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.WrappedGaussianProductOp">
            <summary>
            Provides outgoing WrappedGaussian messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/> and <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp">
            <summary>
            Provides outgoing Gaussian messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/> and <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GaussianProductOp.QuadratureNodeCount">
            <summary>
            The number of quadrature nodes used to compute the messages.
            Reduce this number to save time in exchange for less accuracy.
            Must be an odd number.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GaussianProductOp.ForceProper">
            <summary>
            Force proper messages
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'product'
            </summary>
            <param name="Product">Incoming message from 'product'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[p(product) sum_(a,b) p(a,b) factor(product,a,b)]/p(product)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(product,b) p(product,b) factor(product,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(b) p(b) factor(product,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(product,a) p(product,a) factor(product,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(a) p(a) factor(product,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'product'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[p(product) sum_(b) p(b) factor(product,a,b)]/p(product)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'product'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[p(product) sum_(a) p(a) factor(product,a,b)]/p(product)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'product'
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'product' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(product) p(product) factor(product,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.AAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(product) p(product) factor(product,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.BAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp_SHG09">
            <summary>
            This class allows EP to process the product factor as if running VMP, as required by Stern's algorithm.
            </summary>
            <remarks>
            This algorithm comes from "Matchbox: Large Scale Online Bayesian Recommendations" by David Stern, Ralf Herbrich, and Thore Graepel, WWW 2009.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace2">
            <summary>
            This class allows EP to process the product factor using Laplace's method
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp_Laplace">
            <summary>
            This class allows EP to process the product factor using Laplace's method
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp6">
            <summary>
            This class allows EP to process the product factor using modified Laplace's method
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp3">
            <summary>
            This class allows EP to process the product factor as a linear factor.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp4">
            <summary>
            This class allows EP to process the product factor using an approximation to the integral Z.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp5">
            <summary>
            This class allows EP to process the product factor using a log-normal approximation to the input distributions
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp">
            <summary>
            Provides Gaussian evidence messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <param name="to_product">Outgoing message to 'product'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product,a) p(product,a) factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <param name="to_product">Outgoing message to 'product'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product,b) p(product,b) factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(product,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product) p(product) factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product,a) p(product,a) factor(product,a,b) / sum_product p(product) messageTo(product))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product,b) p(product,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(product,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(product,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp">
            <summary>
            Provides Gaussian evidence messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <param name="to_ratio">Outgoing message to 'ratio'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(ratio,a) p(ratio,a) factor(ratio,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <param name="to_ratio">Outgoing message to 'ratio'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(ratio,b) p(ratio,b) factor(ratio,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(ratio,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(ratio,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(ratio,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(ratio,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(ratio) p(ratio) factor(ratio,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(ratio,a) p(ratio,a) factor(ratio,a,b) / sum_ratio p(ratio) messageTo(ratio))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(ratio,b) p(ratio,b) factor(ratio,a,b) / sum_ratio p(ratio) messageTo(ratio))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(ratio,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(ratio,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(product,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'product'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[sum_(a,b) p(a,b) factor(product,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.ProductAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'product'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[sum_(b) p(b) factor(product,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'product'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[sum_(a) p(a) factor(product,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            Because the factor is deterministic, 'product' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(b) p(b) log(sum_product p(product) factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' with 'product' integrated out.
            The formula is <c>sum_product p(product) factor(product,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            Because the factor is deterministic, 'product' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(a) p(a) log(sum_product p(product) factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            The formula is <c>exp(sum_(a) p(a) log(factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' with 'product' integrated out.
            The formula is <c>sum_product p(product) factor(product,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp">
            <summary>
            Provides VMP Gaussian evidence messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(ratio,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.RatioAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'ratio'
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'ratio' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'ratio' as the random arguments are varied.
            The formula is <c>proj[sum_(b) p(b) factor(ratio,a,b)]</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.RatioAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'ratio'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'ratio' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'ratio' as the random arguments are varied.
            The formula is <c>proj[sum_(a) p(a) factor(ratio,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(ratio,a,b)))</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="ratio">Incoming message from 'ratio'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' with 'ratio' integrated out.
            The formula is <c>sum_ratio p(ratio) factor(ratio,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="ratio"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.BAverageLogarithm">
            <summary>
            VMP message to 'b'
            </summary>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoublePlusOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Double,System.Double)"/> and <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Difference(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_sum">Outgoing message to 'sum'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="a">Incoming message from 'A'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_a">Outgoing message to 'a'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(A) p(A) factor(Sum,A,B))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <param name="to_b">Outgoing message to 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(B) p(B) factor(Sum,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Sum,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'Sum'
            </summary>
            <param name="a">Incoming message from 'A'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'B'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[p(Sum) sum_(A,B) p(A,B) factor(Sum,A,B)]/p(Sum)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'Sum'
            </summary>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Incoming message from 'B'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[p(Sum) sum_(B) p(B) factor(Sum,A,B)]/p(Sum)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'Sum'
            </summary>
            <param name="a">Incoming message from 'A'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>The outgoing EP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[p(Sum) sum_(A) p(A) factor(Sum,A,B)]/p(Sum)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'Sum'
            </summary>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>The outgoing EP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Sum' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'A'
            </summary>
            <param name="Sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'B'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'A' as the random arguments are varied.
            The formula is <c>proj[p(A) sum_(Sum,B) p(Sum,B) factor(Sum,A,B)]/p(A)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'A'
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="b">Incoming message from 'B'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'A' as the random arguments are varied.
            The formula is <c>proj[p(A) sum_(B) p(B) factor(Sum,A,B)]/p(A)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'A'
            </summary>
            <param name="Sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>The outgoing EP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'A' as the random arguments are varied.
            The formula is <c>proj[p(A) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(A)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'A'
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>The outgoing EP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'A' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'B'
            </summary>
            <param name="Sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'A'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'B' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'B' as the random arguments are varied.
            The formula is <c>proj[p(B) sum_(Sum,A) p(Sum,A) factor(Sum,A,B)]/p(B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'B'
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="a">Incoming message from 'A'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'B' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'B' as the random arguments are varied.
            The formula is <c>proj[p(B) sum_(A) p(A) factor(Sum,A,B)]/p(B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'B'
            </summary>
            <param name="Sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value for 'A'.</param>
            <returns>The outgoing EP message to the 'B' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'B' as the random arguments are varied.
            The formula is <c>proj[p(B) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'B'
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <returns>The outgoing EP message to the 'B' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'B' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoublePlusEvidenceOp">
            <summary>
            Evidence methods for Factor.Plus only
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Sum">Incoming message from 'Sum'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B) / sum_Sum p(Sum) messageTo(Sum))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusEvidenceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Sum,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <param name="to_b">Outgoing message to 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(B) p(B) factor(Sum,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="a">Incoming message from 'A'.</param>
            <param name="to_a">Outgoing message to 'a'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(A) p(A) factor(Sum,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoubleMinusEvidenceOp">
            <summary>
            Evidence methods for Factor.Difference only
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="difference">Incoming message from 'difference'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(difference) p(difference) factor(difference,a,b) / sum_difference p(difference) messageTo(difference))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusEvidenceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="difference">Constant value for 'difference'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(difference,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="difference">Constant value for 'difference'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="to_a">Outgoing message to 'a'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(difference,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="difference">Constant value for 'difference'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <param name="to_b">Outgoing message to 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(difference,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp">
            <summary>
            These operator methods are only valid for plus, not minus.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sum">Incoming message from 'Sum'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Sum,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Incoming message from 'A'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AverageLogFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'Sum'
            </summary>
            <param name="a">Incoming message from 'A'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'B'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[sum_(A,B) p(A,B) factor(Sum,A,B)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'Sum'
            </summary>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Incoming message from 'B'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[sum_(B) p(B) factor(Sum,A,B)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'Sum'
            </summary>
            <param name="a">Incoming message from 'A'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>The outgoing VMP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[sum_(A) p(A) factor(Sum,A,B)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'Sum'
            </summary>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>The outgoing VMP message to the 'Sum' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Sum' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="Sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'B'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'A'.
            Because the factor is deterministic, 'Sum' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(B) p(B) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="b">Incoming message from 'B'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'A'.
            The formula is <c>exp(sum_(B) p(B) log(factor(Sum,A,B)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="Sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>The outgoing VMP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'A' with 'Sum' integrated out.
            The formula is <c>sum_Sum p(Sum) factor(Sum,A,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>The outgoing VMP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'A' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="Sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'A'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'B' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'B'.
            Because the factor is deterministic, 'Sum' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(A) p(A) log(sum_Sum p(Sum) factor(Sum,A,B)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="a">Incoming message from 'A'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'B' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'B'.
            The formula is <c>exp(sum_(A) p(A) log(factor(Sum,A,B)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="Sum">Incoming message from 'Sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value for 'A'.</param>
            <returns>The outgoing VMP message to the 'B' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'B' with 'Sum' integrated out.
            The formula is <c>sum_Sum p(Sum) factor(Sum,A,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="Sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <returns>The outgoing VMP message to the 'B' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'B' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp">
            <summary>
            Provides outgoing VMP messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Difference(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(difference,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.DifferenceAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'difference'
            </summary>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'difference' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'difference' as the random arguments are varied.
            The formula is <c>proj[sum_(a,b) p(a,b) factor(difference,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.DifferenceAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'difference'
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'difference' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'difference' as the random arguments are varied.
            The formula is <c>proj[sum_(b) p(b) factor(difference,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.DifferenceAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'difference'
            </summary>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'difference' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'difference' as the random arguments are varied.
            The formula is <c>proj[sum_(a) p(a) factor(difference,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.DifferenceAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'difference'
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'difference' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'difference' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Difference">Incoming message from 'difference'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            Because the factor is deterministic, 'difference' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(b) p(b) log(sum_difference p(difference) factor(difference,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Difference"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Difference">Incoming message from 'difference'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' with 'difference' integrated out.
            The formula is <c>sum_difference p(difference) factor(difference,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Difference"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Difference">Constant value for 'difference'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(difference,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Difference">Constant value for 'difference'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Difference">Incoming message from 'difference'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            Because the factor is deterministic, 'difference' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(a) p(a) log(sum_difference p(difference) factor(difference,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Difference"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Difference">Incoming message from 'difference'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' with 'difference' integrated out.
            The formula is <c>sum_difference p(difference) factor(difference,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Difference"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Difference">Constant value for 'difference'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            The formula is <c>exp(sum_(a) p(a) log(factor(difference,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Difference">Constant value for 'difference'.</param>
            <param name="a">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsPositiveOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.IsPositive(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isPositive">Constant value for 'isPositive'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(x) p(x) factor(isPositive,x))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isPositive">Incoming message from 'isPositive'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isPositive,x) p(isPositive,x) factor(isPositive,x))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isPositive">Incoming message from 'isPositive'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(isPositive,x) p(isPositive,x) factor(isPositive,x) / sum_isPositive p(isPositive) messageTo(isPositive))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="isPositive">Constant value for 'isPositive'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(x) p(x) factor(isPositive,x))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.IsPositiveAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'isPositive'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'isPositive' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isPositive' as the random arguments are varied.
            The formula is <c>proj[p(isPositive) sum_(x) p(x) factor(isPositive,x)]/p(isPositive)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="isPositive">Incoming message from 'isPositive'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'x' as the random arguments are varied.
            The formula is <c>proj[p(x) sum_(isPositive) p(isPositive) factor(isPositive,x)]/p(x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isPositive"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="isPositive">Incoming message from 'isPositive'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Constant value for 'x'.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'x' as the random arguments are varied.
            The formula is <c>proj[p(x) sum_(isPositive) p(isPositive) factor(isPositive,x)]/p(x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isPositive"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'
            </summary>
            <param name="isPositive">Constant value for 'isPositive'.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="isPositive">Constant value for 'isPositive'.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_X">Previous outgoing message to 'X'.</param>
            <returns>The outgoing VMP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="isPositive">Constant value for 'isPositive'.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_X">Previous outgoing message to 'X'.</param>
            <returns>The outgoing VMP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="isPositive">Message from isPositive</param>
            <param name="X">Message from X</param>
            <param name="to_X">Message to X</param>
            <remarks>The formula for the result is <c>sum_(sample,precision) p(sample,precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.</remarks>
            <returns>Evidence</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="isPositive">Constant value for 'isPositive'.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_X">Previous outgoing message to 'X'.</param>
            <returns>Evidence</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageLogarithm(System.Boolean)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="isPositive">Constant value for 'isPositive'.</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.IsPositiveAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'isPositive'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'isPositive' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'isPositive' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(isPositive,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.AverageLogFactor_helper(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="X">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_X">Previous outgoing message to 'X'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsPositiveOp_Proper">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.IsPositive(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromDiscrete(System.Int32,System.Double[])"/>, given random arguments to the function.
            </summary>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="index">Incoming message from 'index'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,index,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="index">Incoming message from 'index'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (sample,index,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.SampleConditional(System.Int32,System.Double[])">
            <summary>
            Gibbs message to 'sample'.
            </summary>
            <param name="index">Constant value for 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing Gibbs message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.SampleAverageConditional(System.Int32,System.Double[])">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="index">Constant value for 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (index,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.SampleAverageLogarithm(System.Int32,System.Double[])">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="index">Constant value for 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (index,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.IndexConditional(System.Boolean,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Gibbs message to 'index'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'index' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.IndexAverageConditional(System.Boolean,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'index'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'index'.
            The formula is <c>int f(index,x) q(x) dx</c> where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.IndexAverageLogarithm(System.Boolean,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'index'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'index'.
            The formula is <c>int log(f(index,x)) q(x) dx</c> where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="index">Incoming message from 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (index,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="index">Incoming message from 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (index,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.IndexAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'index'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'index'.
            The formula is <c>int f(index,x) q(x) dx</c> where <c>x = (sample,probTrue)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.IndexAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'index'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'index'.
            The formula is <c>int log(f(index,x)) q(x) dx</c> where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.EvaluateLn(System.Boolean,System.Int32,System.Double[])">
            <summary>
            Evaluate the factor when inbox is all constants (for Gibbs sampling)
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscreteOp.AverageValueLn(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>
            
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="index">Incoming message from 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete">
            <summary>
            Represents a discrete distribution in the log domain without explicit normalization.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.logProb">
            <summary>
            Log probability of each value (when not a point mass).  Since the distribution is unnormalized, these may be shifted by an arbitrary constant.
            </summary>
            <remarks>
            logprob.Length == D.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Clone">
            <summary>
            Clones this unnormalised discrete distribution. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a UnnormalizedDiscrete type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.FromLogProbs(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Creates an unnormalized discrete distribution from a vector of log probabilities.
            </summary>
            <param name="logProb"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.FromDiscrete(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Creates an unnormalized discrete distribution from a normal discrete distribution.
            </summary>
            <param name="d">The discrete distribution</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Uniform(System.Int32)">
            <summary>
            Creates a uniform unnormalized discrete distribution over the values from 0 to numValues-1
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this discrete and that discrete
            </summary>
            <param name="that">That discrete</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetToUniform">
            <summary>
            Sets this instance to a uniform distribution (i.e. probabilities all equal)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.IsUniform">
            <summary>
            Returns whether the distribution is uniform or not
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetLogProb(System.Int32)">
            <summary>
            Evaluates the log of the unnormalized density at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The log unnormalized density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Evaluate(System.Int32)">
            <summary>
            Evaluates the unnormalized probability at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The unnormalized probability</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetWorkspace">
            <summary>
            Gets a Vector of size this.Dimension.
            </summary>
            <returns>A pointer to the internal log prob Vector of the object.</returns>
            <remarks>
            This function is intended to be used with SetLogProbs, to avoid allocating a new Vector.
            The return value should not be interpreted as a probs vector, but only a workspace filled
            with unknown data that can be overwritten.  Until SetLogProbs is called, the distribution object 
            is invalid once this workspace is modified.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetLogProbs(MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Sets the log probability vector for this distribution.
            </summary>
            <param name="logProbs">A vector of non-negative, finite numbers.  Need not sum to 1.</param>
            <remarks>
            Instead of allocating your own Vector to pass to SetProbs, you can call <see cref="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetWorkspace"/>,
            fill in the resulting Vector, and then pass it to SetProbs.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetTo(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            Sets the parameters of this instance to the parameters of that instance
            </summary>
            <param name="value">That instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetToProduct(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            Sets the parameters to represent the product of two unnormalized discrete distributions.
            </summary>
            <param name="a">The first unnormalized discrete distribution</param>
            <param name="b">The second unnormalized discrete distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.op_Multiply(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            Creates an unnormalized discrete distribution which is the product of two unnormalized discrete distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting unnormalized discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetToRatio(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two unnormalized discrete distributions.
            </summary>
            <param name="numerator">The first unnormalized discrete distribution</param>
            <param name="denominator">The second unnormalized discrete distribution</param>
            <param name="forceProper">Ignored</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.op_Division(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            Creates an unnormalized discrete distribution which is the ratio of two unnormalized discrete distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting unnormalized discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.ToString">
            <summary>
            Override of ToString method
            </summary>
            <returns>String representation of this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.ToString(System.String)">
            <summary>
            Override of ToString method which allows custom number formatting
            </summary>
            <returns>String representation of this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetProbs">
            <summary>
            Gets the unnormalized probability vector for this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetMaxToZero">
            <summary>
            Rescales the unnormalised distribution, so that the max log prob is zero i.e. the max unnormalised prob is 1.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Dimension">
            <summary>
            Dimension of the unnormalised discrete distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Point">
            <summary>
            Sets/gets this distribution as a point distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.IsPointMass">
            <summary>
            Whether or not this instance is a point mass.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel">
            <summary>
            Neural Net kernel
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.SetupParams(System.Double[],System.Double)">
            <summary>
            Sets up names and values of parameters
            </summary>
            <param name="logWeightVariances">Log weight variances</param>
            <param name="logBiasWeightVariance">Log bias weight variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.GetLogWeightVariances">
            <summary>
            Gets the log weight variances from this Neural Net kernel instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.GetLogBiasWeightVariance">
            <summary>
            Gets the log bias variances from this Neural Net kernel instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.#ctor(System.Double[],System.Double)">
            <summary>
            Constructs an neural net kernel from vector of log lweight variances
            </summary>
            <param name="logWeightVariances">Log weight variances</param>
            <param name="logBiasWeightVariance">Log bias weight variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.InitialiseFromData(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Initialises the parameters from data
            </summary>
            <param name="X">X data - initialises weight variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.Read(System.IO.StreamReader)">
            <summary>
            Reads the parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Rank1Pot">
            <summary>
            Rank 1 potential for a sparse GP. This low rank parameterisation
            is used for messages flowing from a SparseGP evaluation factor to
            a function variable.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.Xi">
            <summary>
            Xi
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.Yi">
            <summary>
            Yi
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.LambdaInv">
            <summary>
            Lambda inverse
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.kBx">
            <summary>
            Field for K_B_x property
            </summary>
            
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.K_B_x(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            K(B,x). This is a calculated Vector maintained
            by the class
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.pvec">
            <summary>
            Field for P property
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.P(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            p = Inv(K(B,B)) * K(B,x). This is a calculated Vector maintained
            by the class
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.kxx">
            <summary>
            Field for K_x_x property
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.K_x_x(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            k(x)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.ClearCachedValues">
            <summary>
            Flag recalculation of the calculated properties
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseGP">
            <summary>
            A Gaussian Process distribution over functions, represented by a GP prior times a set of regression likelihoods on basis points.
            The GP prior and basis point locations are stored in FixedParameters.
            The regression likelihoods are stored as a single VectorGaussian called InducingDist.
            IncludePrior=false does not include the prior in the distribution (i.e. the distribution is degenerate).
            If pointFunc != null, the distribution is a point mass.
            If InducingDist is uniform and IncludePrior is false, the distribution is uniform.
            The GP prior is assumed to be non-uniform.
            </summary>
            <remarks>
            <para>
            This distribution family comes from the paper "Sparse-posterior Gaussian Processes for general likelihoods"
            by Qi et al (2010), http://event.cwi.nl/uai2010/papers/UAI2010_0283.pdf
            </para><para>
            The state of the distribution is represented by (FixedParameters, IncludePrior, InducingDist, pointFunc).
            </para>
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.fixedParameters">
            <summary>
            Field for FixedParameters property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.InducingDist">
            <summary>
            The regression likelihoods that modify the prior.
            </summary>
            <remarks>
            If this field is changed, ClearCachedValues() must be called before accessing any other property.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.IncludePrior">
            <summary>
            Whether this sparse GP includes the prior
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.pointFunc">
            <summary>
            Use for setting point distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.alpha">
            <summary>
            Field for Alpha property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.beta">
            <summary>
            Field for Beta property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.meanB">
            <summary>
            Field for Mean_B property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.varBB">
            <summary>
            Field for Var_B_B property
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.ClearCachedValues">
            <summary>
            Function to signal recalculation of calculated parameters.
            This is called automatically if the fixed parameter
            class is swapped out, or if the kernel is changed, or
            if parameters are changed. It should also be called
            by any external program modifies the kernel or other
            fixed parameters in place
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Mean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Mean at a given point
            </summary>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Mean(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Mean at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive mean vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Variance(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive Variance at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Covariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive covariance at a given pair of points
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Covariance(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive coariance at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive covariance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Marginal(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive distribution at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Joint(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive distribution at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor(MicrosoftResearch.Infer.Distributions.SparseGPFixed)">
            <summary>
            Constructs sparse GP, given basis etc
            </summary>
            <param name="spgf">The fixed parameters</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor(MicrosoftResearch.Infer.Distributions.SparseGPFixed,System.Boolean)">
            <summary>
            
            </summary>
            <param name="spgf">Fixed parameters</param>
            <param name="includePrior">Whether this instance includes the prior</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor(MicrosoftResearch.Infer.Distributions.SparseGPFixed,System.Boolean,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.IFunction)">
            <summary>
            Constructor from full specification
            </summary>
            <param name="spgf">Fixed parameters</param>
            <param name="includePrior">Whether this instance includes the prior</param>
            <param name="InducingDist">Inducing distribution</param>
            <param name="pointFunc">If not null, set this as a point distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Uniform(MicrosoftResearch.Infer.Distributions.SparseGPFixed)">
            <summary>
            Creates a uniform sparse GP
            </summary>
            <param name="sgpf"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.PointMass(MicrosoftResearch.Infer.Distributions.SparseGPFixed,MicrosoftResearch.Infer.Distributions.IFunction)">
            <summary>
            Creates a sparse GP point mass - i.e. all the mass is at a given function
            </summary>
            <param name="sgpf"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Clone">
            <summary>
            Clone. Note that the fixed parameters and the rank1 list
            are just referenced
            </summary>
            <returns>The cloned object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetTo(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Sets one sparse GP to another. Everything is copied
            except the FixedParameters and the lsit of rank 1 potentials
            which are referenced.
            </summary>
            <param name="that">The sparse GP to copy</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToProduct(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Sets this instance to the product of two sparse GPs.
            </summary>
            <param name="a">Sparse GP</param>
            <param name="b">Sparse GP</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.op_Multiply(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Creates a new SparseGP which the product of two other SparseGPs
            </summary>
            <param name="a">First SparseGP</param>
            <param name="b">Second SparseGP</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToRatio(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP,System.Boolean)">
            <summary>
            Sets this instance to the ratio of two sparse GPs.
            </summary>
            <param name="numerator">Sparse GP</param>
            <param name="denominator">Sparse GP</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.op_Division(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Creates a new SparseGP which the ratio of two other SparseGPs
            </summary>
            <param name="numerator">numerator SparseGP</param>
            <param name="denominator">denominator SparseGP</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToPower(MicrosoftResearch.Infer.Distributions.SparseGP,System.Double)">
            <summary>
            Sets this sparse GP the the power of another sparse GP
            </summary>
            <param name="dist"></param>
            <param name="exponent"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetLogProb(MicrosoftResearch.Infer.Distributions.IFunction)">
            <summary>
            Gets the log density for a given value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.EvaluateMean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the mean function of the GP
            </summary>
            <param name="X">Input variable</param>
            <returns>Evaulated function value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToUniform">
            <summary>
            Sets to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.IsUniform">
            <summary>
            Asks the distribution whether it is uniform
            </summary>
            <returns>True or false</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.MaxDiff(System.Object)">
            <summary>
            Max difference between two sparse GPs - used for
            convergence testing
            </summary>
            <param name="thatd">That sparse GP which will be compared to this sparse GP</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetMean">
            <summary>
            Gets the mean function for the Sparse GP
            </summary>
            <returns>The mean function</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Sample">
            <summary>
            Samples from the Sparse Gaussian distribution
            This is only implemented for a 1-dimensional input space,
            and returns a simple linear spline function 
            </summary>
            <returns>Sample function</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Sample(MicrosoftResearch.Infer.Distributions.IFunction)">
            <summary>
            Samples from the Sparse Gaussian distribution
            This is only implemented for a 1-dimensional input space,
            and returns a simple linear spline function. result is ignored
            <param name="result">This argument is ignored</param>
            </summary>
            <returns>Sample function</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.SparseGP,System.Double,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Sets this SparseGP distribution to the weighted sum of two other such distributions
            </summary>
            <param name="weight1"></param>
            <param name="value1"></param>
            <param name="weight2"></param>
            <param name="value2"></param>
            <remarks>Not yet implemented</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Gets the log of the integral of the product of this SparseGP and that SparseGP
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.SparseGP,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetAverageLog(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            The expected logarithm of that distribution under this distribution
            </summary>
            <param name="that"></param>
            <returns></returns>
            <remarks>Not yet implemented</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.FixedParameters">
            <summary>
            Sets and gets the fixed sparse parameters - parameters
            which are not changed by inference
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Alpha">
            <summary>
            Alpha - along with beta, this encodes the posterior means
            and covariances of the Sparse GP
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Beta">
            <summary>
            Beta - along with alpha, this encodes the posterior means
            and covariances of the Sparse GP
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Mean_B">
            <summary>
            m(B). This is a calculated Vector maintained
            by the class
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Var_B_B">
            <summary>
            var(B, B). This is a calculated matrix maintained
            by the class
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Point">
            <summary>
            Sets or Gets a point. If not a point function,
            the get returns the mean function of the sparse GP
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.IsPointMass">
            <summary>
            Asks the distribution whether it is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.LinearSpline">
            <summary>
            Very simple 1-D linear spline class which implements IFunction.
            Assumes knots at regular positions - given by a start and increment.
            The vector of knot values defines how many knots.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.LinearSpline.Evaluate(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluate the linear spline at a given point. Only
            1-D input spaces are supported - so only the first element
            of X is considered
            </summary>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.LinearSpline.KnotStart">
            <summary>
            Knot start position
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.LinearSpline.KnotIncrem">
            <summary>
            Knot position increment
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.LinearSpline.YPoints">
            <summary>
            Y points
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Discrete">
            <summary>
            An arbitrary distribution over integers [0,D-1].
            </summary>
            <remarks>
            The distribution is represented by a normalized Vector of length D.
            In the case of a point mass, the first element is infinity and the second element holds the point location.
            The probability of value x is available as this[x] or GetLogProb(x).
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Discrete.prob">
            <summary>
            Probability of each value (when not a point mass).
            </summary>
            <remarks>
            prob.Length == D.
            prob[i] >= 0.  sum_i prob[i] = 1.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Clone">
            <summary>
            Clones this discrete distribution. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Discrete type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.MaxDiff(System.Object)">
            <summary>
            Gets the maximum difference between the parameters of this discrete and that discrete
            </summary>
            <param name="that">That discrete</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="that">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToUniform">
            <summary>
            Sets this instance to a uniform discrete (i.e. probabilities all equal)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.IsUniform">
            <summary>
            Returns whether the discrete distribution is uniform or not
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogProb(System.Int32)">
            <summary>
            Evaluates the log density at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The log density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogNormalizer">
            <summary>
            Gets the log normalizer of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Evaluate(System.Int32)">
            <summary>
            Evaluates the density at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetAverageLog(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            The log of the integral of the product of this discrete and that discrete
            </summary>
            <param name="that">That discrete distribution</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Discrete,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.ProbEqual(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            The integral of the product between this discrete and that discrete. This
            is the probability that samples from this instance and that instance are equal
            </summary>
            <param name="that">That discrete distribution</param>
            <returns>The inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetProbs">
            <summary>
            Gets the probability at each index.
            </summary>
            <returns>The vector of probabilities</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetProbs(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the probability at each index.
            </summary>
            <param name="result">When used internally, can be the same object as prob.</param>
            <returns>result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogProbs">
            <summary>
            Gets the vector of log probabilities for this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetWorkspace">
            <summary>
            Gets a Vector of size this.Dimension.
            </summary>
            <returns>A pointer to the internal probs Vector of the object.</returns>
            <remarks>
            This function is intended to be used with SetProbs, to avoid allocating a new Vector.
            The return value should not be interpreted as a probs vector, but only a workspace filled
            with unknown data that can be overwritten.  Until SetProbs is called, the distribution object 
            is invalid once this workspace is modified.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetProbs(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the probability of each index.
            </summary>
            <param name="probs">A vector of non-negative, finite numbers.  Need not sum to 1.</param>
            <remarks>
            Instead of allocating your own Vector to pass to SetProbs, you can call <see cref="M:MicrosoftResearch.Infer.Distributions.Discrete.GetWorkspace"/>,
            fill in the resulting Vector, and then pass it to SetProbs.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetTo(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Sets the parameters of this instance to the parameters of that instance
            </summary>
            <param name="value">That instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToProduct(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Sets the parameters to represent the product of two discrete distributions.
            </summary>
            <param name="a">The first discrete distribution</param>
            <param name="b">The second discrete distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.op_Multiply(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Creates a Discrete distribution which is the product of two Discrete distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting Discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.op_Division(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Creates a Discrete distribution which is the ratio of two Discrete distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>The resulting Discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToPower(MicrosoftResearch.Infer.Distributions.Discrete,System.Double)">
            <summary>
            Sets the parameters to represent the power of a discrete distributions.
            </summary>
            <param name="dist">The discrete distribution</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Discrete,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Discrete,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Sets the parameters to represent the weighted sum of two discrete distributions.
            </summary>
            <param name="dist1">The first discrete distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second discrete distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Normalize">
            <summary>
            Normalizes this distribution - i.e. sets the probabilities to sum to 1.
            This is called internally after product operations, sum operations etc.
            </summary>
            <returns>The normalizing factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Sample">
            <summary>
            Returns a sample from this discrete distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Sample(System.Int32)">
            <summary>
            Returns a sample from this discrete distribution
            </summary>
            <param name="result">This parameter is ignored and is only present to support the Sampleable interface</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Sample(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a sample from a discrete distribution with the specified probabilities
            </summary>
            <param name="probs">The parameters of the discrete distribution</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor">
            <summary>
            Parameterless constructor required for serialization 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(System.Int32)">
            <summary>
            Creates a uniform Discrete distribution, from 0 to dimension-1.
            </summary>
            <param name="dimension"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a uniform Discrete distribution with a specified sparsity, from 0 to dimension-1.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="sparsity">Sparsity</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Copy constructor
            </summary>
            <param name="that">The discrete instance to copy</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a Discrete distribution from the given probabilities.
            </summary>
            <param name="probs"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(System.Double[])">
            <summary>
            Creates a Discrete distribution from the given probabilities.
            </summary>
            <param name="probs"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.PointMass(System.Int32,System.Int32)">
            <summary>
            Creates a Discrete distribution which allows only one value.
            </summary>
            <param name="value">The allowed value.</param>
            <param name="numValues">The number of values in the domain.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Uniform(System.Int32)">
            <summary>
            Creates a uniform Discrete distribution over the values from 0 to numValues-1
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Uniform(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a uniform Discrete distribution with a specified sparsity over the values from 0 to numValues-1
            </summary>
            <param name="numValues">Number of values</param>
            <param name="sparsity">Sparsity</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.UniformInRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Discrete distribution which is uniform over values from
            start to end inclusive.
            </summary>
            <param name="numValues">Number of values</param>
            <param name="start">The first value included in the distribution</param>
            <param name="end">The last value included in the distribution</param>
            <returns>Discrete which is uniform over the specified range (and zero elsewhere).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.UniformInRanges(System.Int32,System.Int32[])">
            <summary>
            Creates a Discrete distribution which is uniform over values in
            multiple ranges specified by pairs of start and end values. These pairs
            are specified as adjacent values in an array whose length must therefore be
            even.
            </summary>
            <param name="numValues">Number of values</param>
            <param name="startEndPairs">Sequence of start and end pairs</param>
            <returns>Discrete which is uniform over the specified ranges (and zero elsewhere).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.UniformInRanges(System.Int32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Creates a Discrete distribution which is uniform over values in
            multiple ranges specified by pairs of start and end values. These pairs
            are specified as adjacent values in an enumerable whose length must therefore be
            even.
            </summary>
            <param name="numValues">Number of values</param>
            <param name="startEndPairs">Sequence of start and end pairs</param>
            <returns>Discrete which is uniform over the specified ranges (and zero elsewhere).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.ToString">
            <summary>
            Override of ToString method
            </summary>
            <returns>String representation of this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetMean">
            <summary>
            Gets the mean of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetMedian">
            <summary>
            Gets the median of the distribution
            </summary>
            <returns>The median</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetMode">
            <summary>
            Gets the mode of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetVariance">
            <summary>
            Gets the variance of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.Dimension">
            <summary>
            Gets the dimension of this discrete distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.Sparsity">
            <summary>
            Gets the <see cref="P:MicrosoftResearch.Infer.Distributions.Discrete.Sparsity"/> specification of this Distribution.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.Point">
            <summary>
            Sets/gets this distribution as a point distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.IsPointMass">
            <summary>
            Indicates whether or not this instance is a point mass.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.Item(System.Int32)">
            <summary>
            Gets or sets the probability at the given index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.SparseElement`1">
            <summary>
            Stores a value and its index in the sparse vector
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Collections.SparseElement`1.NoElement">
            <summary>
            No element - returned if request for a sparse element cannot be met
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseElement`1.#ctor(System.Int32,`0)">
            <summary>
            A sparse element
            </summary>
            <param name="index">The 0-based index of the element</param>
            <param name="value">The value of the element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseElement`1.Equals(System.Object)">
            <summary>
            Tests whether this element equals the supplied object.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseElement`1.GetHashCode">
            <summary>
            Computes the hash code of this element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseElement`1.CompareTo(System.Object)">
            <summary>
            Compares this object to another object
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseElement`1.ToString">
            <summary>
            ToString override
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseElement`1.Index">
            <summary>
            The index of this element
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseElement`1.Value">
            <summary>
            The value of this element
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ISparseEnumerator`1">
            <summary>
            Contract for sparse enumeration
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ISparseEnumerator`1.CurrentIndex">
            <summary>
            Current index. If past end of list, current index shows count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ISparseEnumerator`1.CommonValueCount">
            <summary>
            Current common value count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ISparseEnumerator`1.CommonValue">
            <summary>
            The common value for the sparse enumeration
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.SparseListEnumerator`1">
            <summary>
            Iterator class for sparse lists
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1">
            <summary>
            Iterator base class for sparse enumeration
            </summary>
            <typeparam name="TRes"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.CurrentIndex">
            <summary>
            Returns the index of the current sparse element
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.CommonValueCount">
            <summary>
            Returns the count of common values up to this point. Once <see cref="M:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.MoveNext"/> returns
            false, this property gives the total common value count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.CommonValue">
            <summary>
            Gets the common value for this sparse collection
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.SparseEnumeratorBase`1.Current">
            <summary>
            Gets the current element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The enumerator is
            positioned before the first or after the last element of the collection.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseListEnumerator`1.#ctor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Collections.SparseElement{`0}},System.Int32,`0)">
            <summary>
            Constructs a sparse enumerator instance for a sparse list
            </summary>
            <param name="sparseList"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseListEnumerator`1.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SparseListEnumerator`1.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FastSumOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Sum(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogAverageFactor(System.Double,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'sum'.</param>
            <param name="array">Constant value for 'array'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sum,array))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogEvidenceRatio(System.Double,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'sum'.</param>
            <param name="array">Constant value for 'array'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sum,array))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.AverageLogFactor(System.Double,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sum">Constant value for 'sum'.</param>
            <param name="array">Constant value for 'array'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sum,array))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_sum">Outgoing message to 'sum'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sum) p(sum) factor(sum,array))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogAverageFactor(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'sum'.</param>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(array) p(array) factor(sum,array))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Incoming message from 'sum'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sum) p(sum) factor(sum,array) / sum_sum p(sum) messageTo(sum))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogEvidenceRatio(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'sum'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(array) p(array) factor(sum,array))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.SumAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            EP message to 'sum'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sum' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sum' as the random arguments are varied.
            The formula is <c>proj[p(sum) sum_(array) p(array) factor(sum,array)]/p(sum)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_sum">Outgoing message to 'sum'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(sum) p(sum) factor(sum,array)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian[],MicrosoftResearch.Infer.Distributions.Gaussian[])">
            <summary>
            EP message to 'array'
            </summary>
            <param name="sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_sum">Outgoing message to 'sum'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(sum) p(sum) factor(sum,array)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageConditional``1(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="sum">Constant value for 'sum'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.SumAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            VMP message to 'sum'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sum' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sum' as the random arguments are varied.
            The formula is <c>proj[sum_(array) p(array) factor(sum,array)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageLogarithm2``1(MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="to_array">Previous outgoing message to 'array'.</param>
            <returns>The outgoing VMP message to the 'array' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'sum' integrated out.
            The formula is <c>sum_sum p(sum) factor(sum,array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageLogarithm1``1(MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="to_array">Previous outgoing message to 'array'.</param>
            <returns>The outgoing VMP message to the 'array' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'sum' integrated out.
            The formula is <c>sum_sum p(sum) factor(sum,array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageLogarithm``1(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="sum">Constant value for 'sum'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sum,array))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BouchardSoftmaxOp_Sparse">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            This implementation uses the simple first order Taylor series expansion from Blei et al. 06, followed by
            optimization using LBFGS. This approach is linear in the dimension K. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BouchardSoftmaxOp_Sparse.AInit">
            <summary>
            Initialise the buffer 'A'
            </summary>
            <returns>Initial value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BouchardSoftmaxOp_Sparse.A``1(``0,System.Double)">
            <summary>
            Update the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>New value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BouchardSoftmaxOp_Sparse.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BouchardSoftmaxOp_Sparse.SoftmaxAverageLogarithm``1(``0,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'softmax'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'softmax' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BouchardSoftmaxOp_Sparse.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,``0,System.Double,``0)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="softmax"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BouchardSoftmaxOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            This implementation uses the simple first order Taylor series expansion from Blei et al. 06, followed by
            optimization using LBFGS. This approach is linear in the dimension K. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BouchardSoftmaxOp.AInit">
            <summary>
            Initialise the buffer 'A'
            </summary>
            <returns>Initial value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BouchardSoftmaxOp.A``1(``0,System.Double)">
            <summary>
            Update the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>New value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BouchardSoftmaxOp.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BouchardSoftmaxOp.SoftmaxAverageLogarithm``1(``0,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'softmax'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'softmax' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BouchardSoftmaxOp.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,``0,System.Double,``0)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="softmax"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            This implementation uses the simple first order Taylor series expansion from Blei and Lafferty (2006), followed by
            optimization using LBFGS. This approach is linear in the dimension K. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.GetMeanAndVariance(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Double[]@,System.Double[]@)">
            <summary>
            Helper function to get the means and variances of a list of Gaussians
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.GetMeanAndVariance(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Helper function to get the means and variances of a list of Gaussians
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.LogSumExpMPlusHalfV(System.Double[],System.Double[])">
            <summary>
            Helper function to calculation log sum_k exp(m_k+v_k/2), which is an upper bound
            on E[log sum_k exp(x_k)] when x_k ~ N(m_k,v_k)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.GradientAndValueAtPoint(System.Double[],System.Double[],MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Function to evaluate this factor's KL divergence contribution, and gradient (if grad is not null). 
            </summary>
            <param name="mu">Prior means</param>
            <param name="s2">Prior variances</param>
            <param name="x">x[1..K]: posterior mean, x[K+1..2K]: posterior log variance</param>
            <param name="ns">Dirichlet counts-1</param>
            <param name="grad">Vector to store the gradient in</param>
            <returns>KL divergence</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.SoftmaxAverageLogarithm``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'softmax'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'softmax' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06_LBFGS.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="softmax"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            This implementation uses the bound from Knowles and Minka (2011), followed by 
            nonconjugate VMP. This approach is linear in the dimension K. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.AInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Initialise the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <returns>Initial value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.A(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Update the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>New value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.SoftmaxAverageLogarithm``1(``0,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'softmax'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'softmax' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_x">Previous outgoing message to 'x'.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>The outgoing VMP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="softmax"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.AdaptiveSoftmaxOp_NCVMP_Sparse">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            This implementation uses a generalisation of the tilted bound used in Saul Jordan 1999, followed by 
            nonconjugate VMP. This approach is linear in the dimension K. 
            
            This will replace SaulJordanSoftmaxOp_NCVMP once the functionality is confirmed to be equivalent. 
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            This implementation uses the bound in Knowles and Minka (2011), followed by 
            nonconjugate VMP. This approach is linear in the dimension K. 
            
            This will replace SaulJordanSoftmaxOp_NCVMP once the functionality is confirmed to be equivalent. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse.AInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Initialise the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <returns>Initial value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse.A(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Collections.Generic.IList{System.Double})">
            <summary>
            Update the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>New value of buffer 'A'</returns>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse.SoftmaxAverageLogarithm``1(``0,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'softmax'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'softmax' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse.AverageLogFactor``1(``0,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_Sparse.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,``0,``0,System.Collections.Generic.IList{System.Double})">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_x">Previous outgoing message to 'x'.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>The outgoing VMP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="softmax"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            This implementation uses the simple first order Taylor series expansion from Blei and Lafferty (2006), followed by
            optimization using LBFGS. This approach is linear in the dimension K. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06.SoftmaxAverageLogarithm``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'softmax'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'softmax' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_BL06.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,``0,``0)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_x">Previous outgoing message to 'x'.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>The outgoing VMP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="softmax"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11">
            <summary>
            Provides outgoing messages for the vector version of <see cref="!:MMath.Softmax(Vector)"/>, given random arguments to the function.
            This implementation uses the bound in Knowles and Minka (2011), followed by 
            nonconjugate VMP. This approach is linear in the dimension K. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(softmax,x))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11.AInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <returns>Initial value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11.A(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Update the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>New value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11.SoftmaxAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'softmax'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'softmax' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorSoftmaxOp_KM11.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_x">Previous outgoing message to 'x'.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>The outgoing VMP message to the 'x' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="softmax"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            This implementation uses the bound in Knowles and Minka (2011), followed by 
            optimization using LBFGS. This approach is linear in the dimension K. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.GradientAndValueAtPoint(System.Double[],System.Double[],MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Function to evaluate this factor's KL divergence contribution, and gradient (if grad is not null). 
            </summary>
            <param name="mu">Prior means</param>
            <param name="s2">Prior variances</param>
            <param name="a">Variational parameter vector a</param>
            <param name="x">x[1..K]: posterior mean, x[K+1..2K]: posterior log variance</param>
            <param name="ns">Dirichlet counts-1</param>
            <param name="grad">Vector to store the gradient in</param>
            <returns>KL divergence</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.SoftmaxAverageLogarithm``1(``0,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'softmax'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'softmax' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.AInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Initialise the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <returns>Initial value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.A(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Update the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>New value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Maths.Vector,``0)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="softmax"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            This implementation uses the bound in Knowles and Minka (2011), followed by 
            optimization using LBFGS. This approach is linear in the dimension K. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse.AverageLogFactor``1(``0,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse.GradientAndValueAtPoint(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector[])">
            <summary>
            Function to evaluate this factor's KL divergence contribution, and gradient (if grad is not null). 
            </summary>
            <param name="mu">Prior means</param>
            <param name="s2">Prior variances</param>
            <param name="a">Variational parameter vector a</param>
            <param name="x">x[1..K]: posterior mean, x[K+1..2K]: posterior log variance</param>
            <param name="ns">Dirichlet counts-1</param>
            <param name="grad">Vector to store the gradient in</param>
            <returns>KL divergence</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse.SoftmaxAverageLogarithm``1(``0,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'softmax'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'softmax' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse.AInit(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Initialise the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <returns>Initial value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse.A(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Collections.Generic.IList{System.Double})">
            <summary>
            Update the buffer 'A'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <returns>New value of buffer 'A'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_KM11_LBFGS_Sparse.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},System.Collections.Generic.IList{System.Double},``0)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="a">Buffer 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="softmax"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaSoftmaxOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            Here the marginal prototype for logOdds is Gamma, which allows for heavier tailed distributions. 
            This implementation uses the Taylor series bound from Blei 06, followed by 
            optimization using LBFGS. This approach is linear in the dimension K. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaSoftmaxOp.GetShapeAndRate(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gamma},System.Double[]@,System.Double[]@)">
            <summary>
            Helper function to get the means and variances of a list of Gaussians
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaSoftmaxOp.GetMeanLog(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gamma})">
            <summary>
            
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <returns></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaSoftmaxOp.SoftmaxAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gamma})">
            <summary>
            VMP message to 'softmax'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'softmax' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'softmax' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaSoftmaxOp.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,``0,``0)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="softmax"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SoftmaxOp_ProductOfLogistics">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            This implementation uses the bound
            <c>exp(x[k])/sum_i exp(x[i]) &gt;= prod_{i!=k} sigma(x[k]-x[i])</c>
            noted by Tom Minka. This approach is quadratic in the dimension K. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_ProductOfLogistics.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(softmax,x))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_ProductOfLogistics.SoftmaxAverageLogarithm``1(``0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'softmax'
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'softmax' as the random arguments are varied.
            The formula is <c>proj[sum_(x) p(x) factor(softmax,x)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_ProductOfLogistics.XAverageLogarithm``1(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SoftmaxOp_ProductOfLogistics.XAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Dirichlet,``0,``0)">
            <summary>
            VMP message to 'x'
            </summary>
            <param name="softmax">Incoming message from 'softmax'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'x' with 'softmax' integrated out.
            The formula is <c>sum_softmax p(softmax) factor(softmax,x)</c>.
            </para>
            <para>The bound used below is exp(x[k])/sum_i exp(x[i]) &gt;= prod_{i!=k} sigma(x[k]-x[i]).
            If UseBlei06Bound is set to true the bound E[log sum_i exp(x)] &lt;= log E[sum_i exp(x)]
            is used instead, followed by numerical optimisation using the LBFGS algorithm. </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="softmax"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.MatrixMultiply(System.Double[0:,0:],System.Double[0:,0:])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(matrixMultiply,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionArray2D{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.DistributionArray2D{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'matrixMultiply'
            </summary>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'matrixMultiply' as the random arguments are varied.
            The formula is <c>proj[sum_(A,B) p(A,B) factor(matrixMultiply,A,B)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageLogarithm(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'matrixMultiply'
            </summary>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'matrixMultiply' as the random arguments are varied.
            The formula is <c>proj[sum_(B) p(B) factor(matrixMultiply,A,B)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'matrixMultiply'
            </summary>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'matrixMultiply' as the random arguments are varied.
            The formula is <c>proj[sum_(A) p(A) factor(matrixMultiply,A,B)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_A">Previous outgoing message to 'A'.</param>
            <returns>The outgoing VMP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'A'.
            Because the factor is deterministic, 'matrixMultiply' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(B) p(B) log(sum_matrixMultiply p(matrixMultiply) factor(matrixMultiply,A,B)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="matrixMultiply"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'B'.</param>
            <param name="to_A">Previous outgoing message to 'A'.</param>
            <returns>The outgoing VMP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'A' with 'matrixMultiply' integrated out.
            The formula is <c>sum_matrixMultiply p(matrixMultiply) factor(matrixMultiply,A,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="matrixMultiply"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_B">Previous outgoing message to 'B'.</param>
            <returns>The outgoing VMP message to the 'B' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'B'.
            Because the factor is deterministic, 'matrixMultiply' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(A) p(A) log(sum_matrixMultiply p(matrixMultiply) factor(matrixMultiply,A,B)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="matrixMultiply"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_B">Previous outgoing message to 'B'.</param>
            <returns>The outgoing VMP message to the 'B' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'B' with 'matrixMultiply' integrated out.
            The formula is <c>sum_matrixMultiply p(matrixMultiply) factor(matrixMultiply,A,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="matrixMultiply"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageLogarithm(System.Double[0:,0:])">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <returns>The outgoing VMP message to the 'A' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'A' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageLogarithm(System.Double[0:,0:])">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <returns>The outgoing VMP message to the 'B' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'B' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'matrixMultiply'
            </summary>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'matrixMultiply' as the random arguments are varied.
            The formula is <c>proj[p(matrixMultiply) sum_(A,B) p(A,B) factor(matrixMultiply,A,B)]/p(matrixMultiply)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'A'
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'A' as the random arguments are varied.
            The formula is <c>proj[p(A) sum_(matrixMultiply,B) p(matrixMultiply,B) factor(matrixMultiply,A,B)]/p(A)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'B'
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'.</param>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'B' as the random arguments are varied.
            The formula is <c>proj[p(B) sum_(matrixMultiply,A) p(matrixMultiply,A) factor(matrixMultiply,A,B)]/p(B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(matrixMultiply,B) p(matrixMultiply,B) factor(matrixMultiply,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(System.Double[0:,0:],System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(B) p(B) factor(matrixMultiply,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:])">
            <summary>
            Evidence message for EP
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(matrixMultiply,A) p(matrixMultiply,A) factor(matrixMultiply,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:])">
            <summary>
            Evidence message for EP
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(A) p(A) factor(matrixMultiply,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(matrixMultiply,B) p(matrixMultiply,B) factor(matrixMultiply,A,B) / sum_matrixMultiply p(matrixMultiply) messageTo(matrixMultiply))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:])">
            <summary>
            Evidence message for EP
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(matrixMultiply,A) p(matrixMultiply,A) factor(matrixMultiply,A,B) / sum_matrixMultiply p(matrixMultiply) messageTo(matrixMultiply))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(System.Double[0:,0:],System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(B) p(B) factor(matrixMultiply,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:])">
            <summary>
            Evidence message for EP
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(A) p(A) factor(matrixMultiply,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageConditional(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'matrixMultiply'
            </summary>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'matrixMultiply' as the random arguments are varied.
            The formula is <c>proj[p(matrixMultiply) sum_(B) p(B) factor(matrixMultiply,A,B)]/p(matrixMultiply)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'matrixMultiply'
            </summary>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'matrixMultiply' as the random arguments are varied.
            The formula is <c>proj[p(matrixMultiply) sum_(A) p(A) factor(matrixMultiply,A,B)]/p(matrixMultiply)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'A'
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'A' as the random arguments are varied.
            The formula is <c>proj[p(A) sum_(matrixMultiply) p(matrixMultiply) factor(matrixMultiply,A,B)]/p(A)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="matrixMultiply"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'B'
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'B' as the random arguments are varied.
            The formula is <c>proj[p(B) sum_(matrixMultiply) p(matrixMultiply) factor(matrixMultiply,A,B)]/p(B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="matrixMultiply"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageConditional(System.Double[0:,0:],System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'A'
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <param name="B">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'A' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageConditional(System.Double[0:,0:],System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'B'
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'B' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GetItemsOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GetItems``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})"/>, given random arguments to the function.
            This factor gets a sub-array of (possibly duplicated) items from an array of items
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogAverageFactor(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Constant value for 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items) p(items) factor(items,array,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogAverageFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogAverageFactor``1(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogAverageFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Constant value for 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items) p(items) factor(items,array,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.AverageLogFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(items,array,indices))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{``0})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="items">Incoming message from 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(items) p(items) factor(items,array,indices)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="items">Incoming message from 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(items) p(items) factor(items,array,indices)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ItemsAverageLogarithm``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            VMP message to 'items'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'items' as the random arguments are varied.
            The formula is <c>proj[sum_(array) p(array) factor(items,array,indices)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ArrayAverageLogarithm``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="items">Incoming message from 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'items' integrated out.
            The formula is <c>sum_items p(items) factor(items,array,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ArrayAverageLogarithm``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'items' integrated out.
            The formula is <c>sum_items p(items) factor(items,array,indices)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp2`1.ItemsAverageConditional2``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            EP message to 'items'
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'items' as the random arguments are varied.
            The formula is <c>proj[p(items) sum_(array) p(array) factor(items,array,indices)]/p(items)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp2`1.ItemsAverageConditional``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},System.Int32,``0)">
            <summary>
            EP message to 'items'
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'items' as the random arguments are varied.
            The formula is <c>proj[p(items) sum_(array) p(array) factor(items,array,indices)]/p(items)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ProductWishartOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'product'
            </summary>
            <param name="B">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[sum_(a,b) p(a,b) factor(product,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'product'
            </summary>
            <param name="B">Constant value for 'a'.</param>
            <param name="A">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[sum_(b) p(b) factor(product,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            Because the factor is deterministic, 'product' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(b) p(b) log(sum_product p(product) factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.BAverageLogarithm(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' with 'product' integrated out.
            The formula is <c>sum_product p(product) factor(product,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductWishartOp.AAverageLogarithm(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogAverageFactor``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32[]})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Constant value for 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items) p(items) factor(items,array,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogAverageFactor``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32[]})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogAverageFactor``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1},System.Collections.Generic.IList{System.Int32[]})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogEvidenceRatio``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``1},System.Collections.Generic.IList{System.Int32[]})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogAverageFactor``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32[]})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Constant value for 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items) p(items) factor(items,array,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.LogEvidenceRatio``3(``1,System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32[]},``1)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(items,array) p(items,array) factor(items,array,indices) / sum_items p(items) messageTo(items))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.ItemsAverageLogarithm``3(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32[]},``2)">
            <summary>
            VMP message to 'items'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'items' as the random arguments are varied.
            The formula is <c>proj[sum_(array) p(array) factor(items,array,indices)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.ArrayAverageLogarithm``3(System.Collections.Generic.IList{``2},System.Collections.Generic.IList{System.Int32[]},``1)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="items">Incoming message from 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'items' integrated out.
            The formula is <c>sum_items p(items) factor(items,array,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.JaggedSubarrayOp`1.ArrayAverageLogarithm``3(System.Collections.Generic.IList{System.Int32[]},System.Collections.Generic.IList{``2},``1)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'items' integrated out.
            The formula is <c>sum_items p(items) factor(items,array,indices)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.ArrayFromVector(MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.LogAverageFactor(System.Double[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="array">Constant value for 'array'.</param>
            <param name="vector">Constant value for 'vector'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_() p() factor(array,vector))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.LogEvidenceRatio(System.Double[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="array">Constant value for 'array'.</param>
            <param name="vector">Constant value for 'vector'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(array,vector))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.AverageLogFactor(System.Double[],MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="array">Constant value for 'array'.</param>
            <param name="vector">Constant value for 'vector'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.LogAverageFactor(System.Double[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="array">Constant value for 'array'.</param>
            <param name="vector">Incoming message from 'vector'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(vector) p(vector) factor(array,vector))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.LogEvidenceRatio(System.Double[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="array">Constant value for 'array'.</param>
            <param name="vector">Incoming message from 'vector'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(vector) p(vector) factor(array,vector))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.LogAverageFactor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="array">Incoming message from 'array'.</param>
            <param name="vector">Incoming message from 'vector'.</param>
            <param name="to_vector">Outgoing message to 'vector'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(array,vector) p(array,vector) factor(array,vector))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="array">Incoming message from 'array'.</param>
            <param name="vector">Incoming message from 'vector'.</param>
            <param name="to_vector">Outgoing message to 'vector'.</param>
            <param name="to_array">Outgoing message to 'array'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(array,vector) p(array,vector) factor(array,vector) / sum_array p(array) messageTo(array))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.AverageLogFactor(System.Double[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="array">Constant value for 'array'.</param>
            <param name="vector">Incoming message from 'vector'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.AverageLogFactor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="array">Incoming message from 'array'.</param>
            <param name="vector">Incoming message from 'vector'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            </para></remarks>	
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.AverageLogFactor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="array">Incoming message from 'array'.</param>
            <param name="vector">Constant value for 'vector'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            </para></remarks>	
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.VectorAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'vector'.
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'vector' as the random arguments are varied.
            The formula is <c>proj[p(vector) sum_(array) p(array) factor(array,vector)]/p(vector)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.VectorAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'vector'.
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'vector' with 'array' integrated out.
            The formula is <c>sum_array p(array) factor(array,vector)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.VectorAverageConditional(System.Double[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'vector'.
            </summary>
            <param name="array">Constant value for 'array'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'vector' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.VectorAverageLogarithm(System.Double[],MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'vector'.
            </summary>
            <param name="array">Constant value for 'array'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'vector' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.ArrayAverageConditional``1(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,``0)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="array">Incoming message from 'array'.</param>
            <param name="vector">Incoming message from 'vector'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_vector">Outgoing message to 'vector'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(vector) p(vector) factor(array,vector)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="vector"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ArrayFromVectorOp.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.VectorGaussian,``0)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="vector">Incoming message from 'vector'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[sum_(vector) p(vector) factor(array,vector)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="vector"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Wishart">
            <summary>
            A Wishart distribution on positive definite matrices.
            </summary>
            <remarks><para>
             In the matrix case, the distribution is
              <c>p(X) = |X|^(a-(d+1)/2)*exp(-tr(X*B))*|B|^a/Gamma_d(a)</c>.
            In this code, the <c>a</c> parameter is called the "Shape" and the <c>B</c> parameter
            is called the "Rate".  The
            mean of the distribution is <c>a/B</c> and the diagonal variance is 
            <c>var(X_ii) = a*C_ii^2</c> where <c>C=inv(B)</c>.  The non-diagonal variances are
            <c>var(X_ij) = a*0.5*(C_ij^2 + C_ii*C_jj)</c> where <c>C=inv(B)</c>.
            </para><para>
            The distribution is represented by a one-dimensional Vector for <c>a</c> and 
            a PositiveDefiniteMatrix for <c>B</c>.  Because both are Cursors, any Wishart instance
            can be used as a cursor.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetMean">
            <summary>
            Gets the mean of the distribution.
            </summary>
            <returns>A new PositiveDefiniteMatrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetScale">
            <summary>
            Gets the scale matrix
            </summary>
            <returns>A new PositiveDefiniteMatrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetMean(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the mean of the distribution.
            </summary>
            <param name="mean">Where to put the mean matrix</param>
            <returns>The mean matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetVariance">
            <summary>
            Gets the variance of the distribution
            </summary>
            <returns>The variance matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetVariance(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the variance of the distribution
            </summary>
            <param name="variance">Where to put the variance</param>
            <returns>The variance matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetMeanAndVariance(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the mean and variance matrices.
            </summary>
            <param name="mean">Where to put the mean - assumed to be of the correct size</param>
            <param name="variance">Where to put the variance - assumed to be of the correct size</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetMeanAndVariance(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the parameters to produce a given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <remarks>
            The mean is always matched, but the variance may not match exactly, since the distribution
            has only one scalar parameter for variance.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetShapeAndScale(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the shape parameter and the scale matrix parameter for this instance
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the shape parameter and the rate matrix parameter for this instance
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="rate">The rate matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetMeanLogDeterminant">
            <summary>
            Gets the mean log determinant
            </summary>
            <returns>The mean log determinant</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing rate matrix
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToUniform">
            <summary>
            Sets this instance to have uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.IsProper">
            <summary>
            Asks whether this instance is proper
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.IsProper(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Asks whether a Wishart distribution of the specified shape and rate is proper
            </summary>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate matrix</param>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogProb(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evaluates the logarithm of a Wishart density function at a given point
            </summary>
            <param name="x">Where to evaluate the density</param>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate matrix</param>
            <returns>The log density</returns>
            <remarks>
            The distribution is <c>p(X) = |X|^(a-(d+1)/2)*exp(-tr(X*B))*|B|^a/Gamma_d(a)</c>.
            When a &lt;= (d-1)/2 the <c>Gamma_d(a)</c> term is dropped.
            When B &lt;= 0 the <c>|B|^a</c> term is dropped.
            Thus if shape = (d+1)/2 and rate = 0 the density is 1.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogProb(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evaluates the logarithm of this Wishart density function at a given point
            </summary>
            <param name="X">Where to evaluate the density</param>
            <returns>The log density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogNormalizer(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the normalizer for a Wishart density function specified by shape and rate matrix
            </summary>
            <param name="shape">Shape parameter</param>
            <param name="rate">rate matrix</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogNormalizer">
            <summary>
            Gets the normalizer for the density function of this Wishart distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetAverageLog(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Gets the log-integral of the product of this Wishart with another Wishart
            </summary>
            <param name="that">The other Wishart</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Wishart,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Sample(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Samples this Wishart distribution
            </summary>
            <param name="result">Where to put the sample</param>
            <param name="cholB">A workspace matrix of the same dimension as the distribution</param>
            <param name="cholX">A workspace matrix of the same dimension as the distribution</param>
            <param name="cholXt">A workspace matrix of the same dimension as the distribution</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Sample(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples this Wishart distribution. Workspaces are allocated behind the scenes
            </summary>
            <param name="result">Where to put the sample</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Sample">
            <summary>
            Samples this Wishart distribution. Workspaces and sample matrix are allocated
            behind the scenes
            </summary>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Sample(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples a Wishart distribution of specified shape and rate.
            Workspaces are allocated behind the scenes
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
            <param name="result">Where to put the sample</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SampleFromShapeAndScale(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples a Wishart distribution of specified shape and scale.
            Workspaces are allocated behind the scenes
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SampleFromShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples a Wishart distribution of specified shape and rate.
            Workspaces are allocated behind the scenes
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SampleFromShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples a Wishart distribution of specified shape and rate.
            Workspaces are allocated behind the scenes
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="rate">The rate matrix</param>
            <param name="result">Receives the sample</param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetTo(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Sets this Wishart instance to have the parameter values of another Wishart instance
            </summary>
            <param name="that">The other Wishart</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToProduct(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Sets the parameters to represent the product of two Wisharts.
            </summary>
            <param name="g1">The first Wishart. May refer to <c>this</c>.</param>
            <param name="g2">The second Wishart. May refer to <c>this</c>.</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.op_Multiply(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Creates a new Wishart which the product of two other Wisharts
            </summary>
            <param name="a">First Wishart</param>
            <param name="b">Second Wishart</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToRatio(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two Wisharts.
            </summary>
            <param name="numerator">The numerator Wishart</param>
            <param name="denominator">The denominator Wishart</param>
            <param name="forceProper">If true, the result shape >= (dimension+1)/2 and rate is non-negative definite</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.op_Division(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Creates a new Wishart which is the ratio of two other Wishart
            </summary>
            <param name="numerator">numerator Wishart</param>
            <param name="denominator">denominator Wishart</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToPower(MicrosoftResearch.Infer.Distributions.Wishart,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source Wishart to some exponent.
            </summary>
            <param name="dist">The source Wishart</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Wishart,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Weighted mixture distribution for two Wisharts
            </summary>
            <param name="weight1">First weight</param>
            <param name="dist1">First Wishart</param>
            <param name="weight2">Second weight</param>
            <param name="dist2">Second Wishart</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.WeightedSum``1(``0,System.Int32,System.Double,``0,System.Double,``0)">
            <summary>
            Creates a weighted mixture distribution for distributions whose mean and variance are both
            of type PositiveDefiniteMatrix. The distribution type must implement <see cref="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVariance`2"/> and
            <see cref="T:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2"/>
            </summary>
            <typeparam name="T">Distribution type for the mixture</typeparam>
            <param name="dimension">The dimension of the domain</param>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second distribution</param>
            <param name="result">Resulting distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Wishart
            and that Wishart
            </summary>
            <param name="thatd">That Wishart</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Clone">
            <summary>
            Clones this Wishart. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Wishart type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor(System.Int32)">
            <summary>
            Constructs a uniform Wishart distribution of the given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Uniform(System.Int32)">
            <summary>
            Constructs a uniform Wishart distribution of the given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor(System.Double,System.Double)">
            <summary>
            Creates a one-dimensional Wishart with given shape and scale
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The one-dimesional scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor(System.Int32,System.Double,System.Double)">
            <summary>
            Constructs a multi-dimensional Wishart with given shape and with
            a scale matrix which is set to a scaled identity matrix
            </summary>
            <param name="dimension">The dimension</param>
            <param name="shape">The shape parameter</param>
            <param name="scale">Used to scale the identity matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Constructs a multi-dimensional Wishart with given shape and scale matrix
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromShapeAndScale(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a new multi-dimensional Wishart with given shape and scale matrix
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
            <returns>A new Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromShapeAndScale(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a multi-dimensional Wishart with given shape and with
            a scale matrix which is set to a scaled identity matrix
            </summary>
            <param name="dimension">The dimension</param>
            <param name="shape">The shape parameter</param>
            <param name="scale">Used to scale the identity matrix</param>
            <returns>A new Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a multi-dimensional Wishart with given shape and rate matrix
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="rate">The rate matrix</param>
            <returns>A new Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromShapeAndRate(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a multi-dimensional Wishart with given shape and with
            a rate matrix which is set to a scaled identity matrix
            </summary>
            <param name="dimension">The dimension</param>
            <param name="shape">The shape parameter</param>
            <param name="rate">Used to scale the identity matrix</param>
            <returns>A new Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromMeanAndMeanLogDeterminant(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Constructs a Wishart distribution with the given mean and mean log determinant.
            </summary>
            <param name="mean">Desired expected value.</param>
            <param name="meanLogDet">Desired expected log determinant.</param>
            <returns>A new Wishart distribution.</returns>
            <remarks>This function is equivalent to maximum-likelihood estimation of a Wishart distribution
            from data given by sufficient statistics.
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization. The algorithm is a generalized Newton iteration, 
            described in "Estimating a Gamma distribution" by T. Minka, 2002.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.PointMass(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a Wishart point mass at the specified location
            </summary>
            <param name="mean">The location of the point-mass</param>
            <returns>A new point mass Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.PointMass(System.Double)">
            <summary>
            Creates a Wishart point mass at the specified location
            </summary>
            <param name="mean">The location of the point-mass is a vector where every element equals this value</param>
            <returns>A new point mass Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Rate">
            <summary>
            Sets/gets the rate matrix
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Shape">
            <summary>
            Sets/gets the shape value
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Point">
            <summary>
            Sets/gets this instance as a point-mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Dimension">
            <summary>
            Dimension of this distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.SourceArray">
            <summary>
            Gets/sets the source array for the Wishart parameters. These are stored
            contiguously in the SourceArray as Rate matrix followed by shape
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator">
            <summary>
            Estimates a Gaussian distribution from samples.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new VectorGaussian estimator of a given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Add(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Adds a VectorGaussian distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Add(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double)">
            <summary>
            Adds a weighted VectorGaussian distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
            <param name="weight">The weight of the distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Add(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Adds a sample item to the estimator
            </summary>
            <param name="sample">The sample value to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Add(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Add a sample item with a given weight to the estimator
            </summary>
            <param name="sample">The sample value to add</param>
            <param name="weight">The weight of the sample</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Computes the maximum-likelihood Gaussian from the samples.
            </summary>
            <param name="result">May be null.</param>
            <returns>If result is not null, modifies and returns result.  
            Otherwise returns a new Gaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.SetTo(MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Dimension">
            <summary>
            Dimension of the VectorGaussian
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator">
            <summary>
            Class for accumulating weighted noisy matrix observations,
            and computing sample count, mean matrix, and covariance matrix
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Mean">
            <summary>
            Mean matrix
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Variance">
            <summary>
            Covariance matrix
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Count">
            <summary>
            Count
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.diff">
            <summary>
            Temporary workspace
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Adds an observation
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Matrix,System.Double)">
            <summary>
            Adds a weighted observation
            </summary>
            <param name="x"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Adds a noisy observation.
            </summary>
            <param name="x"></param>
            <param name="noiseVariance"></param>
            <param name="weight"></param>
            <remarks>The contents of noiseVariance are modified.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an accumulator for matrix observations
            </summary>
            <param name="rows"></param>
            <param name="cols"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.SetTo(MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Rows">
            <summary>
            The number of rows in the matrix
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Cols">
            <summary>
            The number of columns in the matrix
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential">
            <summary>
            Squared Exponential kernel function: k(x,y) = exp(-0.5*(x-y)^2/exp(2*logLength))
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.#ctor(System.Double,System.Double)">
            <summary>
            Constructs the kernel k(x,y) = exp(2*logSignalSD - 0.5*(x-y)^2/exp(2*logLength))
            </summary>
            <param name="logLengthScale">Log length</param>
            <param name="logSignalSD">Log signal variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.#ctor(System.Double)">
            <summary>
            Constructs the kernel k(x,y) = exp(- 0.5*(x-y)^2/exp(2*logLength))
            </summary>
            <param name="logLengthScale"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.#ctor">
            <summary>
            Constructs the kernel k(x,y) = exp(- 0.5*(x-y)^2)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.LogLengthScale">
            <summary>
            Sets/gets log of the length scale
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.LogSignalSD">
            <summary>
            Gets/sets log of the signal variance
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Dirichlet">
            <summary>
            A Dirichlet distribution on probability vectors.
            </summary>
            <remarks><para>
            The Dirichlet is a distribution on probability vectors.
            The formula for the distribution is p(x) = (Gamma(a)/prod_i Gamma(b_i)) prod_i x_i^{b_i-1}
            subject to the constraints x_i &gt;= 0 and sum_i x_i = 1.
            The parameter a is the "total pseudo-count" and is shorthand for sum_i b_i.
            The vector b contains the pseudo-counts for each case i. The vector b can be sparse
            or dense; in many cases it is useful to give it a <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/> specification of
            <see cref="M:MicrosoftResearch.Infer.Maths.Sparsity.ApproximateWithTolerance(System.Double)"/>.
            </para><para>
            The distribution is represented by the pair (TotalCount, PseudoCount).
            If TotalCount is infinity, the distribution is a point mass.  The Point property gives the mean.
            Otherwise TotalCount is always equal to PseudoCount.Sum().
            If distribution is uniform when all PseudoCounts = 1.
            If any PseudoCount &lt;= 0, the distribution is improper.
            In this case, the density is redefined to not include the Gamma terms, i.e.
            there is no normalizer.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Dirichlet.TotalCount">
            <summary>
            Gets the total count. If infinite, the distribution is a point mass.
            Otherwise, this is the sum of pseudo-counts
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Dirichlet.PseudoCount">
            <summary>
            Vector of pseudo-counts
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.IsProper">
            <summary>
            Whether the the distribution is proprer or not.
            It is proper if all pseudo-counts are > 0.
            </summary>
            <returns>true if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMean">
            <summary>
            Gets the expected value E(x)
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the expected value E(x). Provide a vector to put the result
            </summary>
            <param name="result">Where to put E(x)</param>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanLog">
            <summary>
            Gets the expected log value E(log(x))
            </summary>
            <returns>E(log(x))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanLog(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the expected log value E(log(x)). Provide a vector to put the result
            </summary>
            <param name="result">Where to put E(log(x))</param>
            <returns>E(log(x))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanLogAt(System.Int32)">
            <summary>
            E[log prob[sample]]
            </summary>
            <param name="sample">a dimension of prob of interest</param>
            <returns>E[log prob[sample]]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanSquare">
            <summary>
            Computes E[p(x)^2] for each x.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanCube">
            <summary>
            Computes E[p(x)^3] for each x.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetVariance">
            <summary>
            Gets the variance var(p) = m*(1-m)/(1+s)
            </summary>
            <returns>The variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the mean E(p) = m/s and variance var(p) = m*(1-m)/(1+s)
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetMeanAndMeanSquare(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the mean, and sets the precision to best match the given mean-squares.
            </summary>
            <param name="mean">Desired mean in each dimension.  Must be in [0,1] and sum to 1.</param>
            <param name="meanSquare">Desired meanSquare in each dimension.  Must be in [0,1].</param>
            <remarks>
            The resulting distribution will have the given mean but will only approximately match
            the meanSquare, since the Dirichlet does not have enough parameters.  The moment matching
            formula comes from:
            "Expectation-Propagation for the Generative Aspect Model",
            Thomas Minka and John Lafferty,
            Proceedings of the 18th Conference on Uncertainty in Artificial Intelligence, pp. 352-359, 2002
            http://research.microsoft.com/~minka/papers/aspect/
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the mean, and sets the precision to best match the given variances.
            </summary>
            <param name="mean">Desired mean in each dimension.  Must be in [0,1] and sum to 1.</param>
            <param name="variance">Desired variance in each dimension.  Must be non-negative.</param>
            <remarks>
            The resulting distribution will have the given mean but will only approximately match
            the variance, since the Dirichlet does not have enough parameters.  The moment matching
            formula comes from:
            "Expectation-Propagation for the Generative Aspect Model",
            Thomas Minka and John Lafferty,
            Proceedings of the 18th Conference on Uncertainty in Artificial Intelligence, pp. 352-359, 2002
            http://research.microsoft.com/~minka/papers/aspect/
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.FromMeanLog(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Create a Dirichlet distribution with the given expected logarithms.
            </summary>
            <param name="meanLog">Desired expectation E[log(pk)] for each k.</param>
            <returns>A new Dirichlet where GetMeanLog == meanLog</returns>
            <remarks>
            This function is equivalent to maximum-likelihood estimation of a Dirichlet distribution
            from data given by sufficient statistics. 
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization.
            Uses the Newton algorithm described in "Estimating a Dirichlet distribution" by T. Minka, 2000.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetMeanLog(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set the Dirichlet parameters to produce the given expected logarithms.
            </summary>
            <param name="meanLog">Desired expectation E[log(pk)] for each k.</param>
            <remarks>
            This function is equivalent to maximum-likelihood estimation of a Dirichlet distribution
            from data given by sufficient statistics. 
            This function is significantly slower than the other setters since it
            involves nonlinear optimization.
            Uses the Newton algorithm described in "Estimating a Dirichlet distribution" by T. Minka, 2000.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.EstimateNewton(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Modifies PseudoCount to produce the given expected logarithms.
            </summary>
            <param name="PseudoCount">On input, the initial guess.  On output, the converged solution.</param>
            <param name="meanLog">May be -infinity.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Clone">
            <summary>
            Clones this Dirichlet. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Dirichlet type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Dirichlet
            and that Dirichlet
            </summary>
            <param name="that">That Dirichlet</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetLogProb(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the log of the Dirichlet density function at the given Vector value
            </summary>
            <param name="value">Where to do the evaluation. Must be vector of positive real numbers</param>
            <returns>log(Dir(value;a,b))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetLogNormalizer">
            <summary>
            Gets the log normalizer for the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.DirichletLn(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Computes the log Dirichlet function: <c>sum_i GammaLn(pseudoCount[i]) - GammaLn(sum_i pseudoCount[i])</c>
            </summary>
            <param name="pseudoCount">Vector of pseudo-counts.</param>
            <returns><c>sum_i GammaLn(pseudoCount[i]) - GammaLn(sum_i pseudoCount[i])</c></returns>
            <remarks>
            If any pseudoCount &lt;= 0, the result is defined to be 0.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetAverageLog(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetTo(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Sets this Dirichlet instance to have the parameter values of another Dirichlet instance
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToProduct(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Sets the parameters to represent the product of two Dirichlets.
            </summary>
            <param name="a">The first Dirichlet.  May refer to <c>this</c>.</param>
            <param name="b">The second Dirichlet.  May refer to <c>this</c>.</param>
            <remarks>
            The result may not be proper, i.e. its parameters may be negative.
            For example, if you multiply Dirichlet(0.1,0.1) by itself you get Dirichlet(-0.8, -0.8).
            No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.op_Multiply(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Creates a Dirichlet distribution which is the product of two Dirichlet distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToRatio(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two Dirichlets.
            </summary>
            <param name="numerator">The numerator Dirichlet.  Can be the same object as this.</param>
            <param name="denominator">The denominator Dirichlet.  Can be the same object as this.</param>
            <param name="forceProper">If true, the PseudoCounts of the result are made >= 1, under the constraint that denominator*result has the same mean as numerator.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.op_Division(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Creates a Dirichlet distribution which is the ratio of two Dirichlet distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>The resulting Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToPower(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Sets the parameters to represent the raising a Dirichlet to some power.
            </summary>
            <param name="dist">The Dirichlet</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Dirichlet.AllowImproperSum">
            <summary>
            If true, <see cref="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)"/> will use moment matching as described by Minka and Lafferty (2002).
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Set the parameters to match the moments of a mixture distribution.
            </summary>
            <param name="dist1">The first distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.WeightedSum``1(``0,System.Int32,System.Double,``0,System.Double,``0,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Static weighted sum method for distribution types for which both mean and variance
            can be got/set as Vectors
            </summary>
            <typeparam name="T">The distribution type</typeparam>
            <param name="result">The resulting distribution</param>
            <param name="dimension">The vector dimension</param>
            <param name="weight1">First weight</param>
            <param name="dist1">First distribution instance</param>
            <param name="weight2">Second weight</param>
            <param name="dist2">Second distribution instance</param>
            <param name="sparsity">Vector sparsity specification</param>
            <returns>Resulting distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToUniform">
            <summary>
            Sets the distribution to be uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.IsUniform">
            <summary>
            Whether this instance is uniform (i.e. has unit pseudo-counts)
            </summary>
            <returns>true if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            The log of the integral of the product of this Dirichlet and that Dirichlet
            </summary>
            <param name="that">That Dirichlet</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Sample">
            <summary>
            Samples from this Dirichlet distribution
            </summary>
            <returns>The sample Vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Sample(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Samples from this Dirichlet distribution. Provide a Vector to place the result
            </summary>
            <param name="result">Where to place the resulting sample</param>
            <returns>result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SampleFromPseudoCounts(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a Dirichlet with specified pseudo-counts
            </summary>
            <param name="pseudoCount">The pseudo-count vector</param>
            <returns>A new Vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Sample(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a Dirichlet with specified pseudo-counts
            </summary>
            <param name="pseudoCount">The pseudo-count vector</param>
            <param name="result">Where to put the result</param>
            <returns>result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor">
            <summary>
            Parameterless constructor required for serialization 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Int32)">
            <summary>
            Creates a uniform Dirichlet distribution with unit pseudo-counts.
            </summary>
            <param name="dimension">Dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a uniform Dirichlet distribution with unit pseudo-counts and a given dimension
            and <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/>.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/> specification. A specification of <see cref="M:MicrosoftResearch.Infer.Maths.Sparsity.ApproximateWithTolerance(System.Double)"/>
            is recommended for sparse problems.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Int32,System.Double)">
            <summary>
            Creates a uniform Dirichlet distribution with the specified initial pseudo-count for each index.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="initialCount">Initial value for each pseudocount</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a uniform Dirichlet distribution with the specified dimension, initial pseudo-count
            and <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/>.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="initialCount">Initial value for each pseudocount</param>
            <param name="sparsity">The <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/> specification. A specification of <see cref="M:MicrosoftResearch.Infer.Maths.Sparsity.ApproximateWithTolerance(System.Double)"/>
            is recommended for sparse problems.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a Dirichlet distribution with the specified pseudo-counts.
            The pseudo-count vector can have any <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/> specification.
            A specification of <see cref="M:MicrosoftResearch.Infer.Maths.Sparsity.ApproximateWithTolerance(System.Double)"/>
            is recommended for sparse problems, and the message functions used
            in inference will maintain that sparsity specification.
            </summary>
            <param name="pseudoCount">The vector of pseudo-counts</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Double[])">
            <summary>
            Creates a Dirichlet distribution with the psecified pseudo-counts
            </summary>
            <param name="pseudoCount">An array of pseudo-counts</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.PointMass(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a point-mass Dirichlet at the specified location
            </summary>
            <param name="mean">Where to locate the point-mass. All elements of the Vector must be positive</param>
            <returns>The created point mass Dirichlet</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Uniform(System.Int32)">
            <summary>
            Instantiates a uniform Dirichlet distribution
            </summary>
            <param name="dimension">Dimension</param>
            <returns>A new uniform Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Uniform(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Instantiates a uniform Dirichlet distribution of a given sparsity
            </summary>
            <param name="dimension">Dimension</param>
            <param name="sparsity">Sparsity</param>
            <returns>A new uniform Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Symmetric(System.Int32,System.Double)">
            <summary>
            Creates a Dirichlet distribution with all pseudo-counts equal to initialCount.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="pseudoCount">The value for each pseudo-count</param>
            <returns>A new Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Symmetric(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates a Dirichlet distribution of a given sparsity with all pseudo-counts equal to initialCount.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="pseudoCount">The value for each pseudo-count</param>
            <param name="sparsity">Sparsity specification</param>
            <returns>A new Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.PointMass(System.Double[])">
            <summary>
            Creates a point-mass Dirichlet at the specified location
            </summary>
            <param name="mean">Where to locate the point-mass. All elements of the array must be positive</param>
            <returns>The created point mass Dirichlet</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Dimension">
            <summary>
            Gets the dimension of this Dirichlet
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity">
            <summary>
            Gets the <see cref="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Sparsity"/> specification of this Distribution.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Point">
            <summary>
            Sets/gets this distribution as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Dirichlet.IsPointMass">
            <summary>
            Whether this Dirichlet is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4">
            <summary>
            Estimator for a DistributionArray type.
            </summary>
            <typeparam name="ItemEstimator">Type of estimator for each array element.</typeparam>
            <typeparam name="DistributionArray">Type of DistributionArray to estimate.</typeparam>
            <typeparam name="Distribution">Type of DistributionArray element.</typeparam>
            <typeparam name="Sample">Type of a SampleArray element - can be distributions.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.estimators">
            <summary>
            The array of estimators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.#ctor(System.Int32,System.Converter{System.Int32,`0})">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="length">Length of array</param>
            <param name="createEstimator">ItemEstimator for each array element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.#ctor(`0[])">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="estimators"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.GetDistribution(`1)">
            <summary>
            Retrieve the estimated distributions
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.Add(`3[])">
            <summary>
            Adds an array item to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.SetTo(MicrosoftResearch.Infer.Distributions.ArrayEstimator{`0,`1,`2,`3})">
            <summary>
            Set this ArrayEstimator to another ArrayEstimator
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`4.Clone">
            <summary>
            Clones this ArrayEstimator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3">
            <summary>
            Estimator for a DistributionArray type where the sample type is a distribution
            </summary>
            <typeparam name="ItemEstimator">Type of estimator for each array element.</typeparam>
            <typeparam name="DistributionArray">Type of DistributionArray to estimate.</typeparam>
            <typeparam name="Distribution">Type of DistributionArray element.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.estimators">
            <summary>
            The array of estimators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.#ctor(System.Int32,System.Converter{System.Int32,`0})">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="length">Length of array</param>
            <param name="createEstimator">ItemEstimator for each array element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.#ctor(`0[])">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="estimators"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.GetDistribution(`1)">
            <summary>
            Retrieve the estimated distributions
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.Add(`1)">
            <summary>
            Adds an array item to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.SetTo(MicrosoftResearch.Infer.Distributions.ArrayEstimator{`0,`1,`2})">
            <summary>
            Set this ArrayEstimator to another ArrayEstimator
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`3.Clone">
            <summary>
            Clones this ArrayEstimator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4">
            <summary>
            Estimator for a 2-D DistributionArray type.
            </summary>
            <typeparam name="ItemEstimator">Type of estimator for each array element.</typeparam>
            <typeparam name="DistributionArray">Type of DistributionArray to estimate.</typeparam>
            <typeparam name="Distribution">Type of a DistributionArray element.</typeparam>
            <typeparam name="Sample">Type of a SampleArray element - can be distributions.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.estimators">
            <summary>
            The array of estimators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,`0})">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="length1">Length of first dimension of array</param>
            <param name="length2">Length of second dimension of array</param>
            <param name="createEstimator">ItemEstimator for each array element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.#ctor(`0[0:,0:])">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="estimators">ItemEstimator for each array element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.GetDistribution(`1)">
            <summary>
            Retrieve the estimated distributions
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.Add(`3[0:,0:])">
            <summary>
            Adds an array item to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.SetTo(MicrosoftResearch.Infer.Distributions.Array2DEstimator{`0,`1,`2,`3})">
            <summary>
            Set this ArrayEstimator to another ArrayEstimator
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`4.Clone">
            <summary>
            Clones this ArrayEstimator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3">
            <summary>
            Estimator for a 2-D DistributionArray type, where the samples are distributions
            </summary>
            <typeparam name="ItemEstimator">Type of estimator for each array element.</typeparam>
            <typeparam name="DistributionArray">Type of DistributionArray to estimate.</typeparam>
            <typeparam name="Distribution">Type of a DistributionArray element.</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.estimators">
            <summary>
            The array of estimators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,`0})">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="length1">Length of first dimension of array</param>
            <param name="length2">Length of second dimension of array</param>
            <param name="createEstimator">ItemEstimator for each array element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.#ctor(`0[0:,0:])">
            <summary>
            Constructs an ArrayEstimator
            </summary>
            <param name="estimators">ItemEstimator for each array element</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.GetDistribution(`1)">
            <summary>
            Retrieve the estimated distributions
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.Add(`1)">
            <summary>
            Adds an array item to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.SetTo(MicrosoftResearch.Infer.Distributions.Array2DEstimator{`0,`1,`2})">
            <summary>
            Set this ArrayEstimator to another ArrayEstimator
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Array2DEstimator`3.Clone">
            <summary>
            Clones this ArrayEstimator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.AccumulatorList`1">
            <summary>
            Wraps a list of accumulators, adding each sample to all of them.
            </summary>
            <typeparam name="T">The type to accumulate</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.AccumulatorList`1.Accumulators">
            <summary>
            The list of accumulators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.AccumulatorList`1.#ctor(MicrosoftResearch.Infer.Distributions.Accumulator{`0}[])">
            <summary>
            Constructs an accumulator list
            </summary>
            <param name="accumulators"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.AccumulatorList`1.Add(`0)">
            <summary>
            Add an item to all accumulators in the list
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.AccumulatorList`1.Clear">
            <summary>
            Clear all accumulators in the list
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1">
            <summary>
            Wraps an accumulator, discarding the first BurnIn samples.
            </summary>
            <typeparam name="T">The type to accumulate</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.BurnIn">
            <summary>
             Burn in
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.Thin">
            <summary>
            Thin parameter
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.Count">
            <summary>
            Count
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.Accumulator">
            <summary>
            Accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.#ctor(System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.Accumulator{`0})">
            <summary>
            Constructs a burn-in accumulator
            </summary>
            <param name="burnIn"></param>
            <param name="thin"></param>
            <param name="accumulator"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.Add(`0)">
            <summary>
            Adds a sample to the burn-in accumulator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BurnInAccumulator`1.Clear">
            <summary>
            Clears the burn-in accumulator
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ArrayEstimator">
            <summary>
            Useful static methods relating to array estimators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator.CreateEstimator``2(``0,System.Boolean)">
            <summary>
            Create an estimator for a given distribution
            </summary>
            <typeparam name="T">Type of distribution</typeparam>
            <typeparam name="TDomain">Type of domain</typeparam>
            <param name="dist">The distribution</param>
            <param name="accumDist">Whether the estimator should accumulate distributions or samples</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator.GetEstimatorType(System.Type,System.Boolean)">
            <summary>
            Get the estimator type for a distribution
            </summary>
            <param name="distType">Distribution type</param>
            <param name="accumDist">Accumulate distributions rather than samples</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator.FromArray(System.Object,System.Type[],System.Type)">
            <summary>
            Convert an array of element estimators to an estimator over an array variable.
            </summary>
            <param name="arrayOfEstimators">Array of estimators</param>
            <param name="estimatorTypes">Estimator types at each depth</param>
            <param name="distType">Distribution type</param>
            <returns>Estimator over an array variable</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1">
            <summary>
            Static class which implements useful functions on estimator arrays.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(``1[],System.Type[])">
            <summary>
            Creates an estimator over an array domain from an estimator array over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="array">The estimator of each element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(System.Int32,System.Converter{System.Int32,``1},System.Type[])">
            <summary>
            Creates an estimator over an array domain from an estimator over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="length">The length of the array.</param>
            <param name="init">A function providing the estimator of each array element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(``1[0:,0:],System.Type[])">
            <summary>
            Creates an estimator over an array domain from independent estimators over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="array">The estimator of each element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,``1},System.Type[])">
            <summary>
            Creates an estimator over an array domain from independent estimators over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="length1">The first dimension of the array.</param>
            <param name="length2">The second dimension of the array.</param>
            <param name="init">A function providing the estimator of each array element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(``1[][],System.Type[])">
            <summary>
            Creates an estimator over an array domain from independent estimators over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="array">The estimator of each element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(``1[0:,0:][],System.Type[])">
            <summary>
            Creates an estimator over an array domain from independent estimators over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="array">The estimator of each element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(``1[][0:,0:],System.Type[])">
            <summary>
            Creates an estimator over an array domain from independent estimators over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="array">The estimator of each element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ArrayEstimator`1.Array``2(``1[][][],System.Type[])">
            <summary>
            Creates an estimator over an array domain from independent estimators over the elements.
            </summary>
            <typeparam name="TEstArray">Type of estimator array</typeparam>
            <typeparam name="TEstimator">Estimator type for an array element.</typeparam>
            <param name="array">The estimator of each element.</param>
            <param name="estArrTypes">Types of estimator array at each depth</param>
            <returns>A single estimator object over the array domain.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.Sample(MicrosoftResearch.Infer.Maths.SparseVector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase,MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="probsTrue">Incoming message from 'probsTrue'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanLog">Buffer 'MeanLog'.</param>
            <param name="MeanLogOneMinus">Buffer 'MeanLogOneMinus'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,probsTrue) p(sample,probsTrue) log(factor(sample,probsTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probsTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.MeanLogOneMinus(MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            Update the buffer 'MeanLogOneMinus'
            </summary>
            <param name="probsTrue">Incoming message from 'probsTrue'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>New value of buffer 'MeanLogOneMinus'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probsTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.MeanLog(MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            Update the buffer 'MeanLog'
            </summary>
            <param name="probsTrue">Incoming message from 'probsTrue'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>New value of buffer 'MeanLog'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probsTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase,MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="probsTrue">Constant value for 'probsTrue'.</param>
            <param name="MeanLog">Buffer 'MeanLog'.</param>
            <param name="MeanLogOneMinus">Buffer 'MeanLogOneMinus'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,probsTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.AverageLogFactor(System.Collections.Generic.IList{System.Boolean},MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probsTrue">Incoming message from 'probsTrue'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanLogOneMinus">Buffer 'MeanLogOneMinus'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(probsTrue) p(probsTrue) log(factor(sample,probsTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probsTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.AverageLogFactor(System.Collections.Generic.IList{System.Boolean},MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probsTrue">Constant value for 'probsTrue'.</param>
            <param name="MeanLogOneMinus">Buffer 'MeanLogOneMinus'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,probsTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="probsTrue">Constant value for 'probsTrue'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="probsTrue">Incoming message from 'probsTrue'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(probsTrue) p(probsTrue) log(factor(sample,probsTrue)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probsTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.ComputeLogOdds(System.Double,System.Double)">
            <summary>
            Used to compute log odds in the above operator
            </summary>
            <param name="trueCount"></param>
            <param name="falseCount"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.ProbsTrueAverageLogarithm(System.Collections.Generic.IList{System.Boolean})">
            <summary>
            VMP message to 'probsTrue'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <returns>The outgoing VMP message to the 'probsTrue' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'probsTrue' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseBernoulliFromBetaOp.ProbsTrueAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase)">
            <summary>
            VMP message to 'probsTrue'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'probsTrue' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'probsTrue'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,probsTrue)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Sample(MicrosoftResearch.Infer.Maths.SparseVector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.AverageLogFactor(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Distributions.SparseBetaList,MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="probsTrue">Incoming message from 'probsTrue'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanLog"></param>
            <param name="MeanLogOneMinus"></param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(probsTrue) p(probsTrue) log(factor(sample,probsTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probsTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.AverageLogFactor(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="probsTrue">Constant value 'probsTrue'.</param>
            <param name="MeanLog"></param>
            <param name="MeanLogOneMinus"></param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(probsTrue) p(probsTrue) log(factor(sample,probsTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probsTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.AverageLogFactor(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Distributions.SparseBetaList,System.Double,MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probsTrue">Incoming message from 'probsTrue'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="SumMeanLogOneMinus"></param>
            <param name="MeanLogMinusMeanLogOneMinus">Buffer 'MeanLogMinusMeanLogOneMinus'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(probsTrue) p(probsTrue) log(factor(sample,probsTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probsTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.MeanLogOneMinus(MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            Update the buffer 'MeanLogOneMinus'
            </summary>
            <param name="probsTrue">Incoming message from 'probsTrue'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>New value of buffer 'MeanLogOneMinus'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probsTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.SumMeanLogOneMinus(MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            Update the buffer 'SumMeanLogOneMinus'
            </summary>
            <param name="probsTrue">Incoming message from 'probsTrue'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>New value of buffer 'SumMeanLogOneMinus'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probsTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.MeanLogMinusMeanLogOneMinus(MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            Update the buffer 'MeanLogMinusMeanLogOneMinus'
            </summary>
            <param name="probsTrue">Incoming message from 'probsTrue'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>New value of buffer 'MeanLogMinusMeanLogOneMinus'</returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probsTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.AverageLogFactor(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probsTrue">Constant value for 'probsTrue'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,probsTrue))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="probsTrue">Constant value for 'probsTrue'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="probsTrue">Incoming message from 'probsTrue'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(probsTrue) p(probsTrue) log(factor(sample,probsTrue)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probsTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.ProbsTrueAverageLogarithm(System.Collections.Generic.IList{System.Int32},MicrosoftResearch.Infer.Distributions.SparseBetaList)">
            <summary>
            VMP message to 'probsTrue'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'probsTrue' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliIntegerSubsetFromBeta.ProbsTrueAverageLogarithm(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            VMP message to 'probsTrue'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'probsTrue' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'probsTrue'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,probsTrue)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product) p(product) factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product) p(product) factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'BVariance'
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Initial value of buffer 'BVariance'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Update the buffer 'BVariance'
            </summary>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'BMean'
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Initial value of buffer 'BMean'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Update the buffer 'BMean'
            </summary>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="to_product">Outgoing message to 'product'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product) p(product) factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="BMean">Buffer 'BMean'.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product,b) p(product,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="BMean">Buffer 'BMean'.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(product,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="BMean">Buffer 'BMean'.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(product,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.ProductAverageConditional(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'product'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="BMean">Buffer 'BMean'.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'product' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'product'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="BMean">Buffer 'BMean'.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'product' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(product) p(product) factor(product,a,b)]/p(b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' with 'product' integrated out.
            The formula is <c>sum_product p(product) factor(product,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProductOp.BAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BufferTesterCopyOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.BufferTester.Copy``1(``0)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferTesterCopyOp.Buffer``1(``0,``0,``0)">
            <summary>
            Update the buffer 'buffer'
            </summary>
            <param name="copy">Incoming message from 'copy'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferTesterCopyOp.BufferInit``1(``0)">
            <summary>
            Initialise the buffer 'buffer'
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <returns>Initial value of buffer 'buffer'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferTesterCopyOp.CopyAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'copy'
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <param name="buffer">Buffer 'buffer'.</param>
            <returns>The outgoing EP message to the 'copy' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'copy' as the random arguments are varied.
            The formula is <c>proj[p(copy) sum_(value) p(value) factor(copy,value)]/p(copy)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferTesterCopyOp.ValueAverageConditional``1(``0)">
            <summary>
            EP message to 'value'
            </summary>
            <param name="copy">Incoming message from 'copy'.</param>
            <returns>The outgoing EP message to the 'value' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'value' as the random arguments are varied.
            The formula is <c>proj[p(value) sum_(copy) p(copy) factor(copy,value)]/p(value)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Buffer">
            <summary>
            Buffer factors
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Buffer.Value``1">
            <summary>
            Value factor
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Buffer.Infer``1(``0)">
            <summary>
            Infer factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BufferOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Buffer.Value``1"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferOp.ValueAverageConditional``1(``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'value' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = ()</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferOp.ValueAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'value' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int log(f(value,x)) q(x) dx</c> where <c>x = ()</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.InferOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Buffer.Infer``1(``0)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InferOp.ValueAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = (infer)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InferOp.ValueAverageLogarithm``1(``0,``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int log(f(value,x)) q(x) dx</c> where <c>x = (infer)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.MakeCopy``1(``0)">
            <summary>
            This was called 'CloneWithDeepCloneForArrays' - has been renamed as it is now called in inference code.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.CopyStorage``1(``0)">
            <summary>
            Copies the storage of the passed in argument, without caring about its value.
            NOTE: This argument must be named 'result' for the framework to understand that only
                  the storage is being used.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.Boolean,System.Boolean)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogAverageFactor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_() p() factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(areEqual,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AverageLogFactor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(areEqual) p(areEqual) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'.</param>
            <param name="to_areEqual">Outgoing message to 'areEqual'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(areEqual) p(areEqual) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="to_A">Outgoing message to 'a'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="to_A">Outgoing message to 'a'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogAverageFactor(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="to_B">Outgoing message to 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(areEqual,a,b) p(areEqual,a,b) factor(areEqual,a,b) / sum_areEqual p(areEqual) messageTo(areEqual))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="to_A">Outgoing message to 'a'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="to_B">Outgoing message to 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(areEqual,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="to_A">Outgoing message to 'a'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(areEqual,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'areEqual' as the random arguments are varied.
            The formula is <c>proj[sum_(a,b) p(a,b) factor(areEqual,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int log(f(areEqual,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int log(f(areEqual,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int log(f(areEqual,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.Int32,System.Int32)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_() p() factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogEvidenceRatio(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(areEqual,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AverageLogFactor(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,System.Int32)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(areEqual) p(areEqual) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageConditional(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageConditional(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'.</param>
            <param name="to_areEqual">Outgoing message to 'areEqual'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(areEqual) p(areEqual) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="to_A">Previous outgoing message to 'A'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="to_B">Outgoing message to 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="to_A">Outgoing message to 'a'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(areEqual,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(areEqual) p(areEqual) factor(areEqual,a,b) / sum_areEqual p(areEqual) messageTo(areEqual))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="to_A">Outgoing message to 'a'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(areEqual,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogEvidenceRatio(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="to_B">Outgoing message to 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(areEqual,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="to_A">Outgoing message to 'a'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(areEqual,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>	
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'areEqual' as the random arguments are varied.
            The formula is <c>proj[sum_(a,b) p(a,b) factor(areEqual,a,b)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'areEqual' as the random arguments are varied.
            The formula is <c>proj[sum_(b) p(b) factor(areEqual,a,b)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'areEqual' as the random arguments are varied.
            The formula is <c>proj[sum_(a) p(a) factor(areEqual,a,b)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            Because the factor is deterministic, 'areEqual' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(b) p(b) log(sum_areEqual p(areEqual) factor(areEqual,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' with 'areEqual' integrated out.
            The formula is <c>sum_areEqual p(areEqual) factor(areEqual,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(areEqual,a,b)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageLogarithm(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            Because the factor is deterministic, 'areEqual' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(a) p(a) log(sum_areEqual p(areEqual) factor(areEqual,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' with 'areEqual' integrated out.
            The formula is <c>sum_areEqual p(areEqual) factor(areEqual,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            The formula is <c>exp(sum_(a) p(a) log(factor(areEqual,a,b)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageLogarithm(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian">
            <summary>
            Nonconjugate Gaussian messages for VMP. The mean has a Gaussian distribution and the variance a Gamma distribution. 
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.MeanTimesPrecision">
            <summary>
            Mean times precision for the mean
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.Precision">
            <summary>
            Precision for the mean
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.Shape">
            <summary>
            Shape parameter for the variance
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.Rate">
            <summary>
            Rate parameter for the variance
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.GetGaussian">
            <summary>
            Convert to the optimal Gaussian
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.GetGaussian(System.Boolean)">
            <summary>
            Convert to the optimal Gaussian
            </summary>
            <param name="addEntropy">Whether to include an entropy term</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.#ctor(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Constructs a non-conjugate Gaussian from a Gaussian
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.#ctor(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a non-conjugate Gaussian distribution its parameters 
            </summary>
            <param name="meanTimesPrecision">Mean times precision for the mean</param>
            <param name="precision">Precision for the mean</param>
            <param name="shape">Shape parameter for the variance</param>
            <param name="rate">Rate parameter for the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.IsProper">
            <summary>
            Returns true if the distribution is proper
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.SetToUniform">
            <summary>
            Sets this to a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.IsUniform">
            <summary>
            Returns true if distribution is uniform
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.MicrosoftResearch#Infer#Distributions#CanGetLogProb{System#Double}#GetLogProb(System.Double)">
            <summary>
            Gets the log probability of the given value
            </summary>
            <param name="value"></param>
            <returns>Not yet implemented</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.SetTo(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets this non-congugate Gaussian to a Gaussian
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.SetTo(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            Sets this non-conjugate Gaussian to another non-conjugate Gaussian
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.SetToProduct(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            Sets this non-conjugate Gaussian distribution to the product of two others.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.op_Multiply(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            Product operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.SetToRatio(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,System.Boolean)">
            <summary>
            Sets this non-conjugate Gaussian distribution to the ratio of two others.
            </summary>
            <param name="numerator">Numerator</param>
            <param name="denominator">Denominator</param>
            <param name="forceProper">Ignored</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.SetToPower(MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,System.Double)">
            <summary>
            Sets this non-conjugate Gaussian distribution to the power of another.
            </summary>
            <param name="value">The </param>
            <param name="exponent"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.MicrosoftResearch#Infer#Distributions#Sampleable{System#Double}#Sample">
            <summary>
            Samples from a non-conjugate Gaussian distribution
            </summary>
            <returns>Not yet implemented</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.MicrosoftResearch#Infer#Distributions#Sampleable{System#Double}#Sample(System.Double)">
            <summary>
            Samples from a non-conjugate Gaussian distribution
            </summary>
            <param name="result">Where to put the result</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.Uniform">
            <summary>
            Create a uniform non-conjugate Gaussian distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance of this distribution
            </summary>
            <param name="mean">Output mean</param>
            <param name="variance">Output variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.NonconjugateGaussian.ToString">
            <summary>
            Print details as as string
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Mixture`1">
            <summary>
            A mixture of distributions of the same type 
            </summary>
            <typeparam name="T">The distribution type</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Mixture`1.Components">
            <summary>
            The components
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Mixture`1.Weights">
            <summary>
            The mixing weight of each component.  Does not necessarily sum to 1.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.Add(`0,System.Double)">
            <summary>
            Add a component to the mixture with a given weight
            </summary>
            <param name="item">The component to add</param>
            <param name="weight">The weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.Add(`0)">
            <summary>
            Add a component to the mixture. A weight of 1 is assumed
            </summary>
            <param name="item">The component to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.WeightSum">
            <summary>
            The sum of the component weights
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.Normalize">
            <summary>
            Normalize the weights to add to 1
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.GetDistribution(MicrosoftResearch.Infer.Distributions.Mixture{`0})">
            <summary>
            The the resulting mixture
            </summary>
            <param name="result">Where to put the resulting mixture</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.#ctor">
            <summary>
            Create a mixture model
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Gaussian">
            <summary>
            Represents a one-dimensional Gaussian distribution.
            </summary>
            <remarks><para>
            The distribution is represented by two parameters: MeanTimesPrecision and Precision.
            Precision is the inverse of the variance, so a Gaussian with mean m and variance v is
            represented as Precision = 1/v, MeanTimesPrecision = m/v.
            </para><para>
            Some special cases:
            If the Precision is zero, then the distribution is uniform.
            If the Precision is infinite, then the distribution is a point mass.  The Point property
            gives the location of the point mass.
            </para><para>
            The formula for the distribution is:
            <c>N(x;m,v) = 1/sqrt(2*pi*v) * exp(-(x-m)^2/(2v))</c>.
            When v=0, this reduces to delta(x-m).
            When v=infinity, the density is redefined to be 1.
            When v &lt; 0, the density is redefined to be <c>exp(-0.5*x^2*(1/v) + x*(m/v))</c>, 
            i.e. we drop the terms <c>exp(-m^2/(2v))/sqrt(2*pi*v)</c>.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Gaussian.MeanTimesPrecision">
            <summary>
            Mean times precision
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Gaussian.Precision">
            <summary>
            Precision
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMeanAndVarianceImproper(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance, even if the distribution is improper
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMeanAndPrecision(System.Double@,System.Double@)">
            <summary>
            Gets the mean and precision
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="precision">Where to put the precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetMeanAndPrecision(System.Double,System.Double)">
            <summary>
            Sets the mean and precision
            </summary>
            <param name="mean">Mean</param>
            <param name="precision">Precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetNatural(System.Double@,System.Double@)">
            <summary>
            Gets the natural parameters of the distribution (mean time precision, and precision)
            </summary>
            <param name="meanTimesPrecision">Where to put the mean times precision</param>
            <param name="precision">Where to put the precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetNatural(System.Double,System.Double)">
            <summary>
            Sets the natural parameters of the distribution (mean time precision, and precision)
            </summary>
            <param name="meanTimesPrecision">Mean times precision</param>
            <param name="precision">Precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMean">
            <summary>
            Gets the expected value E(x)
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetVariance">
            <summary>
            Gets the variance
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing mean
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToUniform">
            <summary>
            Sets this Gaussian instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.IsProper">
            <summary>
            Asks whether this Gaussian instance is proper or not. A Gaussian distribution
            is proper only if Precision > 0.
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogProb(System.Double,System.Double,System.Double)">
            <summary>
            Evaluates the log of one-dimensional Gaussian density.
            </summary>
            <param name="x">Must be finite.</param>
            <param name="mean">Must be finite.</param>
            <param name="variance">Any real number.  May be zero or negative.</param>
            <remarks>
            <c>N(x;m,v) = 1/sqrt(2*pi*v) * exp(-(x-m)^2/(2v))</c>.
            When v=0, this reduces to delta(x-m).
            When v=infinity, the density is redefined to be 1.
            When v &lt; 0, the density is redefined to be <c>exp(-0.5*x^2*(1/v) + x*(m/v))</c>, 
            i.e. we drop the terms <c>exp(-m^2/(2v))/sqrt(2*pi*v)</c>.
            </remarks>
            <returns><c>log(N(x;mean,variance))</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogProb(System.Double)">
            <summary>
            Evaluates the log of this one-dimensional Gaussian density.
            </summary>
            <param name="x">Must be finite.</param>
            <returns><c>log(N(x;mean,variance))</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogNormalizer">
            <summary>
            Gets the log of the normalizer for the Gaussian density function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetAverageLog(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gets the expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double,System.Double)">
            <summary>
            Samples from a Gaussian distribution with the specified mean and precision
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample">
            <summary>
            Samples from this Gaussian distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double)">
            <summary>
            Samples from this Gaussian distribution. This override is only
            present to support the Sampleable interface
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetTo(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets this Gaussian instance to have the parameter values of that Gaussian instance
            </summary>
            <param name="that">That Gaussian</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToProduct(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets the parameters to represent the product of two Gaussians.
            </summary>
            <param name="a">The first Gaussian</param>
            <param name="b">The second Gaussian</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_Multiply(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Creates a new Gaussian which is the product of two other Gaussians
            </summary>
            <param name="a">First Gaussian</param>
            <param name="b">Second Gaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two Gaussians, optionally forcing the precision to be non-negative.
            </summary>
            <param name="numerator">The numerator Gaussian</param>
            <param name="denominator">The denominator Gaussian</param>
            <param name="forceProper">If true, the result will have non-negative precision, under the constraint that result*denominator has the same mean as numerator</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_Division(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Creates a new Gaussian which is the ratio of two other Gaussians
            </summary>
            <param name="numerator">numerator Gaussian</param>
            <param name="denominator">denominator Gaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToPower(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source Gaussian to some exponent.
            </summary>
            <param name="dist">The source Gaussian</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets the mean and variance to match a Gaussian mixture.
            </summary>
            <param name="weight1">First weight</param>
            <param name="g1">First Gaussian</param>
            <param name="weight2">Second weight</param>
            <param name="g2">Second Gaussian</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.WeightedSum``1(``0,System.Double,``0,System.Double,``0)">
            <summary>
            Creates a distribution of the specified type which matches the mean and variance
            of a Gaussian mixture. The distribution type must implement <see cref="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVarianceOut`2"/>,
            </summary>
            <see cref="T:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2"/>, and <see cref="T:MicrosoftResearch.Infer.Distributions.SettableToUniform"/>
            <typeparam name="T">Distribution type for the mixture</typeparam>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second distribution</param>
            <param name="result">Resulting distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gets the integral of the product of two Gaussians.
            </summary>
            <param name="that"></param>
            <remarks>
            <c>this = N(x;m1,v1)</c>.
            <c>that = N(x;m2,v2)</c>.
            <c>int_(-infinity)^(infinity) N(x;m1,v1) N(x;m2,v2) dx = N(m1; m2, v1+v2)</c>.
            When improper, the density is redefined to be <c>exp(-0.5*x^2*(1/v) + x*(m/v))</c>, 
            i.e. we drop the terms <c>exp(-m^2/(2v))/sqrt(2*pi*v)</c>.
            </remarks>
            <returns>log(N(m1;m2,v1+v2)).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Gaussian
            and that Gaussian
            </summary>
            <param name="thatd">That Gaussian</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_Equality(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_Inequality(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.#ctor(System.Double,System.Double)">
            <summary>
            Creates a Gaussian distribution with specified mean and variance.
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.#ctor(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Clone">
            <summary>
            Clones this Gaussian. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Gaussian type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a Gaussian distribution with given mean and variance.
            </summary>
            <param name="mean">The desired mean.</param>
            <param name="variance">The desired variance.</param>
            <returns>A new Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.FromMeanAndPrecision(System.Double,System.Double)">
            <summary>
            Creates a Gaussian distribution with given mean and precision.
            </summary>
            <param name="mean">The desired mean.</param>
            <param name="precision">precision = 1/variance.</param>
            <returns>A new Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.FromNatural(System.Double,System.Double)">
            <summary>
            Creates a new Gaussian distribution from its natural parameters
            (Mean times precision, and Precision)
            </summary>
            <param name="meanTimesPrecision">Mean time precision</param>
            <param name="precision">Precision</param>
            <returns>A new Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Uniform">
            <summary>
            Creates a new uniform Gaussian distribution
            </summary>
            <returns>A new uniform Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.PointMass(System.Double)">
            <summary>
            Create a new point mass Gaussian distribution at a specified location
            </summary>
            <param name="mean">The location for the point mass</param>
            <returns>A new point mass Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Gaussian.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Gaussian.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionArray`1">
            <summary>
            A distribution over an array, where each element is independent and has distribution type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">The distribution type of an element</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.#ctor(System.Int32)">
            <summary>
            Creates a distribution array of a specified length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.#ctor(`0[])">
            <summary>
            Creates a distribution array from an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.SetToUniform">
            <summary>
            Set the distribution to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.IsUniform">
            <summary>
            True if the distribution is uniform
            </summary>
            <returns>True if uniform, otherwise false</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.MaxDiff(System.Object)">
            <summary>
            The maximum difference in parameter values between this distribution and that distribution
            </summary>
            <param name="that">That distribution</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionArray`2">
            <summary>
            A distribution over an array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Distribution type of an element.  Must be a value type all the way down, i.e. must not hold any references.</typeparam>
            <typeparam name="DomainType">Domain type of an element</typeparam>
            <remarks>
            This is an extension of DistributionArray that implements IDistribution and Sampleable.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.#ctor(System.Int32)">
            <summary>
            Creates a distribution array of a specified length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.#ctor(`0[])">
            <summary>
            Creates a distribution array from an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.GetLogProb(`1[])">
            <summary>
            Logarithm of the probability density function
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.Sample">
            <summary>
            Get a sample from the distribution array
            </summary>
            <returns>An array of samples</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.Sample(`1[])">
            <summary>
            Get a sample from the distribution array
            </summary>
            <param name="result">Where to put the results</param>
            <returns>An array of samples</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionArray`2.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionArray`2.IsPointMass">
            <summary>
            True if the distribution is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2">
            <summary>
            A distribution over an array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Distribution type of an element.  Must be a value type all the way down, i.e. must not hold any references.</typeparam>
            <typeparam name="DomainType">Domain type of an element</typeparam>
            <remarks>
            This is an extension of DistributionArray that requires T to be a value type.
            This class only exists for efficiency, to avoid unnecessary cloning.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(System.Int32)">
            <summary>
            Create a new distribution struct array of a specified length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(System.Int32,System.Func{System.Int32,`0})">
            <summary>
            Create a new distribution struct array of a specified length and initial values.
            </summary>
            <param name="length"></param>
            <param name="init">Function that maps an index to a value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(`0,System.Int32)">
            <summary>
            Create a new distribution struct array of a specified value and length
            </summary>
            <param name="value"></param>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(`0[])">
            <summary>
            Create a new distribution struct array from an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.Clone">
            <summary>
            Clone the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.MaxDiff(System.Object)">
            <summary>
            The maximum difference in parameters between
            this distribution array and that distribution array
            </summary>
            <param name="that">That distribution array</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.Sample(`1[])">
            <summary>
            Get a sample from the distribution
            </summary>
            <param name="result">Where to put the result</param>
            <returns>A sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            Set the parameters of this distribution to match those of the given distribution (by value)
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            Set the parameters to represent the product of two distributions
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},System.Boolean)">
            <summary>
            Set the parameters to represent the ratio of two distributions
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},System.Double)">
            <summary>
            Set the parameters to represent the power of a source distribution to some exponent
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            Set the parameters to match the moments of a mixture of two distributions
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For a DistributionArray, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For a DistributionArray, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2">
            <summary>
            A distribution over an array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Distribution type of an element</typeparam>
            <typeparam name="DomainType">Domain type of an element</typeparam>
            <remarks>
            This is an extension of DistributionArray that requires T to be a reference type.
            The SetTo and CopyTo methods are overriden to use cloning instead of assignment.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(System.Int32)">
            <summary>
            Creates a distribution array given a length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(System.Int32,System.Func{System.Int32,`0})">
            <summary>
            Create a distribution struct array of a specified length and initial values.
            </summary>
            <param name="length"></param>
            <param name="init">Function that maps an index to a value.</param>
            <remarks>
            The references returned by <paramref name="init"/> are not copied.  They are placed directly into the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(`0,System.Int32)">
            <summary>
            Creates a new distribution array given a value and a length
            </summary>
            <param name="value"></param>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(`0[])">
            <summary>
            Creates a new distribution array given an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.InitializeTo(`0[])">
            <summary>
            Initialise the elements of this distribution array to clones of the given distributions
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetTo(`0[])">
            <summary>
            Set the parameters of this distribution so that the marginals match the given distributions (by value)
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.InitializeTo(`0)">
            <summary>
            Initialise all the values in this array to clones of the given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetAllElementsTo(`0)">
            <summary>
            Set the parameters of this distribution so that all marginals equal the given distribution (by value)
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.CopyTo(`0[])">
            <summary>
            Set the parameters of array[i] to match the marginal distribution of element i, creating a new distribution if array[i] was null
            </summary>
            <param name="array">Array to write into</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetItemsOf(`0[])">
            <summary>
            Set the parameters of array[i] to match the marginal distribution of element i
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetItemsOf(`0[],System.Int32)">
            <summary>
            Set the parameters of array[i] to match the marginal distribution of element i,
            starting at a given index
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.CopyTo(`0[],System.Int32)">
            <summary>
            Set the parameters of array[i] to match the marginal distribution of element i, creating a new distribution if array[i] was null,
            starting at a given index
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.Clone">
            <summary>
            Clones the array and the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.Sample(`1[])">
            <summary>
            Get a sample from the distribution
            </summary>
            <param name="result">Where to put the results</param>
            <returns>A sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            Set the parameters of this distribution to match those of the given distribution (by value)
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            Set the parameters to represent the product of two distributions
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},System.Boolean)">
            <summary>
            Set the parameters to represent the ratio of two distributions
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
            <param name="forceProper">Argument passed to T.SetToRatio</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},System.Double)">
            <summary>
            Set the parameters to represent the power of a source distribution to some exponent
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            Set the parameters to match the moments of a mixture of two distributions
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For a DistributionArray, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For a DistributionArray, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DiscreteChar">
            <summary>
            A discrete distribution over characters.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.#ctor">
            <summary>
            Creates a uniform distribution over the enum values.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.ConvertFromInt(System.Int32)">
            <summary>
            Converts from an integer to an enum value
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.ConvertToInt(System.Char)">
            <summary>
            Converts the enum value to an integer
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.ToString(System.Char)">
            <summary>
            ToString() method that handles unprintable characters.
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Digit">
            <summary>
            Distribution representing an unknown digit in 0..9
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Lower">
            <summary>
            Distribution representing an unknown lowercase letter in a..z
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Upper">
            <summary>
            Distribution representing an unknown uppercase letter in A..Z
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Letter">
            <summary>
            Distribution representing an unknown letter in a..z, A..Z
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.LetterOrDigit">
            <summary>
            Distribution representing an unknown letter or digit
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.WordChar">
            <summary>
            Distribution representing an unknown word character.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Whitespace">
            <summary>
            Distribution representing an unknown whitespace character
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteChar.Complement">
            <summary>
            Returns a distribution which is uniform over all characters
            that have zero probability in this distribution
            i.e. that are not 'in' this distribution.
            </summary>
            <remarks>
            This is useful for defining characters that are not in a particular distribution
            e.g. not a letter or not a word character.
            </remarks>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.SortedSet`1">
            <summary>
            A sorted collection of unique items.
            </summary>
            <typeparam name="T">The item type.</typeparam>
            <remarks>
            A sorted collection of items, all of which are different according
            to Equals.  null items are not allowed.  Adding a duplicate has no effect.
            Union, intersection, and superset are all supported via operator overloading.
            The items are stored in the keys of a SortedList, which does the sorting
            via its own comparer function.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all items in a collection.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.Contains(System.Collections.Generic.IList{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>result[i] is true iff the set contains list[i].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.ContainsAny(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>true if the set contains any item in list.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.Remove(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in a collection.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.op_GreaterThanOrEqual(MicrosoftResearch.Infer.Collections.SortedSet{`0},MicrosoftResearch.Infer.Collections.SortedSet{`0})">
            <summary>
            Superset operator.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>True iff a is equal to or a superset of b.</returns>
            <remarks>null is treated as an empty set.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.op_LessThanOrEqual(MicrosoftResearch.Infer.Collections.SortedSet{`0},MicrosoftResearch.Infer.Collections.SortedSet{`0})">
            <summary>
            Subset operator.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>True iff a is equal to or a subset of b.</returns>
            <remarks>null is treated as an empty set.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Quadrature">
            <summary>
            Quadrature nodes and weights
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Quadrature.AdaptiveClenshawCurtis(System.Converter{System.Double,System.Double},System.Double,System.Int32,System.Double)">
            <summary>
            Integrate the function f from -Infinity to Infinity
            </summary>
            <param name="f">The function to integrate</param>
            <param name="CCFactor">A positive tuning parameter</param>
            <param name="numIntervals">The initial number of nodes</param>
            <param name="relTol">A threshold to stop subdividing</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Quadrature.GaussianNodesAndWeights(System.Double,System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Quadrature nodes for Gaussian expectations.
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
            <param name="nodes">A list in which to store the nodes.</param>
            <param name="weights">A list in which to store the weights.</param>
            <remarks>
            The nodes and weights lists are modified to have the property that for any function f with a fast-converging Taylor series,
            <c>sum_i weights[i] f(nodes[i]) =approx int_{-inf..inf} f(x) N(x; m, v) dx</c>.
            If f is a polynomial of order 2*n-1, then the result is exact.
            For example, to compute E[x*x] where x ~ N(2,3):
            <code>
            Vector nodes = new Vector(2);
            Vector weights = new Vector(2);
            Quadrature.GaussianNodesAndWeights(2,3,nodes,weights);
            double result = (weights*nodes*nodes).Sum();
            </code>
            The result is mean^2 + variance = 7. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Quadrature.GammaNodesAndWeights(System.Double,System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Quadrature nodes for Gamma expectations.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="nodes">A list in which to store the nodes.</param>
            <param name="weights">A list in which to store the weights.</param>
            <remarks>
            The nodes and weights lists are modified to have the property that for any function f with a fast-converging Taylor series,
            <c>sum_i weights[i] f(nodes[i]) =approx int_{0..inf} f(x) Ga(x; a, b) dx</c> where
            <c>Ga(x; a, b) = x^a*exp(-x*b)*b^(a+1)/Gamma(a+1)</c>.
            For example, to approximate E[x*x] where x ~ Ga(2,3):
            <code>
            Vector nodes = new Vector(3);
            Vector logWeights = new Vector(3);
            Quadrature.GammaNodesAndWeights(2,3,nodes,logWeights);
            double result = (exp(logWeights)*nodes*nodes).Sum();
            </code>
            The result is mean^2 + variance = ((a+1)^2 + (a+1))/b^2 = 4/3.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Quadrature.UniformNodesAndWeights(System.Double,System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Quadrature nodes for integrals on [low,high].
            </summary>
            <param name="low">Lower limit of integration.  Must be finite.</param>
            <param name="high">Upper limit of integration.  Must be finite.</param>
            <param name="nodes">A list in which to store the nodes.</param>
            <param name="weights">A list in which to store the weights.</param>
            <remarks>
            The nodes and weights lists are modified to have the property that for any function f with a fast-converging Taylor series,
            <c>sum_i weights[i] f(nodes[i]) =approx int_{low..high} f(x) dx</c>.
            If f is a polynomial of order 2*n-1, then the result is exact.
            For example, to compute <c>int_{0..1} x^3 dx</c>:
            <code>
            Vector nodes = new Vector(2);
            Vector weights = new Vector(2);
            Quadrature.UniformNodesAndWeights(0,1,nodes,weights);
            double result = (weights*nodes*nodes*nodes).Sum();
            </code>
            The result is 1/4.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Quadrature.LegendreNodesAndWeights">
            <summary>
            Legendre nodes and weights
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Quadrature.LaguerreNodesAndWeights">
            <summary>
            Laguerre nodes and weights
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Quadrature.HermiteNodesAndWeights">
            <summary>
            Hermite nodes and weights
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.IListExtensions">
            <summary>
            Provides extension methods for IList that support sparse lists.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.IsSparse``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns true if and only if this list is sparse
            </summary>
            <typeparam name="T">The type of this list</typeparam>
            <param name="source">The list</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ListSelect``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>
            Similar to LINQ Select, except it takes and returns a list.
            If the supplied list is sparse, the returned list will also be sparse.
            </summary>
            <typeparam name="T">The type of this list</typeparam>
            <typeparam name="T2">The target element type</typeparam>
            <param name="source">This list</param>
            <param name="converter">The converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ListSum(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Sums the elements of this list.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ListSum(System.Collections.Generic.IList{System.Int32},System.Func{System.Int32,System.Double})">
            <summary>
            Sums the elements of this list, after transforming each element using the specified converter.
            </summary>
            <param name="source"></param>
            <param name="converter">The converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.Inner(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Double})">
            <summary>
            Computes the inner product between an integer list and a double list of the same size.
            </summary>
            <param name="source"></param>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ListReduce``2(System.Collections.Generic.IList{``0},``1,System.Func{``1,``0,``1})">
            <summary>
            Reduces across a list.
            </summary>
            <typeparam name="T">Type of this list</typeparam>
            <typeparam name="TRes">Type of result</typeparam>
            <param name="source">This list</param>
            <param name="initial">Initial value for reduction</param>
            <param name="fun">The function</param>		/// <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ListReduce``3(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``1},``2,System.Func{``2,``0,``1,``2})">
            <summary>
            Reduces across a list and another collection
            </summary>
            <typeparam name="T">Type of this list</typeparam>
            <typeparam name="T2">Type of the other list</typeparam>
            <typeparam name="TRes">Type of result</typeparam>
            <param name="source">This list</param>
            <param name="secondList">The other collection</param>
            <param name="initial">Initial value for reduction</param>
            <param name="fun">The function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ToVector(System.Collections.Generic.IList{System.Double})">
            <summary>
            Converts a list of doubles into a vector.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.ToVector(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Converts a list of ints into a double vector.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.SetTo``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Sets this list from an enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IListExtensions.SetTo(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Sets this list from an enumerable (need separate implementation from
            generic version for interop with Vectors)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="that"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VectorGaussianOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.VectorGaussian(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'SampleVariance'
            </summary>
            <param name="Sample">Incoming message from 'sample'.</param>
            <returns>Initial value of buffer 'SampleVariance'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Update the buffer 'SampleVariance'
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'SampleMean'
            </summary>
            <param name="Sample">Incoming message from 'sample'.</param>
            <returns>Initial value of buffer 'SampleMean'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Update the buffer 'SampleMean'
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="SampleVariance">Buffer 'SampleVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'MeanVariance'
            </summary>
            <param name="Mean">Incoming message from 'mean'.</param>
            <returns>Initial value of buffer 'MeanVariance'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Update the buffer 'MeanVariance'
            </summary>
            <param name="Mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'MeanMean'
            </summary>
            <param name="Mean">Incoming message from 'mean'.</param>
            <returns>Initial value of buffer 'MeanMean'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Update the buffer 'MeanMean'
            </summary>
            <param name="Mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanVariance">Buffer 'MeanVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionMeanInit(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Initialise the buffer 'PrecisionMean'
            </summary>
            <param name="Precision">Incoming message from 'precision'.</param>
            <returns>Initial value of buffer 'PrecisionMean'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionMean(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Update the buffer 'PrecisionMean'
            </summary>
            <param name="Precision">Incoming message from 'precision'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionMeanLogDet(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Update the buffer 'PrecisionMeanLogDet'
            </summary>
            <param name="Precision">Incoming message from 'precision'.</param>
            <returns>New value of buffer 'PrecisionMeanLogDet'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,precision))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Gibbs message to 'sample'
            </summary>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Gibbs message to 'mean'
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gibbs message to 'precision'
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'precision' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Gibbs message to 'precision'
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'precision' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="SampleMean">Buffer 'SampleMean'.</param>
            <param name="SampleVariance">Buffer 'SampleVariance'.</param>
            <param name="MeanMean">Buffer 'MeanMean'.</param>
            <param name="MeanVariance">Buffer 'MeanVariance'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,precision))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="MeanMean">Buffer 'MeanMean'.</param>
            <param name="MeanVariance">Buffer 'MeanVariance'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,precision))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="MeanMean">Buffer 'MeanMean'.</param>
            <param name="MeanVariance">Buffer 'MeanVariance'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,mean) p(sample,mean) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="Mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(mean) p(mean) factor(sample,mean,precision)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(sample) p(sample) factor(sample,mean,precision)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            EP message to 'precision'
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'precision' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="SampleMean">Buffer 'SampleMean'.</param>
            <param name="SampleVariance">Buffer 'SampleVariance'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanMean">Buffer 'MeanMean'.</param>
            <param name="MeanVariance">Buffer 'MeanVariance'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="precisionMean">Buffer 'precisionMean'.</param>
            <param name="precisionMeanLogDet">Buffer 'precisionMeanLogDet'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,mean,precision) p(sample,mean,precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="precisionMean">Buffer 'precisionMean'.</param>
            <param name="precisionMeanLogDet">Buffer 'precisionMeanLogDet'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(precision) p(precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="SampleMean">Buffer 'SampleMean'.</param>
            <param name="SampleVariance">Buffer 'SampleVariance'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanMean">Buffer 'MeanMean'.</param>
            <param name="MeanVariance">Buffer 'MeanVariance'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(mean) p(mean) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanMean">Buffer 'MeanMean'.</param>
            <param name="MeanVariance">Buffer 'MeanVariance'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="precisionMean">Buffer 'precisionMean'.</param>
            <param name="precisionMeanLogDet">Buffer 'precisionMeanLogDet'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(mean,precision) p(mean,precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="SampleMean">Buffer 'SampleMean'.</param>
            <param name="SampleVariance">Buffer 'SampleVariance'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="precisionMean">Buffer 'precisionMean'.</param>
            <param name="precisionMeanLogDet">Buffer 'precisionMeanLogDet'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,precision) p(sample,precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="SampleMean">Buffer 'SampleMean'.</param>
            <param name="SampleVariance">Buffer 'SampleVariance'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanMean">Buffer 'MeanMean'.</param>
            <param name="MeanVariance">Buffer 'MeanVariance'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,mean) p(sample,mean) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="SampleMean">Mean of incoming message from 'sample'</param>
            <param name="SampleVariance">Variance of incoming message from 'sample'</param>
            <param name="MeanMean">Mean of incoming message from 'mean'</param>
            <param name="MeanVariance">Variance of incoming message from 'mean'</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="SampleMean">Mean of incoming sample message</param>
            <param name="SampleVariance">Variance of incoming sample message</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="Mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanMean">Buffer 'MeanMean'.</param>
            <param name="Precision">Incoming message from 'precision'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="PrecisionMean">Buffer 'PrecisionMean'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(mean,precision) p(mean,precision) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanMean">Buffer 'MeanMean'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="Precision">Incoming message from 'precision'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="PrecisionMean">Buffer 'PrecisionMean'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(precision) p(precision) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="SampleMean">Buffer 'SampleMean'.</param>
            <param name="Precision">Incoming message from 'precision'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="PrecisionMean">Buffer 'PrecisionMean'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(sample,precision) p(sample,precision) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="SampleMean">Buffer 'SampleMean'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Precision">Incoming message from 'precision'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="PrecisionMean">Buffer 'PrecisionMean'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(precision) p(precision) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'precision'
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'precision' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'precision'
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="SampleMean">Buffer 'SampleMean'.</param>
            <param name="SampleVariance">Buffer 'SampleVariance'.</param>
            <param name="Mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanMean">Buffer 'MeanMean'.</param>
            <param name="MeanVariance">Buffer 'MeanVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'precision'.
            The formula is <c>exp(sum_(sample,mean) p(sample,mean) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'precision'
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanMean">Buffer 'MeanMean'.</param>
            <param name="MeanVariance">Buffer 'MeanVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'precision'.
            The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'precision'
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="SampleMean">Buffer 'SampleMean'.</param>
            <param name="SampleVariance">Buffer 'SampleVariance'.</param>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'precision'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SampleFromMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianFromMeanAndVarianceOp.SampleAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteFromLogProbsOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.DiscreteFromLogProbs(System.Double[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromLogProbsOp.LogAverageFactor(System.Int32,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logProbs">Incoming message from 'logProbs'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(logProbs) p(logProbs) factor(sample,logProbs))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromLogProbsOp.AverageLogFactor(System.Int32,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logProbs">Incoming message from 'logProbs'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(logProbs) p(logProbs) log(factor(sample,logProbs))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromLogProbsOp.AverageLogFactor(System.Int32,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logProbs">Incoming message from 'logProbs'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(logProbs) p(logProbs) log(factor(sample,logProbs))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logProbs"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromLogProbsOp.LogProbsAverageLogarithm``1(System.Int32,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            VMP message to 'logProbs'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logProbs">Incoming message from 'logProbs'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'logProbs' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logProbs"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.PoissonEstimator">
            <summary>
            Estimates a Poisson distribution from samples.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PoissonEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Retrieves an estimation of the distribution
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PoissonEstimator.Add(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Add a distribution sample to the estimator
            </summary>
            <param name="item">The item to add</param>
            <remarks>Assumes a Com-Poisson precision of 1.0</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PoissonEstimator.Clear">
            <summary>
            Clear the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PoissonEstimator.Add(System.Double)">
            <summary>
            Add a domain sample to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PoissonEstimator.SetTo(MicrosoftResearch.Infer.Distributions.PoissonEstimator)">
            <summary>
            Set this estimator to another
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PoissonEstimator.Clone">
            <summary>
            Clone this estimator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel">
            <summary>
            Summation kernel. This provides the management layer for adding
            together different kernels
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.kernels">
            <summary>
            List of kernels in the summation
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.indexInKernel">
            <summary>
            Index of a hyper-parameter within a participating kernel
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.indexOfKernel">
            <summary>
            Index of the kernel to which the hyper-parameter belongs
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.thetaCount">
            <summary>
            Parameter counts of the individual kernels
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.clearMaps">
            <summary>
            Clear maps between container and containees
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.initialise">
            <summary>
            (Re-)initialise a summation kernel. This clears
            all participating kernels
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.buildMaps">
            <summary>
            Helper method for building maps between container and containees
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.#ctor(MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams)">
            <summary>
            Constructs summation kernel from an initial kernel function
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.op_Addition(MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel,MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams)">
            <summary>
            Adds two kernel functions
            </summary>
            <param name="kernelA"></param>
            <param name="kernelB"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Write(System.IO.StreamWriter)">
            <summary>
            Writes the function parameters out to a stream
            </summary>
            <param name="sw">Stream writer</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Read(System.IO.StreamReader)">
            <summary>
            Reads the function parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Kernels">
            <summary>
            The participating kernels
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.ThetaCount">
            <summary>
            Number of theta parameters
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index">parameter index</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Item(System.String)">
            <summary>
            Set or get hyper-parameter by name. This indexer is not over-rideable
            </summary>
            <param name="name">Mame of the hyper-parameter</param>
            <returns>The hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GaussianProcess">
            <summary>
            A base class for Gaussian process distributions
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GaussianProcess.mean">
            <summary>
            Mean function
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GaussianProcess.kernel">
            <summary>
            Covariance function
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.#ctor(MicrosoftResearch.Infer.Distributions.IFunction,MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction)">
            <summary>
            Constructor
            </summary>
            <param name="mean">Mean function</param>
            <param name="kernel">Kernel function</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Sample">
            <summary>
            This base class just returns the mean function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Sample(MicrosoftResearch.Infer.Distributions.IFunction)">
            <summary>
            This base class just returns the mean function
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Mean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Mean at a given point
            </summary>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Mean(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Mean at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive mean vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Variance(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive Variance at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Covariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive covariance at a given pair of points
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Covariance(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive coariance at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive covariance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Marginal(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive distribution at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Joint(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive distribution at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianProcess.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CreateEstimatorMethod">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.EstimatorFactory">
            <summary>
            Estimator factor. Given a distribution instance, create a compatible estimator instance
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorFactory.RegisterEstimator(System.Type,System.Type,MicrosoftResearch.Infer.Distributions.CreateEstimatorMethod)">
            <summary>
            Registers an estimator. The factory is primed with stock
            stock estimators. This function allows clients to add in custom
            estimators
            </summary>
            <param name="distType">Distribution type</param>
            <param name="estType">Estimator type</param>
            <param name="c">Method for creating the estimator</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorFactory.CreateEstimator``2(``0)">
            <summary>
            Creates an estimator instance from a distribution prototype
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TDomain"></typeparam>
            <param name="distProto">Distribution prototype</param>
            <returns>Estimator instance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorFactory.EstimatorType(System.Type)">
            <summary>
            Creates an estimator instance from a distribution prototype
            </summary>
            <param name="distType">Distribution type</param>
            <returns>Estimator instance</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.EstimatorFactory.Instance">
            <summary>
            Estimator factory singleton instance
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Evaluator`2">
            <summary>
            Delegate type for evaluating log densities. This is used for distributions such as
            <see cref="T:MicrosoftResearch.Infer.Distributions.VectorGaussian"/> which have a large memory footprint. If a distribution
            supports <see cref="T:MicrosoftResearch.Infer.Distributions.CanGetLogProbPrep`2"/>, then it can return a delegate of this type
            to do evaluations without recreating a workspace each time.
            </summary>
            <typeparam name="DistributionType">The distribution type</typeparam>
            <typeparam name="T">The domain type of the distribution</typeparam>
            <param name="dist">The distribution instance</param>
            <param name="value">The value at which to evaluate the log density</param>
            <returns>The delegate returns a double</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Sampler`1">
            <summary>
            Delegate type for sampling
            </summary>
            <typeparam name="T">Domain type</typeparam>
            <param name="result">Where to put the result</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Sampler`2">
            <summary>
            Delegate type for sampling a distribution. This is used for distributions such as
            <see cref="T:MicrosoftResearch.Infer.Distributions.VectorGaussian"/> which have a large memory footprint. If a distribution
            supports <see cref="T:MicrosoftResearch.Infer.Distributions.CanSamplePrep`2"/>, then it can return a delegate of this type
            to do successive sampling without recreating a workspace each time.
            </summary>
            <typeparam name="DistributionType">The distribution type</typeparam>
            <typeparam name="T">The domain type of the distribution</typeparam>
            <param name="distribution">The distribution instance</param>
            <param name="result">The value at which to evaluate the log density</param>
            <returns>The delegate's return type is the domain type</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ImproperDistributionException">
            <summary>
            Exception thrown when a distribution is improper and its expectations need to be computed.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ImproperDistributionException.#ctor(System.Object)">
            <summary>
            Create a new Improper Distribution exception
            </summary>
            <param name="distribution"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Distribution">
            <summary>
            Static class which implements useful functions on distributions.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.IsDistributionType(System.Type)">
            <summary>
            Determinines if this type is a distribution type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.HasDistributionType(System.Type)">
            <summary>
            Determines whether the type, or any element, or any generic type parameter specification, etc
            is a distribution type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetQualityBand(System.Type)">
            <summary>
            Returns the quality band for the distribution type
            </summary>
            <param name="type">The distribution type</param>
            <returns></returns>
            <remarks>This will throw an exception if there is no distribution associated with this type. Call
            <see cref="M:MicrosoftResearch.Infer.Distributions.Distribution.HasDistributionType(System.Type)"/> to check.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetDomainType(System.Type)">
            <summary>
            Gets the domain type of a distribution type, e.g. the domain type of 'Gaussian' is 'double'.
            </summary>
            <param name="distributionType"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.ChangeType``1(System.Object)">
            <summary>
            Convert a distribution from one type to another
            </summary>
            <typeparam name="TReturn">The desired distribution type</typeparam>
            <param name="distribution">The object to convert</param>
            <returns>The converted distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.MakeDistributionArrayType(System.Type,System.Int32)">
            <summary>
            Makes a distribution array of a specified type and size
            </summary>
            <param name="elementType">Distribution type</param>
            <param name="rank">Number of dimensions</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.ToArray``1(System.Object)">
            <summary>
            Convert a distribution over an array variable to an array of element distributions.
            </summary>
            <typeparam name="ArrayType">A .NET array type, such as <c>Bernoulli[]</c> or <c>Gaussian[,][]</c>.  The array structure should match the domain of the distribution.</typeparam>
            <param name="distributionArray">A distribution over an array domain, such as <c>IDistribution&lt;bool[]&gt;</c> or <c>IDistribution&lt;double[,][]&gt;</c>.</param>
            <returns>An array of element distributions.</returns>
            <remarks>
            <typeparamref name="ArrayType"/> should match the array structure of the domain.  For example, if the input
            is <c>IDistribution&lt;bool[,]&gt;</c> then <typeparamref name="ArrayType"/> should be
            <c>Bernoulli[,]</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.ToArray``2(``0)">
            <summary>
            Convert a distribution over an array variable to an array of element distributions.
            </summary>
            <typeparam name="DistributionType">The concrete type of distributionArray</typeparam>
            <typeparam name="ArrayType">A .NET array type, such as <c>Bernoulli[]</c> or <c>Gaussian[,][]</c>.  The array structure should match the domain of the distribution.</typeparam>
            <param name="distributionArray">A distribution over an array domain, such as <c>IDistribution&lt;bool[]&gt;</c> or <c>IDistribution&lt;double[,][]&gt;</c>.</param>
            <returns>An array of element distributions.</returns>
            <remarks>
            <typeparamref name="ArrayType"/> should match the array structure of the domain.  For example, if the input
            is <c>IDistribution&lt;bool[,]&gt;</c> then <typeparamref name="ArrayType"/> should be
            <c>Bernoulli[,]</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetArrayConverter``2">
            <summary>
            Get a converter from a distribution over an array variable to an array of element distributions.
            </summary>
            <typeparam name="TInput">A distribution type over an array domain, such as <c>IDistribution&lt;bool[]&gt;</c></typeparam>
            <typeparam name="TOutput">An array type such as <c>Bernoulli[]</c></typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.FromArray(System.Object)">
            <summary>
            Convert an array of element distributions to a distribution over an array variable.
            </summary>
            <param name="arrayOfDistributions">Array of distributions</param>
            <returns>Distribution over an array variable</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetTo``2(``0,``1)">
            <summary>
            Sets result to value and returns result.
            </summary>
            <typeparam name="T">Type of the result</typeparam>
            <typeparam name="TValue">Type of the value</typeparam>
            <param name="result">The result</param>
            <param name="value">The value</param>
            <returns>result, or a newly allocated object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetTo``3(``0,``1)">
            <summary>
            Sets result to value and returns result.
            </summary>
            <typeparam name="T">Type of the result</typeparam>
            <typeparam name="TValue">Type of the value</typeparam>
            <typeparam name="TDomain">Domain</typeparam>
            <param name="result">The result</param>
            <param name="value">The value</param>
            <returns>result, or a newly allocated object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductOfAll``2(``0,System.Collections.Generic.IList{``1})">
            <summary>
            Product of all distributions in an array.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c>, unless it is not SettableTo&lt;T&gt; in which case an element of dists may be returned.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductOfAll``2(``0,``1[])">
            <summary>
            Sets a distribution to the product of an array of ditributions
            </summary>
            <typeparam name="T">Domain type of the result distribution</typeparam>
            <typeparam name="U">Domain type of the array of distributions</typeparam>
            <param name="result">The result distribution</param>
            <param name="dists">The array of distributions</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAllExcept``2(``0,System.Collections.Generic.IList{``1},System.Int32)">
            <summary>
            Multiplies result by all distributions in an array, except for one index.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <param name="index"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAllExcept``2(``0,``1[],System.Int32)">
            <summary>
            Multiplies result by all distributions in an array, except for one index.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <param name="index"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAll``2(``0,System.Collections.Generic.IList{``1})">
            <summary>
            Multiplies result by all distributions in an array.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAll``2(``0,``1[])">
            <summary>
            Multiplies result by all distributions in an array.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAllExcept``3(``0,System.Collections.Generic.IList{``1},System.Int32)">
            <summary>
            Multiplies result by all distributions in an array, except for one index.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <param name="index"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAll``3(``0,System.Collections.Generic.IList{``1})">
            <summary>
            Multiplies result by all distributions in an array.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductOfAllExcept``2(``0,System.Collections.Generic.IList{``1},System.Int32,System.Int32)">
            <summary>
            Product of distributions in an array.
            </summary>
            <param name="result">A reference in which to place the results.</param>
            <param name="dists">An array of distributions.</param>
            <param name="count">The number of distributions in the array to multiply (starting from index 0).</param>
            <param name="index">An array index to omit in the multiplication.  If index == count, no index is omitted and all distributions are multiplied.</param>
            <returns><c>result</c>, unless it is not SettableTo&lt;T&gt; in which case an element of dists may be returned.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.LogInnerProduct``1(System.Collections.Generic.IList{``0})">
            <summary>
            Log-probability that all distributions in the list would produce the same value.
            </summary>
            <param name="dists"></param>
            <returns><c>sum_x prod_i dists[i](x)</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.MaxDiff``2(``0[],``1[])">
            <summary>
            Max difference between two arrays of distributions
            </summary>
            <typeparam name="T">Domain type for fisrt array of distributions</typeparam>
            <typeparam name="U">Domain type for second array of distributions</typeparam>
            <param name="a">First array of distributions</param>
            <param name="b">Second array of distributions</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProduct``2(``0[],``1[],``1[])">
            <summary>
            Sets each element of result to the product of the corresponding distributions in two given
            arrays
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the two distribution arrays</typeparam>
            <param name="result">Result</param>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProduct``4(``0[],``1[],``2[])">
            <summary>
            Sets each element of the result to the product of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the numerator distribution arrays</typeparam>
            <typeparam name="T3">Element type of the denominator distribution array</typeparam>
            <typeparam name="TDomain">Domian type</typeparam>
            <param name="result">Result distribution array</param>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToRatio``2(``0[],``1[],``1[],System.Boolean)">
            <summary>
            Sets each element of the result to the ratio of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the numerator and denominator distribution arrays</typeparam>
            <param name="result">Result distribution array</param>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
            <param name="forceProper">Argument passed to T1.SetToRatio</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToRatio``4(``0[],``1[],``2[])">
            <summary>
            Sets each element of the result to the ratio of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the numerator distribution arrays</typeparam>
            <typeparam name="T3">Element type of the denominator distribution array</typeparam>
            <typeparam name="TDomain">Domian type</typeparam>
            <param name="result">Result distribution array</param>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToPower``2(``0[],``1[],System.Double)">
            <summary>
            Sets each element of the result to a power of the corresponding element in a source distribution array
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the source distribution array</typeparam>
            <param name="result">Result distribution array</param>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToPowerLazy``2(``0[],``1[],System.Double)">
            <summary>
            Sets each element of the result to a power of the corresponding element in a source distribution array
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the source distribution array</typeparam>
            <param name="result">Result distribution array</param>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToSum``2(``0[],System.Double,``1[],System.Double,``1[])">
            <summary>
            Sets each element of result to a weighted sum of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the two source distribution arrays</typeparam>
            <param name="result">Result distribution array</param>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToSumLazy``2(``0[],System.Double,``1[],System.Double,``1[])">
            <summary>
            Sets each element of result to a weighted sum of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the two source distribution arrays</typeparam>
            <param name="result">Result distribution array</param>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetLogAverageOf``2(``0[],``1[])">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <typeparam name="T1">Element type of this distribution array</typeparam>
            <typeparam name="T2">Element type of that distribution array</typeparam>
            <param name="thisDist">This distribution array</param>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For an array, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetLogAverageOfLazy``2(``0[],``1[])">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <typeparam name="T1">Element type of this distribution array</typeparam>
            <typeparam name="T2">Element type of that distribution array</typeparam>
            <param name="thisDist">This distribution array</param>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For an array, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetAverageLog``2(``0[],``1[])">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <typeparam name="T">Type of this distribution</typeparam>
            <typeparam name="TValue">Type of the distribution to take the logarithm of</typeparam>
            <param name="thisDist">This distribution</param>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For an array, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetAverageLogLazy``2(``0[],``1[])">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <typeparam name="T1">Element type of this distribution array</typeparam>
            <typeparam name="T2">Element type of thatd istribution array</typeparam>
            <param name="thisDist">This distribution array</param>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For an array, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.PointMass``1(``0)">
            <summary>
            Creates a point mass at the specified location.
            </summary>
            <param name="point">The point at which to place the point mass</param>
            <returns>The PointMass object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetPoint``2(``0,``1)">
            <summary>
            Set a distribution to a point mass
            </summary>
            <typeparam name="TDist">The distribution type</typeparam>
            <typeparam name="T">The domain type</typeparam>
            <param name="result">Where to put the result (for reference types)</param>
            <param name="point">The location of the point mass</param>
            <returns>A point mass distribution of the specified type and location</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Distribution`1">
            <summary>
            Static class which implements useful functions on distributions.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="length">The length of the array.</param>
            <param name="init">A function providing the distribution of each array element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[0:,0:])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="length1">The first dimension of the array.</param>
            <param name="length2">The second dimension of the array.</param>
            <param name="init">A function providing the distribution of each array element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[][])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[0:,0:][])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[][0:,0:])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[][][])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.IGeneratedAlgorithm">
            <summary>
            Interface for running a generated inference algorithm
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Execute(System.Int32)">
            <summary>
            Execute the inference algorithm for the specified number of iterations, starting from the initial state
            </summary>
            <param name="numberOfIterations">The number of iterations to perform from the initial state</param>
            <remarks>
            Sets <c>NumberOfIterationsDone = <paramref name="numberOfIterations"/></c>.
            This method is equivalent to calling <c>Reset()</c> followed by <c>Update(numberOfIterations)</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Update(System.Int32)">
            <summary>
            Perform additional iterations of the inference algorithm
            </summary>
            <param name="additionalIterations">The number of additional iterations to perform</param>
            <remarks>
            If no observed values have changed, this method increments <c>NumberOfIterationsDone</c> by <paramref name="additionalIterations"/>,
            and is equivalent to calling <c>Execute(NumberOfIterationsDone + additionalIterations)</c>.
            If some observed values have changed, this method sets <c>NumberOfIterationsDone = <paramref name="additionalIterations"/></c>,
            and is not equivalent to calling <c>Execute</c>, because it will start from the existing message state rather than the initial state.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Reset">
            <summary>
            Reset all messages to their initial values.  Sets NumberOfIterationsDone to 0
            </summary>
            <remarks>
            This method is equivalent to calling <c>Execute(0)</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Marginal(System.String)">
            <summary>
            Get the marginal distribution (computed up to this point) of a variable
            </summary>
            <param name="variableName">Name of the variable in the generated code</param>
            <returns>The marginal distribution computed up to this point</returns>
            <remarks>
            Execute, Update, or Reset must be called first to set the value of the marginal.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Marginal``1(System.String)">
            <summary>
            Get the marginal distribution (computed up to this point) of a variable, converted to type T
            </summary>
            <param name="variableName">Name of the variable in the generated code</param>
            <returns>The marginal distribution computed up to this point</returns>
            <remarks>
            Execute, Update, or Reset must be called first to set the value of the marginal.
            The conversion operation may be costly, even if the marginal already has type T.
            For maximum efficiency, use the non-generic Marginal method when conversion is not needed.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Marginal(System.String,System.String)">
            <summary>
            Get the query-specific marginal distribution of a variable.
            For example, GibbsSampling answers "Marginal", "Samples", and "Conditionals" queries
            </summary>
            <param name="variableName">Name of the variable in the generated code</param>
            <param name="query">Query string</param>
            <returns>The query-specific marginal distribution computed up to this point</returns>
            <remarks>
            Execute, Update, or Reset must be called first to set the value of the marginal.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.Marginal``1(System.String,System.String)">
            <summary>
            Get the query-specific marginal distribution of a variable, converted to type T
            </summary>
            <typeparam name="T">Type to cast to</typeparam>
            <param name="variableName">Name of the variable in the generated code</param>
            <param name="query">Query</param>
            <returns>The query-specific marginal distribution computed up to this point</returns>
            <remarks>
            Execute, Update, or Reset must be called first to set the value of the marginal.
            The conversion operation may be costly, even if the marginal already has type T.
            For maximum efficiency, use the non-generic Marginal method when conversion is not needed.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.GetObservedValue(System.String)">
            <summary>
            Gets an observed value
            </summary>
            <param name="variableName">Name of the variable in the generated code</param>
            <returns>The observed value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.IGeneratedAlgorithm.SetObservedValue(System.String,System.Object)">
            <summary>
            Sets an observed value
            </summary>
            <param name="variableName">Name of the variable in the generated code</param>
            <param name="value">The observed value</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.IGeneratedAlgorithm.NumberOfIterationsDone">
            <summary>
            The number of iterations done from the initial state or since the last change of observed values
            </summary>
            <remarks>
            Changing an observed value will reset this to 0.
            </remarks>
        </member>
        <member name="E:MicrosoftResearch.Infer.IGeneratedAlgorithm.ProgressChanged">
            <summary>
            Fired when the progress of inference changes, typically at the
            end of one iteration of the inference algorithm
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.ProgressChangedEventArgs">
            <summary>
            Provides information about the progress of the inference algorithm, as it
            is being executed.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.ProgressChangedEventArgs.#ctor(System.Int32)">
            <summary>
            Create a ProgressChangedEventArgs with the given iteration number
            </summary>
            <param name="iteration"></param>
        </member>
        <member name="P:MicrosoftResearch.Infer.ProgressChangedEventArgs.Iteration">
            <summary>
            The iteration of inference that has just been completed (the first iteration is 0).
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MMath">
            <summary>
            This class provides mathematical constants and special functions, 
            analogous to System.Math.
            It cannot be instantiated and consists of static members only.
            </summary>
            <remarks>
            <para>
            In order to provide the highest accuracy, some routines return their results in log form or logit form.
            These transformations expand the domain to cover the full range of double-precision values, ensuring 
            all bits of the representation are utilized.  A good example of this is the NormalCdf function, whose 
            value lies between 0 and 1.  Numbers between 0 and 1 use only a small fraction of the capacity of a 
            double-precision number.  The function NormalCdfLogit transforms the result p according to log(p/(1-p)), 
            providing full use of the range from -Infinity to Infinity and (potentially) much higher precision.
            </para><para>
            To get maximal use out of these transformations, you want to stay in the expanded form as long as 
            possible.  Every time you transform into a smaller domain, you lose precision.  Thus helper functions 
            are provided which allow you to perform common tasks directly in the log form and logit form. 
            For logs, you have addition.  For logit, you have averaging. 
            </para>
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.LogisticGaussianQuadratureNodeCount">
            <summary>
            Specifies the number of quadrature nodes that should be used when doing
            Gauss Hermite quadrature for direct KL minimisation 
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.LogisticGaussianVarianceThreshold">
            <summary>
            For integrals with variance greater than this Clenshaw curtis quadrature will be used
            instead of Gauss-Hermite quadrature. 
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.EulerGamma">
            <summary>
            The Euler-Mascheroni Constant.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Digamma1">
            <summary>
            Digamma(1)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Sqrt2PI">
            <summary>
            Math.Sqrt(2*Math.PI)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.InvSqrt2PI">
            <summary>
            1.0/Math.Sqrt(2*Math.PI)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.LnSqrt2PI">
            <summary>
            Math.Log(Math.Sqrt(2*Math.PI)).
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.LnPI">
            <summary>
            Math.Log(Math.PI)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Ln2">
            <summary>
            Math.Log(2)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Sqrt2">
            <summary>
            Math.Sqrt(2)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.SqrtHalf">
            <summary>
            Math.Sqrt(0.5)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_gamma_g">
            <summary>
            Expansion point of the Lanczos method, used in Gamma and GammaLn.
            Must be consistent with <see cref="F:MicrosoftResearch.Infer.Maths.MMath.c_gamma_series"/>.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Zeta2">
            <summary>
            Zeta(2) = Trigamma(1) = pi^2/6.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_trigamma_large">
            <summary>
            The threshold for applying de Moivre's expansion for the trigamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_trigamma_small">
            <summary>
            The threshold for applying de Moivre's expansion for the trigamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.M2Zeta3">
            <summary>
            Tetragamma(1) = -2 Zeta(3)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_tetragamma_large">
            <summary>
            The threshold for applying de Moivre's expansion for the quadgamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_tetragamma_small">
            <summary>
            The threshold for applying de Moivre's expansion for the quadgamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Zeta4">
            <summary>
            Zeta4 = pi^4/90
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Gamma(System.Double)">
            <summary>
            Evaluates Gamma(x), defined as the integral from 0 to x of t^(x-1)*exp(-t) dt.
            </summary>
            <param name="x">Any real value.</param>
            <returns>Gamma(x).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaLn(System.Double)">
            <summary>
            Computes the natural logarithm of the Gamma function.
            </summary>
            <param name="x">A real value >= 0.</param>
            <returns>ln(Gamma(x)).</returns>
            <remarks>This function provides higher accuracy than <c>Math.Log(Gamma(x))</c>, which may fail for large x.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaLn(System.Double,System.Double)">
            <summary>
            Computes the natural logarithm of the multivariate Gamma function.
            </summary>
            <param name="x">A real value >= 0.</param>
            <param name="d">The dimension, an integer > 0.</param>
            <returns>ln(Gamma_d(x))</returns>
            <remarks>The <a href="http://en.wikipedia.org/wiki/Multivariate_gamma_function">multivariate Gamma function</a> 
            is defined as Gamma_d(x) = pi^(d*(d-1)/4)*prod_(i=1..d) Gamma(x + (1-i)/2)</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Digamma(System.Double,System.Double)">
            <summary>
            Derivative of the natural logarithm of the multivariate Gamma function.
            </summary>
            <param name="x">A real value >= 0</param>
            <param name="d">The dimension, an integer > 0</param>
            <returns>digamma_d(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Trigamma(System.Double,System.Double)">
            <summary>
            Second derivative of the natural logarithm of the multivariate Gamma function.
            </summary>
            <param name="x">A real value >= 0</param>
            <param name="d">The dimension, an integer > 0</param>
            <returns>trigamma_d(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Digamma(System.Double)">
            <summary>
            Evaluates Digamma(x), the derivative of ln(Gamma(x)).
            </summary>
            <param name="x">Any real value.</param>
            <returns>Digamma(x).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ComputeDigammaPositiveNotSmall(System.Double)">
            <summary>
            Computes the Digamma(x) when the argument x is positive and not very small.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Trigamma(System.Double)">
            <summary>
            Evaluates Trigamma(x), the derivative of Digamma(x).
            </summary>
            <param name="x">Any real value.</param>
            <returns>Trigamma(x).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Tetragamma(System.Double)">
            <summary>
             Evaluates Tetragamma, the forth derivative of logGamma(x)
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ChooseLn(System.Double,System.Double)">
            <summary>
            Evaluates the natural logarithm of Gamma(n+1)/(Gamma(k+1)*Gamma(n-k+1))
            </summary>
            <param name="n"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ChooseLn(System.Double,System.Double[])">
            <summary>
            Evaluates the natural logarithm of Gamma(n+1)/(prod_i Gamma(k[i]+1))
            </summary>
            <param name="n"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Erfc(System.Double)">
            <summary>
            Computes the complementary error function. This function is defined by 2/sqrt(pi) * integral from x to infinity of exp (-t^2) dt.
            </summary>
            <param name="x">Any real value.</param>
            <returns>The complementary error function at x.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ErfcInv(System.Double)">
            <summary>
            Computes the inverse of the complementary error function, i.e.
            <c>erfcinv(erfc(x)) == x</c>.
            </summary>
            <param name="y">A real number between 0 and 2.</param>
            <returns>A number x such that <c>erfc(x) == y</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfRatio(System.Double)">
            <summary>
            Computes <c>NormalCdf(x)/N(x;0,1)</c> to high accuracy.
            </summary>
            <param name="x">Any real number.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdf(System.Double)">
            <summary>
            Computes the cumulative Gaussian distribution, defined as the
            integral from -infinity to x of N(t;0,1) dt.  
            For example, <c>NormalCdf(0) == 0.5</c>.
            </summary>
            <param name="x">Any real number.</param>
            <returns>The cumulative Gaussian distribution at <paramref name="x"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfLn(System.Double)">
            <summary>
            The natural logarithm of the cumulative Gaussian distribution.
            </summary>
            <param name="x">Any real number.</param>
            <returns>ln(NormalCdf(x)).</returns>
            <remarks>This function provides higher accuracy than <c>Math.Log(NormalCdf(x))</c>, which can fail for x &lt; -7.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfLogit(System.Double)">
            <summary>
            The log-odds of the cumulative Gaussian distribution.
            </summary>
            <param name="x">Any real number.</param>
            <returns>ln(NormalCdf(x)/(1-NormalCdf(x))).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfInv(System.Double)">
            <summary>
            Computes the inverse of the cumulative Gaussian distribution,
            i.e. <c>NormalCdf(NormalCdfInv(p)) == p</c>.
            For example, <c>NormalCdfInv(0.5) == 0</c>.
            This is also known as the Gaussian quantile function.  
            </summary>
            <param name="p">A real number in [0,1].</param>
            <returns>A number x such that <c>NormalCdf(x) == p</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfMomentRatio(System.Int32,System.Double)">
            <summary>
            Computes int_0^infinity t^n N(t;x,1) dt / (n! N(x;0,1))
            </summary>
            <param name="n">The exponent</param>
            <param name="x">Any real number</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdf(System.Double,System.Double,System.Double)">
            <summary>
            Computes the cumulative bivariate normal distribution.
            </summary>
            <param name="x">First upper limit.</param>
            <param name="y">Second upper limit.</param>
            <param name="r">Correlation coefficient.</param>
            <returns><c>phi(x,y,r)</c></returns>
            <remarks>
            The cumulative bivariate normal distribution is defined as
            <c>int_(-inf)^x int_(-inf)^y N([x;y],[0;0],[1 r; r 1]) dx dy</c>
            where <c>N([x;y],[0;0],[1 r; r 1]) = exp(-0.5*(x^2+y^2-2*x*y*r)/(1-r^2))/(2*pi*sqrt(1-r^2))</c>.
            The double integral is transformed into a single integral which is approximated by quadrature.
            Reference: 
            "Numerical Computation of Rectangular Bivariate and Trivariate Normal and t Probabilities"
            Alan Genz, Statistics and Computing, 14 (2004), pp. 151-160
            http://www.math.wsu.edu/faculty/genz/genzhome/research.html
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfLn(System.Double,System.Double,System.Double)">
            <summary>
            Computes the natural logarithm of the cumulative bivariate normal distribution.
            </summary>
            <param name="x">First upper limit.</param>
            <param name="y">Second upper limit.</param>
            <param name="r">Correlation coefficient.</param>
            <returns><c>ln(phi(x,y,r))</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Logistic(System.Double)">
            <summary>
            Computes the logistic function 1/(1+exp(-x)).
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <returns>1/(1+exp(-x)).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogisticLn(System.Double)">
            <summary>
            Compute the natural logarithm of the logistic function, i.e. -log(1+exp(-x)).
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <returns>-log(1+exp(-x)).</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>-log(1+exp(-x))</c>, 
            which can fail for x &lt; -50 and x > 36.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Log1Plus(System.Double)">
            <summary>
            Computes the natural logarithm of 1+x.
            </summary>
            <param name="x">A non-negative real number: 0 &lt;= x &lt;= Inf, or NaN.</param>
            <returns>log(1+x), which is always >= 0.</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(1+x)</c>,
            particularly when <paramref name="x"/> is small.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Log1PlusExp(System.Double)">
            <summary>
            Computes log(1 + exp(x)) to high accuracy.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <returns>log(1+exp(x)), which is always >= 0.</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(1+exp(x))</c>,
            particularly when x &lt; -36 or x > 50.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Log1MinusExp(System.Double)">
            <summary>
            Computes log(1 - exp(x)) to high accuracy.
            </summary>
            <param name="x">A non-positive real number: -Inf &lt;= x &lt;= 0, or NaN.</param>
            <returns>log(1-exp(x)), which is always &lt;= 0.</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(1-exp(x))</c>,
            particularly when x &lt; -7.5 or x > -1e-5.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ExpMinus1(System.Double)">
            <summary>
            Computes the exponential of x and subtracts 1.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <returns>exp(x)-1</returns>
            <remarks>
            This function is more accurate than a direct evaluation of <c>exp(x)-1</c> when x is small.
            It is the inverse function to Log1Plus: <c>ExpMinus1(Log1Plus(x)) == x</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogExpMinus1(System.Double)">
            <summary>
            Computes <c>log(exp(x)-1)</c> for non-negative x.
            </summary>
            <param name="x">A non-negative real number: 0 &lt;= x &lt;= Inf, or NaN.</param>
            <returns><c>log(exp(x)-1)</c></returns>
            <remarks>
            This function is more accurate than a direct evaluation of <c>log(exp(x)-1)</c> when x &lt; 1e-3
            or x > 50.
            It is the inverse function to Log1PlusExp: <c>LogExpMinus1(Log1PlusExp(x)) == x</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogSumExp(System.Double,System.Double)">
            <summary>
            Computes log(exp(x) + exp(y)) to high accuracy.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <param name="y">Any real number from -Inf to Inf, or NaN.</param>
            <returns>log(exp(x)+exp(y)), which is always >= max(x,y).</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(exp(x)+exp(y))</c>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogSumExp(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the log of the sum of exponentials of a list of doubles
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogSumExpSparse(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the log of the sum of exponentials of a list of doubles
            </summary>
            <param name="list"></param>    
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.DiffLogSumExp(System.Double,System.Double,System.Double)">
            <summary>
            Computes log(exp(x)+exp(a))-log(exp(x)+exp(b)) to high accuracy.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <param name="a">A finite real number.</param>
            <param name="b">A finite real number.</param>
            <returns>log(exp(x)+exp(a))-log(exp(x)+exp(b))</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of 
            <c>LogSumExp(x,a)-LogSumExp(x,b)</c>, particularly when x is large.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Logit(System.Double)">
            <summary>
            Computes the log-odds function log(p/(1-p)).
            </summary>
            <param name="p">Any number between 0 and 1, inclusive.</param>
            <returns>log(p/(1-p))</returns>
            <remarks>This function is the inverse of the logistic function, 
            i.e. <c>Logistic(Logit(p)) == p.</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogitFromLog(System.Double)">
            <summary>
            Compute log(p/(1-p)) from log(p).
            </summary>
            <param name="logp">Any number between -infinity and 0, inclusive.</param>
            <returns>log(exp(logp)/(1-exp(logp))) = -log(exp(-logp)-1).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Collections.Generic.IList{System.Double})">
            <summary>
            Exponentiate array elements and normalize to sum to 1.
            </summary>
            <param name="x">May be +/-infinity</param>
            <returns>A Vector p where <c>p[k] = exp(x[k])/sum_j exp(x[j])</c></returns>
            <remarks>Sparse lists and vectors are handled efficiently</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Log1PlusExpGaussian(System.Double,System.Double)">
            <summary>
            Evaluates E[log(1+exp(x))] under a Gaussian distribution with specified mean and variance.
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogisticGaussian(System.Double,System.Double)">
            <summary>
            Calculate sigma(m,v) = \int N(x;m,v) logistic(x) dx
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>The value of this special function.</returns>
            <remarks><para>
            Note <c>1-LogisticGaussian(m,v) = LogisticGaussian(-m,v)</c> which is more accurate.
            </para><para>
            For large v we can use the big v approximation <c>\sigma(m,v)=normcdf(m/sqrt(v+pi^2/3))</c>.
            For small and moderate v we use Gauss-Hermite quadrature.
            For moderate v we first find the mode of the (log concave) function since this may be quite far from m.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogisticGaussianDerivative(System.Double,System.Double)">
            <summary>
            Calculate <c>\sigma'(m,v)=\int N(x;m,v)logistic'(x) dx</c>
            </summary>
            <param name="mean">Mean.</param>
            <param name="variance">Variance.</param>
            <returns>The value of this special function.</returns>
            <remarks><para>
            For large v we can use the big v approximation <c>\sigma'(m,v)=N(m,0,v+pi^2/3)</c>.
            For small and moderate v we use Gauss-Hermite quadrature.
            For moderate v we first find the mode of the (log concave) function since this may be quite far from m.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogisticGaussianDerivative2(System.Double,System.Double)">
            <summary>
            Calculate <c>\sigma''(m,v)=\int N(x;m,v)logistic''(x) dx</c>
            </summary>
            <param name="mean">Mean.</param>
            <param name="variance">Variance.</param>
            <returns>The value of this special function.</returns>
            <remarks><para>
            For large v we can use the big v approximation <c>\sigma'(m,v)=-m/(v+pi^2/3)*N(m,0,v+pi^2/3)</c>.
            For small and moderate v we use Gauss-Hermite quadrature.
            The function is multimodal so mode finding is difficult and probably won't help.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Max(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the maximum of a list of doubles
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Min(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the minimum of a list of doubles
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.IndexOfMinimum``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns the index of the minimum element, or -1 if empty.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.IndexOfMaximum``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns the index of the maximum element, or -1 if empty.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.IndexOfMaximumDouble(System.Collections.Generic.IList{System.Double})">
            <summary>
            Returns the index of the maximum element, or -1 if empty.
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Median(System.Double[])">
            <summary>
            Returns the median of the array elements.
            </summary>
            <param name="array"></param>
            <returns>The median ignoring NaNs.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Median(System.Double[],System.Int32,System.Int32)">
            <summary>
            Returns the median of elements in a subrange of an array.
            </summary>
            <param name="array"></param>
            <param name="start">Starting index of the range.</param>
            <param name="length">The number of elements in the range.</param>
            <returns>The median of array[start:(start+length-1)], ignoring NaNs.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.RemoveNaNs(System.Double[],System.Int32,System.Int32)">
            <summary>
            Given an array, returns a new array with all NANs removed.
            </summary>
            <param name="array">The source array</param>
            <param name="start">The start index in the source array</param>
            <param name="length">How many items to look at in the source array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.AbsDiff(System.Double,System.Double,System.Double)">
            <summary>
            Returns the relative distance between two numbers.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>abs(x - y)/(abs(x) + rel)</c>. 
            Matching infinities give zero.
            </returns>
            <remarks>
            This routine is often used to measure the error of y in estimating x.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.AbsDiff(System.Double,System.Double)">
            <summary>
            Returns the distance between two numbers.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns><c>abs(x - y)</c>. 
            Matching infinities give zero.
            </returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_gamma_series">
            <summary>
            Coefficients of the Lanczos series for Gamma, determined by
            the expansion point <see cref="F:MicrosoftResearch.Infer.Maths.MMath.c_gamma_g"/>.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_digamma_series">
            <summary>
            Coefficients of de Moivre's expansion for the digamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_trigamma_series">
            <summary>
            Coefficients of de Moivre's expansion for the trigamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_tetragamma_series">
            <summary>
            Coefficients of de Moivre's expansion for the quadgamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_normcdfln_series">
            <summary>
            Coefficients of the asymptotic expansion of NormalCdfLn.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_normcdf_table">
            <summary>
            NormCdf(x)/NormPdf(x) for x = 0, -1, -2, -3, ..., -16
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SerializableMatrix">
            <summary>
            Helper class for serializing Matrices.  To serialize a Matrix, first cast it to SerializableMatrix.  After deserializing, cast back to Matrix.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Undirected">
            <summary>
            Provides useful factors for undirected models.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Undirected.Potts(System.Int32,System.Int32,System.Double)">
            <summary>
            Implements an integer Potts potential which has the value of 1 if a=b and exp(-logCost) otherwise.
            </summary>
            <remarks>
            See http://en.wikipedia.org/wiki/Potts_model
            </remarks>
            <param name="a"></param>
            <param name="b"></param>
            <param name="logCost"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Undirected.Potts(System.Boolean,System.Boolean,System.Double)">
            <summary>
            Implements an boolean Potts potential which has the value of 1 if a=b and exp(-logCost) otherwise.
            </summary>
            <remarks>
            See http://en.wikipedia.org/wiki/Potts_model
            </remarks>
            <param name="a"></param>
            <param name="b"></param>
            <param name="logCost"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Undirected.Linear(System.Int32,System.Int32,System.Double)">
            <summary>
            Implements a linear difference potential which has the value of exp( -|a-b|* logUnitCost ).
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="logUnitCost"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Undirected.LinearTrunc(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Implements a truncated linear difference potential which has the value of  exp( - min( |a-b|* logUnitCost, maxCost) ).
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="logUnitCost"></param>
            <param name="maxCost"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PottsIntOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Undirected.Potts(System.Int32,System.Int32,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PottsIntOp.AMaxConditional(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Double,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <param name="logCost">Constant value for 'logCost'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PottsIntOp.BMaxConditional(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Double,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="logCost">Constant value for 'logCost'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PottsBoolOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Undirected.Potts(System.Boolean,System.Boolean,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PottsBoolOp.AMaxConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <param name="logCost">Constant value for 'logCost'.</param>
            <returns></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PottsBoolOp.BMaxConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="logCost">Constant value for 'logCost'.</param>
            <returns></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LinearOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Undirected.Linear(System.Int32,System.Int32,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LinearOp.AMaxConditional(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Double,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <param name="logUnitCost">Constant value for 'logUnitCost'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LinearOp.BMaxConditional(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Double,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="logUnitCost">Constant value for 'logUnitCost'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LinearTruncOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Undirected.LinearTrunc(System.Int32,System.Int32,System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LinearTruncOp.AMaxConditional(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <param name="logUnitCost">Constant value for 'logUnitCost'.</param>
            <param name="maxCost">Constant value for 'maxCost'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LinearTruncOp.BMaxConditional(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="logUnitCost">Constant value for 'logUnitCost'.</param>
            <param name="maxCost">Constant value for 'maxCost'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'product'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[sum_(a,b) p(a,b) factor(product,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            Because the factor is deterministic, 'product' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(b) p(b) log(sum_product p(product) factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_B">Previous outgoing message to 'B'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            Because the factor is deterministic, 'product' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(a) p(a) log(sum_product p(product) factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            The formula is <c>exp(sum_(a) p(a) log(factor(product,a,b)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_B">Previous outgoing message to 'B'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' with 'product' integrated out.
            The formula is <c>sum_product p(product) factor(product,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Gate">
            <summary>
            Factors for handling gates.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.Enter``1(System.Int32,``0)">
            <summary>
            Enter factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="selector"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartial``1(System.Int32,``0,System.Int32[])">
            <summary>
            Enter partial factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="selector"></param>
            <param name="value"></param>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartialTwo``1(System.Boolean,System.Boolean,``0,System.Int32[])">
            <summary>
            Enter partial factor with two cases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="case0"></param>
            <param name="case1"></param>
            <param name="value"></param>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MicrosoftResearch.Infer.Factors.Gate.EnterOne``1(System.Int32,``0,System.Int32)" -->
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.Exit``1(System.Boolean[],``0[])">
            <summary>
            Exit factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cases"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ExitTwo``1(System.Boolean,System.Boolean,``0[])">
            <summary>
            Exit factor with two cases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="case0"></param>
            <param name="case1"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ExitRandom``1(System.Boolean[],``0[])">
            <summary>
            Exit random factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cases"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ExitRandomTwo``1(System.Boolean,System.Boolean,``0[])">
            <summary>
            Exit random factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="case0"></param>
            <param name="case1"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ExitingVariable``1(``0,``0@)">
            <summary>
            Exiting variable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Def"></param>
            <param name="Marginal"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ReplicateExiting``1(``0,System.Int32)">
            <summary>
            Replicate an exiting variable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Def"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.Cases(System.Boolean)">
            <summary>
            Boolean cases factor
            </summary>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.CasesBool(System.Boolean,System.Boolean@,System.Boolean@)">
            <summary>
            Boolean cases factor expanded into elements
            </summary>
            <param name="b"></param>
            <param name="case0">case 0 (true)</param>
            <param name="case1">case 1 (false)</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.CasesInt(System.Int32,System.Int32)">
            <summary>
            Integer cases factor
            </summary>
            <param name="i">index</param>
            <param name="count">number of cases</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CasesOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.Cases(System.Boolean)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.CasesAverageConditional``1(MicrosoftResearch.Infer.Distributions.Bernoulli,``0)">
            <summary>
            EP message to 'cases'.
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int f(cases,x) q(x) dx</c> where <c>x = (b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.BAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="cases">Incoming message from 'cases'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.CasesAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Bernoulli,``0)">
            <summary>
            VMP message to 'cases'.
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.BAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="cases">Incoming message from 'cases'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.AverageLogFactor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="cases">Incoming message from 'cases'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (cases,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CasesBoolOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.CasesBool(System.Boolean,System.Boolean@,System.Boolean@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.Case0AverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'case0'
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'case0' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'case0' as the random arguments are varied.
            The formula is <c>proj[p(case0) sum_(b) p(b) factor(b,case0,case1)]/p(case0)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.Case1AverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'case1'
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'case1' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'case1' as the random arguments are varied.
            The formula is <c>proj[p(case1) sum_(b) p(b) factor(b,case0,case1)]/p(case1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="case0">Incoming message from 'case0'.</param>
            <param name="case1">Incoming message from 'case1'.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(case0,case1) p(case0,case1) factor(b,case0,case1)]/p(b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="case0">Incoming message from 'case0'.</param>
            <param name="case1">Incoming message from 'case1'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(case0,case1,b) p(case0,case1,b) factor(b,case0,case1))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.Case0AverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'case0'
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'case0' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'case0'.
            The formula is <c>exp(sum_(b) p(b) log(factor(b,case0,case1)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.Case1AverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'case1'
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'case1' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'case1'.
            The formula is <c>exp(sum_(b) p(b) log(factor(b,case0,case1)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="case0">Incoming message from 'case0'.</param>
            <param name="case1">Incoming message from 'case1'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            The formula is <c>exp(sum_(case0,case1) p(case0,case1) log(factor(b,case0,case1)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="case0">Incoming message from 'case0'.</param>
            <param name="case1">Incoming message from 'case1'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IntCasesOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.CasesInt(System.Int32,System.Int32)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.CasesAverageConditional``1(MicrosoftResearch.Infer.Distributions.Discrete,``0)">
            <summary>
            EP message to 'casesInt'.
            </summary>
            <param name="i">Incoming message from 'i'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'casesInt'.
            The formula is <c>int f(casesInt,x) q(x) dx</c> where <c>x = (i)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.IAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'i'.
            </summary>
            <param name="cases">Incoming message from 'casesInt'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'i'.
            The formula is <c>int f(i,x) q(x) dx</c> where <c>x = (casesInt)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="cases">Incoming message from 'casesInt'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Int32)">
            <summary>
            Evidence message for Gibbs.
            </summary>
            <param name="cases">Incoming message from 'casesInt'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.CasesAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Discrete,``0)">
            <summary>
            VMP message to 'casesInt'.
            </summary>
            <param name="i">Incoming message from 'i'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'casesInt'.
            The formula is <c>int log(f(casesInt,x)) q(x) dx</c> where <c>x = (i)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.IAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'i'.
            </summary>
            <param name="cases">Incoming message from 'casesInt'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'i'.
            The formula is <c>int log(f(i,x)) q(x) dx</c> where <c>x = (casesInt)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.AverageLogFactor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="cases">Incoming message from 'casesInt'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="i">Incoming message from 'i'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (casesInt,i)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteUniform">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.DiscreteUniform(System.Int32)"/>, given random arguments to the function.
            </summary>
            <remarks>Factor is f(sample, size) = 1(sample &lt; size)/size</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogAverageFactor(System.Int32,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="size">Constant value for 'size'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,size))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogEvidenceRatio(System.Int32,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="size">Constant value for 'size'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,size))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="size">Incoming message from 'size'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(size) p(size) factor(sample,size))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="size">Incoming message from 'size'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(size) p(size) factor(sample,size))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,size))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="size">Incoming message from 'size'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,size) p(sample,size) factor(sample,size) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="size">Constant value for 'size'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,size) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SampleAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="size">Constant value for 'size'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="size">Incoming message from 'size'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(size) p(size) factor(sample,size)]/p(sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SizeAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'size'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'size' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SizeAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'size'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'size' as the random arguments are varied.
            The formula is <c>proj[p(size) sum_(sample) p(sample) factor(sample,size)]/p(size)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="size">Constant value for 'size'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,size))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="size">Incoming message from 'size'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(size) p(size) log(factor(sample,size))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.AverageLogFactor(System.Int32,System.Int32)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="size">Constant value for 'size'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,size))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="size">Incoming message from 'size'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,size) p(sample,size) log(factor(sample,size))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SampleAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="size">Constant value for 'size'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="size">Incoming message from 'size'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(size) p(size) log(factor(sample,size)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SizeAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'size'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'size' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteUniform.SizeAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'size'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'size'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,size)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SampleFromPseudoCounts(MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sampleFromPseudoCounts'.</param>
            <param name="pseudoCounts">Constant value for 'pseudoCount'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sampleFromPseudoCounts) p(sampleFromPseudoCounts) factor(sampleFromPseudoCounts,pseudoCount))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sampleFromPseudoCounts'.</param>
            <param name="pseudoCounts">Constant value for 'pseudoCount'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sampleFromPseudoCounts) p(sampleFromPseudoCounts) factor(sampleFromPseudoCounts,pseudoCount) / sum_sampleFromPseudoCounts p(sampleFromPseudoCounts) messageTo(sampleFromPseudoCounts))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sampleFromPseudoCounts'.</param>
            <param name="pseudoCounts">Constant value for 'pseudoCount'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sampleFromPseudoCounts) p(sampleFromPseudoCounts) log(factor(sampleFromPseudoCounts,pseudoCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sampleFromPseudoCounts'.</param>
            <param name="pseudoCounts">Constant value for 'pseudoCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sampleFromPseudoCounts,pseudoCount))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sampleFromPseudoCounts'.</param>
            <param name="pseudoCounts">Constant value for 'pseudoCount'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sampleFromPseudoCounts,pseudoCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sampleFromPseudoCounts'.</param>
            <param name="pseudoCounts">Constant value for 'pseudoCount'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sampleFromPseudoCounts,pseudoCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.SampleAverageConditional(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            EP message to 'sampleFromPseudoCounts'
            </summary>
            <param name="pseudoCounts">Constant value for 'pseudoCount'.</param>
            <returns>The outgoing EP message to the 'sampleFromPseudoCounts' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sampleFromPseudoCounts' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletFromPseudoCountsOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            VMP message to 'sampleFromPseudoCounts'
            </summary>
            <param name="pseudoCounts">Constant value for 'pseudoCount'.</param>
            <returns>The outgoing VMP message to the 'sampleFromPseudoCounts' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sampleFromPseudoCounts' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.DirichletSymmetric(System.Int32,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="alpha">Incoming message from 'alpha'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="probMeanLog">Buffer for E[log(prob)]</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(prob,alpha) p(prob,alpha) log(factor(prob,alpha,K))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="alpha"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="alpha">Incoming message for 'alpha'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>int p(alpha) log(factor(prob,alpha,K))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="alpha">Incoming message for 'alpha'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>int p(alpha) log(factor(prob,alpha,K))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="alpha">Incoming message for 'alpha'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>int p(alpha) log(factor(prob,alpha,K))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="alpha">Constant value for 'alpha'.</param>
            <param name="probMeanLog">Buffer for E[log(prob)]</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(prob) p(prob) log(factor(prob,alpha,K))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.GradientAndValueAtPoint(System.Double,System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the gradient and value of the KL divergence for this factor
            </summary>
            <param name="a2">Prior shape</param>
            <param name="b2">Prior rate</param>
            <param name="x">A vector of the variational posterior parameters. x[1]=log(shape), x[2]=log(rate)</param>
            <param name="SumElogP">Sum E[ log(prob_k) ]. Cached for efficiency</param>
            <param name="grad">Vector to fill with the gradient</param>
            <param name="K">Dimensionality</param>
            <returns>KL divergence</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbMeanLogInit(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Initialisation of buffer for E[log(prob)]
            </summary>
            <param name="prob">Incoming message from 'prob'</param>
            <returns>Correct size message.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbMeanLogInit(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Initialisation of buffer for E[log(prob)]
            </summary>
            <param name="prob">Incoming message from 'prob'</param>
            <returns>Correct size message.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbMeanLog(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Buffer for E[log(prob)]
            </summary>
            <param name="prob">Incoming message from 'prob'</param>
            <param name="result">Will be the returned value. </param>
            <returns>E[log(prob)]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbMeanLog(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Buffer for E[log(prob)]
            </summary>
            <param name="prob">Incoming message from 'prob'</param>
            <param name="result">Will be the returned value. </param>
            <returns>E[log(prob)]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AlphaAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'alpha'
            </summary>
            <param name="prob">Incoming message from 'prob'.</param>
            <param name="alpha">Incoming message from 'alpha'.</param>
            <param name="probMeanLog">Buffer for E[log(prob)].</param>
            <param name="to_Alpha">Previous message sent to 'alpha'</param>
            <returns>Message to alpha</returns>
            <remarks><para>
            Optimal message calculated by minimising local KL divergence using LBFGS. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AlphaAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            VMP message to 'alpha'
            </summary>
            <param name="prob">Constant value for prob 'prob'.</param>
            <param name="alpha">Incoming message from 'alpha'.</param>
            <param name="probMeanLog">Buffer for E[log(x)] values of 'prob'</param>
            <returns>Message to alpha</returns>
            <remarks><para>
            Optimal message calculated by minimising local KL divergence using LBFGS. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AlphaAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            VMP message to 'alpha'
            </summary>
            <param name="prob">Constant value for prob 'prob'.</param>
            <param name="alpha">Incoming message from 'alpha'.</param>
            <param name="probMeanLog">Buffer for E[log(x)] values of 'prob'</param>
            <returns>Message to alpha</returns>
            <remarks><para>
            Optimal message calculated by minimising local KL divergence using LBFGS. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AlphaAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'alpha'
            </summary>
            <param name="prob">Constant value for prob 'prob'.</param>
            <param name="alpha">Incoming message from 'alpha'.</param>
            <param name="to_Alpha">Previous message sent to 'alpha'</param>
            <returns>Message to alpha</returns>
            <remarks><para>
            Optimal message calculated by minimising local KL divergence using LBFGS. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'prob'
            </summary>
            <param name="alpha">Constant value for 'alpha'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is simply the definition of the factor since 
            alpha is fixed.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'prob'
            </summary>
            <param name="alpha">Incoming message from 'alpha'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'prob'.
            The formula is <c>exp(sum_(alpha) p(alpha) log(factor(prob,alpha,K)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="alpha"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'prob'
            </summary>
            <param name="alpha">Incoming message from 'alpha'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'prob'.
            The formula is <c>exp(sum_(alpha) p(alpha) log(factor(prob,alpha,K)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="alpha">Incoming message from 'alpha'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(prob,alpha) p(prob,alpha) factor(prob,alpha,K))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="alpha"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.LogAverageFactor(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="alpha">Constant value for 'alpha'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log factor(prob,alpha,K))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.LogEvidenceRatio(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="alpha">Constant value for 'alpha'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log factor(prob,alpha,K))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AverageLogFactor(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="alpha">Constant value for 'alpha'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log factor(prob,alpha,K))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Incoming message from 'prob'.</param>
            <param name="alpha">Constant value for 'alpha'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log int_prob p(prob) factor(prob,alpha,K))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Incoming message from 'prob'.</param>
            <param name="alpha">Constant value for 'alpha'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log int_prob p(prob) factor(prob,alpha,K))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'prob'
            </summary>
            <param name="alpha">Constant value for 'alpha'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'prob' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.AlphaAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'alpha'
            </summary>
            <param name="alpha">Incoming message from 'alpha'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'alpha' as the random arguments are varied.
            The formula is <c>proj[p(alpha) sum_(prob) p(prob) factor(prob,alpha,K)]/p(alpha)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="alpha"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletSymmetricOp.ProbAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'prob'
            </summary>
            <param name="alpha">Incoming message from 'alpha'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'prob' as the random arguments are varied.
            The formula is <c>proj[p(prob) sum_(alpha) p(alpha) factor(prob,alpha,K)]/p(prob)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="alpha"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DirichletOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.DirichletFromMeanAndTotalCount(MicrosoftResearch.Infer.Maths.Vector,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.DirichletOp.damping">
            <summary>
            How much damping to use to prevent improper messages. Higher values result in more damping. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(prob,mean,totalCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(prob,mean,totalCount) p(prob,mean,totalCount) log(factor(prob,mean,totalCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(prob,totalCount) p(prob,totalCount) log(factor(prob,mean,totalCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(totalCount) p(totalCount) log(factor(prob,mean,totalCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(prob,mean) p(prob,mean) log(factor(prob,mean,totalCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(prob) p(prob) log(factor(prob,mean,totalCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(mean,totalCount) p(mean,totalCount) log(factor(prob,mean,totalCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(mean) p(mean) log(factor(prob,mean,totalCount))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'prob'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'prob' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'prob'.
            The formula is <c>exp(sum_(mean,totalCount) p(mean,totalCount) log(factor(prob,mean,totalCount)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            VMP message to 'prob'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'prob' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'prob'.
            The formula is <c>exp(sum_(mean) p(mean) log(factor(prob,mean,totalCount)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'prob'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'prob' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'prob'.
            The formula is <c>exp(sum_(totalCount) p(totalCount) log(factor(prob,mean,totalCount)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            VMP message to 'prob'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'prob' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'prob' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="to_mean">Previous outgoing message to 'mean'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(totalCount) p(totalCount) log(factor(prob,mean,totalCount)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="to_mean">Previous outgoing message to 'mean'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_mean">Previous outgoing message to 'mean'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(prob) p(prob) log(factor(prob,mean,totalCount)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_mean">Previous outgoing message to 'mean'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(totalCount,prob) p(totalCount,prob) log(factor(prob,mean,totalCount)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.CalculateGradientForMean(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Helper function to calculate gradient of the KL divergence with respect to the mean of the Dirichlet. 
            </summary>
            <param name="meanPseudoCount">Pseudocount vector of the incoming message from 'mean'</param>
            <param name="totalCount">Incoming message from 'totalCount'</param>
            <param name="meanLogProb">E[log(prob)]</param>
            <returns>Gradient of the KL divergence with respect to the mean of the Dirichlet</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'totalCount'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="to_totalCount">Previous outgoing message to 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'totalCount' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'totalCount' conditioned on the given values.
            </para>
            <para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
            sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'totalCount'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_totalCount">Previous outgoing message to 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'totalCount' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'totalCount'.
            The formula is <c>exp(sum_(prob) p(prob) log(factor(prob,mean,totalCount)))</c>.
            </para>
            <para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
            sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'totalCount'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="to_totalCount">Previous outgoing message to 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'totalCount' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'totalCount'.
            The formula is <c>exp(sum_(mean) p(mean) log(factor(prob,mean,totalCount)))</c>.
            </para><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
            sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'totalCount'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_totalCount">Previous outgoing message to 'totalCount'.</param>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
            sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageLogarithmHelper(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            VMP message to 'totalCount'. This functionality is separated out to allow use by BetaOp. 
            </summary>
            <param name="meanPseudoCount">Pseudocount of incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="meanLogProb">E[log(prob)] from incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
            sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanMessageExpectations(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,System.Double[]@,System.Double[]@,System.Double[]@)">
            <summary>
            Perform the quadrature required for the Nonconjugate VMP message to 'mean'
            </summary>
            <param name="meanQPseudoCount">Incoming message from 'mean'.</param>
            <param name="totalCountQ">Incoming message from 'totalCount'.</param>
            <param name="EELogGamma">Array to be filled with E[LogGamma(s*m_k)].</param>
            <param name="EELogMLogGamma">Array to be filled with E[Log(m_k)*LogGamma(s*m_k)].</param>
            <param name="EELogOneMinusMLogGamma">Array to be filled with E[Log(1-m_k)*LogGamma(s*m_k)].</param>
            <remarks><para>
            All three arrays are calculated simultaneously for efficiency. The quadrature over 
            'totalCount' (which is Gamma-distributed) is peformed by a change of variable x=log(s)
            followed by Gauss-Hermite quadrature. The quadrature over m is performed using 
            Gauss-Legendre. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountMessageExpectations(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,System.Double[]@,System.Double[]@,System.Double[]@)">
            <summary>
            Perform the quadrature required for the Nonconjugate VMP message to 'totalCount'
            </summary>
            <param name="meanQPseudoCount">Incoming message from 'mean'.</param>
            <param name="totalCountQ">Incoming message from 'totalCount'.</param>
            <param name="EELogGamma">Array to be filled with E[LogGamma(s*m_k)].</param>
            <param name="EELogSLogGamma">Array to be filled with E[Log(s)*LogGamma(s*m_k)].</param>
            <param name="EEMSDigamma">Array to be filled with E[s*m_k*Digamma(s*m_k)].</param>
            <remarks><para>
            All three arrays are calculated simultaneously for efficiency. The quadrature over 
            'totalCount' (which is Gamma-distributed) is peformed by a change of variable x=log(s)
            followed by Gauss-Hermite quadrature. The quadrature over m is performed using 
            Gauss-Legendre. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.EvidenceMessageExpectations(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Perform the quadrature required for the VMP evidence message
            </summary>
            <param name="meanQ">Incoming message from m='mean'.</param>
            <param name="totalCountQ">Incoming message from s='totalCount'.</param>
            <returns>Vector of E[ LogGamma(s*m_k)].</returns>
            <remarks><para>
            The quadrature over 'totalCount' (which is Gamma-distributed) is 
            peformed by a change of variable x=log(s) followed by Gauss-Hermite 
            quadrature. The quadrature over m is performed using Gauss-Legendre. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(prob,mean,totalCount))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Incoming message from 'prob'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(prob,mean,totalCount))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Incoming message from 'prob'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="to_prob">Previous outgoing message to 'prob'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(prob) p(prob) factor(prob,mean,totalCount))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'prob'
            </summary>
            <param name="prob">Incoming message from 'prob'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'prob' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(prob,mean,totalCount) p(prob,mean,totalCount) factor(prob,mean,totalCount))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(prob,totalCount) p(prob,totalCount) factor(prob,mean,totalCount))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(totalCount) p(totalCount) factor(prob,mean,totalCount))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(prob,mean) p(prob,mean) factor(prob,mean,totalCount))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(mean,totalCount) p(mean,totalCount) factor(prob,mean,totalCount))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.LogAverageFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(mean) p(mean) factor(prob,mean,totalCount))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'prob'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'prob' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'prob' as the random arguments are varied.
            The formula is <c>proj[p(prob) sum_(mean,totalCount) p(mean,totalCount) factor(prob,mean,totalCount)]/p(prob)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            EP message to 'prob'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>The outgoing EP message to the 'prob' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'prob' as the random arguments are varied.
            The formula is <c>proj[p(prob) sum_(mean) p(mean) factor(prob,mean,totalCount)]/p(prob)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'prob'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'prob' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'prob' as the random arguments are varied.
            The formula is <c>proj[p(prob) sum_(totalCount) p(totalCount) factor(prob,mean,totalCount)]/p(prob)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageConditional(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            EP message to 'prob'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>The outgoing EP message to the 'prob' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'prob' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(totalCount) p(totalCount) factor(prob,mean,totalCount)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(prob) p(prob) factor(prob,mean,totalCount)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(totalCount,prob) p(totalCount,prob) factor(prob,mean,totalCount)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'totalCount'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'totalCount' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'totalCount'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'totalCount' as the random arguments are varied.
            The formula is <c>proj[p(totalCount) sum_(prob) p(prob) factor(prob,mean,totalCount)]/p(totalCount)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'totalCount'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'totalCount' as the random arguments are varied.
            The formula is <c>proj[p(totalCount) sum_(mean) p(mean) factor(prob,mean,totalCount)]/p(totalCount)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'totalCount'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="totalCount">Incoming message from 'totalCount'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="prob">Incoming message from 'prob'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'totalCount' as the random arguments are varied.
            The formula is <c>proj[p(totalCount) sum_(mean,prob) p(mean,prob) factor(prob,mean,totalCount)]/p(totalCount)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="totalCount"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="prob"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.RotateOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Rotate(System.Double,System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BooleanAndOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.And(System.Boolean,System.Boolean)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_() p() factor(and,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(and,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AverageLogFactor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Incoming message from 'and'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(and) p(and) factor(and,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'and'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'and' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'and'.
            The formula is <c>int f(and,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'and'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'and' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'and'.
            The formula is <c>int f(and,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'and'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'and' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'and'.
            The formula is <c>int f(and,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Incoming message from 'and'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(and,a,b) p(and,a,b) factor(and,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Incoming message from 'and'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(and,b) p(and,b) factor(and,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Incoming message from 'and'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(and,a) p(and,a) factor(and,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(and,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(and,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(and,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Incoming message from 'and'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(and,a,b) p(and,a,b) factor(and,a,b) / sum_and p(and) messageTo(and))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(and,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(and,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(and,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'and'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'and' argument.</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'and' as the random arguments are varied.
            The formula is <c>proj[sum_(a,b) p(a,b) factor(and,a,b)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'and'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'and' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'and'.
            The formula is <c>int log(f(and,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'and'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'and' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'and'.
            The formula is <c>int log(f(and,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.MethodFullNameToString(System.Reflection.MethodBase)">
            <summary>
            Get string of the form "typeName.methodName".
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.MethodSignatureToString(System.Reflection.MethodInfo)">
            <summary>
            Get a short string describing the signature of a method.
            </summary>
            <param name="method"></param>
            <returns>A string of the form "methodName&lt;types>(parameters)"</returns>
            <remarks>From the C# 3.0 specification sec 1.6.6: 
            The signature of a method consists of the name of the method, 
            the number of type parameters and the number, modifiers, and types of its parameters. 
            The signature of a method does not include the return type.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.JoinColumns(System.String[][])">
            <summary>
            Create a string denoting a multi-line table with multiple columns.
            </summary>
            <param name="lines">lines[column][line] is a single text line in the column.</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise">
            <summary>
            White noise kernel function. This can be added to other kernels using the
            SummationKernel class to provide measurement noise
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.#ctor">
            <summary>
            Default constructor for white noise kernel function
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.#ctor(System.Double)">
            <summary>
            Construct white noise kernel function from log noise standard deviation
            </summary>
            <param name="logNoiseSD">Log noise standard deviation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GammaEstimator">
            <summary>
            Estimates a Gamma distribution from samples.
            </summary>
            <remarks><code>
            The distribution is estimated via moment matching (not maximum-likelihood).
            In the one-dimensional case,
            E[x] = (a+1)/b
            var(x) = (a+1)/b^2
            b = E[x]/var(x)
            a = E[x]^2/var(x) - 1
            </code></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GammaEstimator.mva">
            <summary>
            Where to accumulate means and variances
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.#ctor">
            <summary>
            Creates a new Gamma estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Retrieves the Gamma estimator
            </summary>
            <param name="result">Where to put the result</param>
            <returns>The resulting distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Add(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Adds a Gamma distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Add(System.Double)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="value">The sample to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Add(System.Double,System.Double)">
            <summary>
            Adds a sample with a given weight to the estimator
            </summary>
            <param name="value">The sample to add</param>
            <param name="weight">The weight of the sample</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.SetTo(MicrosoftResearch.Infer.Distributions.GammaEstimator)">
            <summary>
            Sets the state of this estimator from the supplied estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Clone">
            <summary>
            Returns a clone of this Gamma estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FileArray`1">
            <summary>
            An IArray where each element is stored as a disk file.
            </summary>
            <typeparam name="T">The element type</typeparam>
            <remarks><para>
            The elements (whose values do not equal default(T)) are stored as individual files in a temp folder.
            Elements equal to default(T) are not stored.
            A FileArray may contain FileArrays as elements: these are called child FileArrays.
            Child FileArrays must be created using the special constructor.
            When a FileArray (that is not a child) is Disposed or garbage collected, the folder is deleted.
            A child FileArray is deleted only when its parent is deleted.
            Thus if the program exits normally, all temp folders should be deleted.
            However, if the program halts with an exception, temp folders will not be deleted and must be cleaned up manually.
            </para><para>
            Be careful when modifying elements of the FileArray in place.  If fa is a FileArray, then the syntax
            <code>fa[i][j] = 0;</code> or <code>fa[i].property = 0;</code> will not have any effect.  This happens
            because <code>fa[i]</code> reads the element from disk but does not write it back again.  You must explicitly
            read the element, modify it, then write it back like so: <code>T item = fa[i];  item.property=0;  fa[i] = item;</code>
            </para>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FileArray`1.#ctor(System.String,System.Int32,System.Func{System.Int32,`0})">
            <summary>
            Create a file array
            </summary>
            <param name="folder">Temporary folder for storing data.  Will be deleted when the FileArray is disposed.</param>
            <param name="count"></param>
            <param name="func"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a priority queue filled with count items equal to default(T).
            </summary>
            <param name="count"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Int32)">
            <summary>
            Create a priority queue filled with count items equal to default(T).
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0},System.Action{`0,System.Int32})">
            <summary>
            Create a priority queue initialized with the contents of list.
            </summary>
            <param name="list"></param>
            <param name="comparer"></param>
            <param name="moved"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a priority queue initialized with the contents of list.
            </summary>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a priority queue initialized with the contents of list.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Action{`0,System.Int32})">
            <summary>
            Create a priority queue initialized with the contents of list.
            </summary>
            <param name="list"></param>
            <param name="moved"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.Add(`0)">
            <summary>
            Add a new item to the queue.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add several new items to the queue.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.Changed(System.Int32)">
            <summary>
            Reposition node i to restore the heap property.
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.SiftUp(System.Int32)">
            <summary>
            Move Items[i] upward until it is greater than or equal to its parent.
            </summary>
            <param name="i">An index into Items.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.SiftDown(System.Int32)">
            <summary>
            Move Items[i] downward until it is less than or equal to its children.
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.SiftAll">
            <summary>
            Rearrange all items to satisfy the heap property.
            </summary>
        </member>
        <member name="E:MicrosoftResearch.Infer.Collections.PriorityQueue`1.Moved">
            <summary>
            Raised when an item has changed position.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SparseVector">
            <summary>
            A one-dimensional vector of double values, optimised for the case where many of the 
            elements share a common value (which need not be zero).
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.FromXml(System.Xml.XmlReader)">
            <summary>
            Read a SparseVector from XML of the form <example>&lt;SparseVector&gt;&lt;Tolerance%gt;0.1&lt;/Tolerance%gt;&lt;SparseElement&gt;...&lt;/SparseElement&gt;...&lt;/SparseVector&gt;</example>
            </summary>
            <param name="reader"></param>
            <returns>SparseVector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Writer XML of the form <example>&lt;SparseVector&gt;&lt;double&gt;1.2&lt;/double&gt;...&lt;/SparseVector&gt;</example>
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Zero(System.Int32)">
            <summary>
            Create a sparse vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Constant(System.Int32,System.Double)">
            <summary>
            Create a sparse vector of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Copy(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creator a sparse vector as a copy of another vector (which may not be sparse)
            </summary>
            <param name="that">The source vector - can be dense or sparse</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.FromArray(System.Double[])">
            <summary>
            Constructs a sparse vector from a dense array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.FromSparseValues(System.Int32,System.Double,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{System.Double}})">
            <summary>
            Constructs a sparse vector from a sorted list of sparse elements.
            </summary>
            <param name="count">Count for result</param>
            <param name="commonValue">Common value</param>
            <param name="sortedSparseValues">Sorted list of sparse elements</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.FromArray(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector from part of an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Append(System.Double)">
            <summary>
            Appends an item to a vector - returns a new sparse vector
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Append(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a new vector which appends a second vector to this vector
            </summary>
            <param name="second">Second vector</param>
            <returns></returns>
            <remarks>If the second vector is dense, or if the common values
            for the two vectors are different, then the result becomes dense</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.#ctor">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.#ctor(System.Int32)">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.#ctor(System.Int32,System.Double,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{System.Double}})">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value, except
            for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.#ctor(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that">the vector to copy into this new vector</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Creates a sparse vector from a list of doubles.
            </summary>
            <param name="dlist">the list of doubles</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GetSparseIndex(System.Int32)">
            <summary>
            Gets the index into the sparse values array corresponding to an element index.
            If there is no sparse value at that index, returns the binary complement of the 
            index in the sparse array where such an element should be inserted to retain the
            sort order of the sparse array.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GetFirstCommonIndex">
            <summary>
            Gets the dense index of the first common element.
            </summary>
            <returns>Returns the dense index of the first common element or -1 if there are no common elements</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GetEnumerator">
            <summary>
            Gets a typed enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GetSparseEnumerator">
            <summary>
            Returns a sparse enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetAllElementsTo(System.Double)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetTo(System.Double[])">
            <summary>
            Copies values from an array. The minimum value is used as the common value
            </summary>
            <param name="values">An array whose length matches <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetTo(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copies values from a Vector to this vector.
            </summary>
            <param name="that"></param>
            <remarks> The source vector can be dense, in which case the
            minimum value is used as the common value.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetTo(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Copies values from a sparse vector to this sparse vector.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetTo(System.Collections.Generic.IList{System.Double})">
            <summary>
            Copies values from a list of doubles which must have the same size as this vector.
            The 'common value' is set to the minimum value of the list.
            </summary>
            <param name="dlist"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetTo(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Copies values from a list of doubles which must have the same size as this vector,
            using the specified common value.
            </summary>
            <param name="dlist">List of doubles</param>
            <param name="commonValue">Common value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetTo(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Copies values from an Enumerable to this vector
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Clone">
            <summary>
            Clones this vector - return as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.System#ICloneable#Clone">
            <summary>
            Clones this vector - return as an object
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another (vector) object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GreaterThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly greater than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly greater than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.LessThan(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is strictly less than a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.GreaterThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is greater than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.LessThanOrEqual(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Tests if this vector is less than or equal to a second vector.
            </summary>
            <param name="that">The value to test against.</param>
            <returns>True if each element is strictly less than or equal to the corresponding element of <paramref name="that"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the maximum absolute difference between this vector and another vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the maximum relative difference between this vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.All(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if all elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Any(System.Converter{System.Double,System.Boolean})">
            <summary>
            Tests if any elements in the vector satisfy the specified condition.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.IndexOfAll(System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns an enumeration of the indices of all elements which satisfy the specified condition.
            Indices are returned in sorted order.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce(System.Double,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and that vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and that vector
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">A second vector</param>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce(System.Double,MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Double,System.Double,System.Double})">
            <summary>
            Reduce method. Operates on this vector and two other vectors
            </summary>
            <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
            <param name="initial">Initial value</param>
            <param name="a">A second vector</param>
            <param name="b">A third vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce``1(``0,System.Func{``0,System.Double,``0},System.Func{``0,System.Double,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of sparse structure. Operates on this list
            </summary>
            <param name="initial">Initial value</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
            <remarks>This method does not take advantage of this list's sparseness.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce``2(``0,MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},System.Func{``0,System.Double,``1,``0},System.Func{``0,System.Double,``1,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of sparse structure. Operates on this list
            and another sparse collection
            </summary>
            <param name="initial">Initial value</param>
            <param name="that">The other sparse collection</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Reduce``3(``0,MicrosoftResearch.Infer.Collections.ISparseEnumerable{``1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{``2},System.Func{``0,System.Double,``1,``2,``0},System.Func{``0,System.Double,``1,``2,System.Int32,``0})">
            <summary>
            Reduce method which can take advantage of sparse structure. Operates on this list
            and two other sparse collections
            </summary>
            <param name="initial">Initial value</param>
            <param name="b">A second sparse collection</param>
            <param name="c">A third sparse collection</param>
            <param name="fun">Reduction function taking partial result and current element</param>
            <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Sum">
            <summary>
            Returns the sum of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Sum(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the sum of a function of all elements.
            </summary>
            <param name="fun">Conversion function</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this vector filtered by a function of a second vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Sum(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.SparseVector,System.Converter{System.Double,System.Boolean})">
            <summary>
            Returns the sum of a function of this sparse vector filtered by a function of a second sparse vector.
            </summary>
            <param name="fun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="cond">Function to convert the elements of that vector to give the filter condition</param>
            <returns>The filtered and mapped sum</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SumI">
            <summary>
            Returns the sum of over zero-based index times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SumISq">
            <summary>
            Returns the sum of over square of index^2 times element.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Max">
            <summary>
            Returns the maximum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Max(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the maximum of a function of the elements in the vector
            </summary>
            <param name="fun">Conversion function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Median">
            <summary>
            Returns the median of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Min">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Min(System.Converter{System.Double,System.Double})">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <param name="fun">Conversion function</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.LogSumExp">
            <summary>
            Returns the log of the sum of exponentials of the elements of the vector
            computed to high accuracy
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.IndexOfMinimum">
            <summary>
            Returns the index of the minimum element.
            </summary>
            <returns>The index of the minimum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.IndexOfMaximum">
            <summary>
            Returns the index of the maximum element.
            </summary>
            <returns>The index of the maximum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.IndexAtCumulativeSum(System.Double)">
            <summary>
            Returns the index of the first element at which the sum of all elements so far is greater
            than a particular value. Useful for finding the median of a Discrete distribution.
            </summary>
            <param name="targetSum">The sum of interest</param>
            <returns>
            The index of the element where <paramref name="targetSum"/> is exceeded 
            or -1 if <paramref name="targetSum"/> cannot be exceeded.
            </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Inner(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product of this vector with another vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Inner(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Returns the inner product of this sparse vector with another sparse vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Inner(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of this vector with a function of a second vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Inner(MicrosoftResearch.Infer.Maths.SparseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of this sparse vector with a function of a second sparse vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="fun">Function to convert the elements of the second vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this vector with a function of a second vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Inner(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.SparseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Returns the inner product of a function of this sparse vector with a function of a second sparse vector.
            </summary>
            <param name="thisFun">Function to convert the elements of this vector</param>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <param name="thatFun">Function to convert the elements of that vector</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Outer(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the outer product of this vector with another vector.
            </summary>
            <param name="that">Second vector.</param>
            <returns>Their outer product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Outer(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Returns the outer product of this sparse vector with another sparse vector.
            </summary>
            <param name="that">Second vector.</param>
            <returns>Their outer product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToDiagonal(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the diagonal of a matrix.
            </summary>
            <param name="m">A matrix with Rows==Cols==this.Count.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Scale(System.Double)">
            <summary>
            Multiplies this vector by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns></returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Contains(System.Double)">
            <summary>
            Returns true if the Vector contains the specified value
            </summary>
            <param name="value">The value to test for</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.IndexOf(System.Double)">
            <summary>
            Returns the index of the first occurence of the given value in the array.
            Returns -1 if the value is not in the array
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies this vector to the given array starting at the specified index
            in the target array
            </summary>
            <param name="array">The target array</param>
            <param name="index">The start index in the target array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of a given vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The given vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToFunction(MicrosoftResearch.Infer.Maths.SparseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of the elements of another sparse vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToFunction(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this vector to a function of the elements of two vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToFunction(MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of the elements of two other sparse vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToFunctionInPlace(MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of the elements of this sparse vector and another sparse vectors
            x = fun(x,b)
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.ToString(System.String,System.String)">
            <summary>
            String representation of vector with a specified format and delimiter
            </summary>
            <param name="format">Format of each element value</param>
            <param name="delimiter">Delimiter between sparse elements</param>
            <returns>A string</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.ToArray">
            <summary>
            Converts this sparse vector to an array of doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.ToVector">
            <summary>
            Converts this sparse vector to an ordinary non-sparse vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.AsSparseVector(System.Collections.Generic.IList{System.Double})">
            <summary>
            Converts the supplied list of doubles to a sparse vector, or does nothing
            if it is already a sparse vector.
            </summary>
            <param name="iList"></param>
            <returns>A sparse vector containing the list of doubles</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToSubarray(System.Double[],System.Int32)">
            <summary>
            Copies values from an array. The minimum is used as the common value
            </summary>
            <param name="values">An array whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="values"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>
            Copies values from a vector. If the source vector is sparse, then the common value
            is set to the common value from the source vector. If the source vector
            is dense, then the common value is set to the minimum of the data in the source vector
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.SparseVector,System.Int32)">
            <summary>
            Copies values from a sparse vector. The common value is set to the common value
            from the source vector.
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.Subvector(System.Int32,System.Int32)">
            <summary>
            Create a subvector of this sparse vector.
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SparseVector.SetSubvector(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set a subvector of this sparse vector to another vector. The common value is
            not changed
            </summary>
            <param name="startIndex">The index of the first element of this to copy to.</param>
            <param name="that">A vector whose length is at most <c>this.Count - startIndex</c>.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.SparseVector.SparseValues">
            <summary>
            A list of the value and indices of elements which may not have the common value 
            (although they are not precluded from doing so).
            This list is kept sorted by index to allow efficient operations on the sparse vector.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.SparseVector.CommonValue">
            <summary>
            The value of all elements not mentioned explicitly as sparse values.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.SparseVector.Count">
            <summary>
            The number of elements in this vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.SparseVector.SparseCount">
            <summary>
            The number of elements not equal to the common value
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.SparseVector.Item(System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.SparseVector.HasCommonElements">
            <summary>
            Returns true if there is at least one element which has the common value.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.ApproximateSparseVector">
            <summary>
            A one-dimensional vector of double values, optimised for the case where many of the 
            elements share a common value (which need not be zero) within some tolerance.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.FromXml(System.Xml.XmlReader)">
            <summary>
            Read a SparseVector from XML of the form <example>&lt;ApproximateSparseVector&gt;&lt;Sparsity%gt;...&lt;/Sparsity%gt;...&lt;/ApproximateSparseVector&gt;</example>
            </summary>
            <param name="reader"></param>
            <returns>SparseVector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.ToXml(System.Xml.XmlWriter)">
            <summary>
            Writer XML of the form <example>&lt;ApproximateSparseVector&gt;&lt;Sparsity&gt;...&lt;/Sparsity&gt;...&lt;/ApproximateSparseVector&gt;</example>
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Zero(System.Int32)">
            <summary>
            Creates an approximate sparse vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Zero(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates an approximate sparse vector of given length with elements all 0.0
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="s">Sparsity</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Constant(System.Int32,System.Double)">
            <summary>
            Creates an approximate sparse vector of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Constant(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Creates an approximate sparse vector of given length with elements all equal
            to a specified value
            </summary>
            <param name="count">Number of elements in vector</param>
            <param name="value">value for each element</param>
            <param name="s">Sparsity</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Copy(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates an approximate sparse vector as a copy of another vector (which may not be sparse)
            </summary>
            <param name="that">The source vector - can be dense or sparse</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.FromArray(System.Double[])">
            <summary>
            Constructs a sparse vector from a dense array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.FromSparseValues(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{System.Double}})">
            <summary>
            Constructs a sparse vector from a sorted list of sparse elements.
            </summary>
            <param name="count">Count for result</param>
            <param name="commonValue">Common value</param>
            <param name="s">Sparsity</param>
            <param name="sortedSparseValues">Sorted list of sparse elements</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.FromArray(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector from part of an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Append(System.Double)">
            <summary>
            Appends an item to a vector - returns a new sparse vector
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Append(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a new vector which appends a second vector to this vector
            </summary>
            <param name="second">Second vector</param>
            <returns></returns>
            <remarks>If the second vector is dense, or if the common values
            for the two vectors are different, then the result becomes dense</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Int32)">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Int32,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Constructs a zero vector with the given number of elements and sparsity spec.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="s">Sparsity specification</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="s">Sparsity</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Int32,System.Double,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{System.Double}})">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value, except
            for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Int32,System.Double,MicrosoftResearch.Infer.Maths.Sparsity,System.Collections.Generic.List{MicrosoftResearch.Infer.Collections.SparseElement{System.Double}})">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value, except
            for the specified list of sparse values. This list is stored internally as is
            so MUST be sorted by index and must not be modified externally.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
            <param name="commonValue">The value to assign to all elements.</param>
            <param name="s">Sparsity</param>
            <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(MicrosoftResearch.Infer.Maths.ApproximateSparseVector)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that">the vector to copy into this new vector</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.#ctor(System.Collections.Generic.IList{System.Double})">
            <summary>
            Creates a sparse vector from a list of doubles.
            </summary>
            <param name="dlist">the list of doubles</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetTo(System.Double[])">
            <summary>
            Copies values from an array. The minimum value is used as the common value
            </summary>
            <param name="values">An array whose length matches <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetTo(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copies values from a Vector to this vector.
            </summary>
            <param name="that"></param>
            <remarks> The source vector can be dense, in which case the
            minimum value is used as the common value.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetTo(MicrosoftResearch.Infer.Maths.ApproximateSparseVector)">
            <summary>
            Copies values from a sparse vector to this sparse vector.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetTo(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Copies values from a list of doubles which must have the same size as this vector,
            using the specified common value.
            </summary>
            <param name="dlist">List of doubles</param>
            <param name="commonValue">Common value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetTo(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Set this vector to a collection
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Clone">
            <summary>
            Clones this vector - return as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.System#ICloneable#Clone">
            <summary>
            Clones this vector - return as an object
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the maximum absolute difference between this vector and another vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the maximum relative difference between this vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToDiagonal(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the diagonal of a matrix.
            </summary>
            <param name="m">A matrix with Rows==Cols==this.Count.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Scale(System.Double)">
            <summary>
            Multiplies this vector by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns></returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Contains(System.Double)">
            <summary>
            Returns true if the Vector contains the specified value up to tolerance
            </summary>
            <param name="value">The value to test for</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.IndexOf(System.Double)">
            <summary>
            Returns the index of the first occurence of the given value in the array.
            Returns -1 if the value is not in the array
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToFunction(MicrosoftResearch.Infer.Maths.SparseVector,System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of the elements of another sparse vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToFunctionInPlace(System.Converter{System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of themselves.
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToFunction(MicrosoftResearch.Infer.Maths.SparseVector,MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of the elements of two other sparse vectors
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToFunctionInPlace(MicrosoftResearch.Infer.Maths.SparseVector,System.Func{System.Double,System.Double,System.Double})">
            <summary>
            Sets the elements of this sparse vector to a function of the elements of this sparse vector and another sparse vectors
            x = fun(x,b)
            </summary>
            <param name="fun">The function which maps two doubles to a double</param>
            <param name="b">The second vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.ToString(System.String,System.String)">
            <summary>
            String representation of vector with a specified format and delimiter
            </summary>
            <param name="format"></param>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToSubarray(System.Double[],System.Int32)">
            <summary>
            Copies values from an array. The minimum is used as the common value
            </summary>
            <param name="values">An array whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="values"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetToSubvector(MicrosoftResearch.Infer.Maths.SparseVector,System.Int32)">
            <summary>
            Copies values from a sparse vector. The common value is set to the common value
            from the source vector.
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Subvector(System.Int32,System.Int32)">
            <summary>
            Create a subvector of this sparse vector.
            </summary>
            <param name="startIndex"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.SetSubvector(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set a subvector of this sparse vector to another vector. The common value is
            not changed
            </summary>
            <param name="startIndex">The index of the first element of this to copy to.</param>
            <param name="that">A vector whose length is at most <c>this.Count - startIndex</c>.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Tolerance">
            <summary>
            The tolerance at which vector element values are considered equal to the common value.
            </summary>
            <remarks>By default this tolerance is set to 0.000001.</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.CountTolerance">
            <summary>
            The maximum allowed count of vector elements not set to the common value.
            </summary>
            <remarks>This is ignored if &lt;= 0 which is the default value.</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.ApproximateSparseVector.Item(System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaProductOp">
            <summary>
            Provides outgoing Gamma messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/> and <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.ProductAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'product'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[p(product) sum_(b) p(b) factor(product,a,b)]/p(product)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            EP message to 'product'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[p(product) sum_(a) p(a) factor(product,a,b)]/p(product)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.ProductAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'product'
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'product' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(product) p(product) factor(product,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.AAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(b) p(b) factor(product,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(a) p(a) factor(product,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(product) p(product) factor(product,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.BAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp">
            <summary>
            Provides Gamma evidence messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product,a) p(product,a) factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product,b) p(product,b) factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(product,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product,a) p(product,a) factor(product,a,b) / sum_product p(product) messageTo(product))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(product,b) p(product,b) factor(product,a,b) / sum_product p(product) messageTo(product))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(product,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(product,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaProductVmpOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'product'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[sum_(a,b) p(a,b) factor(product,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.ProductAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'product'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[sum_(b) p(b) factor(product,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'product'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'product' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[sum_(a) p(a) factor(product,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            Because the factor is deterministic, 'product' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(b) p(b) log(sum_product p(product) factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' with 'product' integrated out.
            The formula is <c>sum_product p(product) factor(product,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            Because the factor is deterministic, 'product' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(a) p(a) log(sum_product p(product) factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            The formula is <c>exp(sum_(a) p(a) log(factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' with 'product' integrated out.
            The formula is <c>sum_product p(product) factor(product,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp">
            <summary>
            Provides Gamma evidence messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(ratio,a) p(ratio,a) factor(ratio,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(ratio,b) p(ratio,b) factor(ratio,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(ratio,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(ratio,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(ratio,a) p(ratio,a) factor(ratio,a,b) / sum_ratio p(ratio) messageTo(ratio))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(ratio,b) p(ratio,b) factor(ratio,a,b) / sum_ratio p(ratio) messageTo(ratio))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(ratio,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(ratio,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp">
            <summary>
            Provides VMP Gamma evidence messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.RatioAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'ratio'
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'ratio' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'ratio' as the random arguments are varied.
            The formula is <c>proj[sum_(b) p(b) factor(ratio,a,b)]</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.RatioAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'ratio'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'ratio' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'ratio' as the random arguments are varied.
            The formula is <c>proj[sum_(a) p(a) factor(ratio,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(ratio,a,b)))</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="ratio">Incoming message from 'ratio'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' with 'ratio' integrated out.
            The formula is <c>sum_ratio p(ratio) factor(ratio,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.BAverageLogarithm">
            <summary>
            VMP message to 'b'
            </summary>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ProductExpOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.ProductExp(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.ProductExpAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'productExp'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'productExp' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'productExp' as the random arguments are varied.
            The formula is <c>proj[sum_(a,b) p(a,b) factor(productExp,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.ProductExpAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'productExp'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'productExp' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'productExp' as the random arguments are varied.
            The formula is <c>proj[sum_(b) p(b) factor(productExp,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="ProductExp">Incoming message from 'productExp'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            Because the factor is deterministic, 'productExp' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(b) p(b) log(sum_productExp p(productExp) factor(productExp,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="ProductExp"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="ProductExp">Constant value for 'productExp'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(productExp,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="ProductExp">Incoming message from 'productExp'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_B">Previous outgoing message to 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            Because the factor is deterministic, 'productExp' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(a) p(a) log(sum_productExp p(productExp) factor(productExp,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="ProductExp"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="ProductExp">Incoming message from 'productExp'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            Because the factor is deterministic, 'productExp' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(a) p(a) log(sum_productExp p(productExp) factor(productExp,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="ProductExp"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="ProductExp">Constant value for 'productExp'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            The formula is <c>exp(sum_(a) p(a) log(factor(productExp,a,b)))</c>.
            </para><para>Throws an exception rather than return a meaningless point mass</para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,MicrosoftResearch.Infer.Distributions.NonconjugateGaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="ProductExp">Incoming message from 'productExp'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_B">Previous outgoing message to 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' with 'productExp' integrated out.
            The formula is <c>sum_productExp p(productExp) factor(productExp,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="ProductExp"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductExpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="ProductExp">Constant value for 'productExp'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.OffsetCopyOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Copy``1(``0)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.OffsetCopyOp`1.LogAverageFactor">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(OffsetCopy,value))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.OffsetCopyOp`1.LogEvidenceRatio``1(``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="output">Incoming message from 'OffsetCopy'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(OffsetCopy) p(OffsetCopy) factor(OffsetCopy,value) / sum_OffsetCopy p(OffsetCopy) messageTo(OffsetCopy))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.OffsetCopyOp`1.LogEvidenceRatio``1(`0,``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="output">Constant value for 'OffsetCopy'.</param>
            <param name="input">Incoming message from 'value'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(value) p(value) factor(OffsetCopy,value))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.OffsetCopyOp`1.InputAverageConditional``2(``1,``0)">
            <summary>
            EP message to 'value'
            </summary>
            <param name="input">Incoming message from 'value'.</param>
            <param name="Output">Incoming message from 'OffsetCopy'.</param>
            <returns>The outgoing EP message to the 'value' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'value' as the random arguments are varied.
            The formula is <c>proj[p(value) sum_(OffsetCopy) p(OffsetCopy) factor(OffsetCopy,value)]/p(value)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.OffsetCopyOp`1.InputAverageConditional``1(``0,`0,``0)">
            <summary>
            EP message to 'value'
            </summary>
            <param name="input">Incoming message from 'value'.</param>
            <param name="output">Constant value for 'OffsetCopy'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'value' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.OffsetCopyOp`1.OutputAverageConditional``2(``1,``0)">
            <summary>
            EP message to 'OffsetCopy'
            </summary>
            <param name="Output">Incoming message from 'OffsetCopy'.</param>
            <param name="Input">Incoming message from 'value'.</param>
            <returns>The outgoing EP message to the 'OffsetCopy' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'OffsetCopy' as the random arguments are varied.
            The formula is <c>proj[p(OffsetCopy) sum_(value) p(value) factor(OffsetCopy,value)]/p(OffsetCopy)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.OffsetCopyOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(OffsetCopy,value))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.OffsetCopyOp`1.InputAverageLogarithm``2(``1,``0)">
            <summary>
            VMP message to 'value'
            </summary>
            <param name="Input">Incoming message from 'value'.</param>
            <param name="Output">Incoming message from 'OffsetCopy'.</param>
            <returns>The outgoing VMP message to the 'value' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'value' with 'OffsetCopy' integrated out.
            The formula is <c>sum_OffsetCopy p(OffsetCopy) factor(OffsetCopy,value)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.OffsetCopyOp`1.InputAverageLogarithm``1(``0,`0,``0)">
            <summary>
            VMP message to 'value'
            </summary>
            <param name="input">Incoming message from 'value'.</param>
            <param name="output">Constant value for 'OffsetCopy'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'value' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.OffsetCopyOp`1.OutputAverageLogarithm``2(``1,``0)">
            <summary>
            VMP message to 'OffsetCopy'
            </summary>
            <param name="Output">Incoming message from 'OffsetCopy'.</param>
            <param name="Input">Incoming message from 'value'.</param>
            <returns>The outgoing VMP message to the 'OffsetCopy' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'OffsetCopy' as the random arguments are varied.
            The formula is <c>proj[sum_(value) p(value) factor(OffsetCopy,value)]</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.InnerProductPartialCovariance(System.Double[],MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(X,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.EbbtInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Update the buffer 'CovarianceOfB'
            </summary>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>New value of buffer 'CovarianceOfB'</returns>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.Ebbt(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Update the buffer 'CovarianceOfB'
            </summary>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>New value of buffer 'CovarianceOfB'</returns>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.EaatInit(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            Update the buffer 'CovarianceOfB'
             </summary>
             <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
             <returns>New value of buffer 'CovarianceOfB'</returns>
             <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.Eaat(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Update the buffer 'CovarianceOfB'
            </summary>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>New value of buffer 'CovarianceOfB'</returns>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.CovarianceOfBInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'CovarianceOfB'
            </summary>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>New value of buffer 'CovarianceOfB'</returns>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.CovarianceOfB(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Update the buffer 'CovarianceOfB'
            </summary>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Storage for result.</param>
            <returns>New value of buffer 'CovarianceOfB'</returns>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.MeanOfBInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'MeanOfB'
            </summary>
            <param name="B">Incoming message from 'B'..</param>
            <returns>New value of buffer 'MeanOfB'</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.MeanOfB(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Update the buffer 'MeanOfB'
            </summary>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="CovarianceOfB">Buffer 'CovarianceOfB'.</param>
            <param name="result">Storage for result</param>
            <returns>New value of buffer 'MeanOfB'</returns>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="X">Incoming message from 'X'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="MeanOfB">Buffer 'MeanOfB'.</param>
            <param name="CovarianceOfB">Buffer 'CovarianceOfB'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'A'.
            Because the factor is deterministic, 'X' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(B) p(B) log(sum_X p(X) factor(X,A,B)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="X">Incoming message from 'X'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'B'.
            Because the factor is deterministic, 'X' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(A) p(A) log(sum_X p(X) factor(X,A,B)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductPartialCovarianceOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            VMP message to 'X'
            </summary>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="MeanOfB">Buffer 'MeanOfB'.</param>
            <param name="CovarianceOfB">Buffer 'CovarianceOfB'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'X' as the random arguments are varied.
            The formula is <c>proj[sum_(A,B) p(A,B) factor(X,A,B)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GetItemsWithDictionaryOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GetItems``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})"/>, given random arguments to the function.
            This factor gets a sub-array of (possibly duplicated) items from an array of items
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsWithDictionaryOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.String},System.Collections.Generic.IDictionary{System.String,System.Int32},``1)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="items">Incoming message from 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(items) p(items) factor(items,array,indices)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsWithDictionaryOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.String},System.Collections.Generic.IDictionary{System.String,System.Int32},``1)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="items">Incoming message from 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(items) p(items) factor(items,array,indices)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstraintViolatedException">
            <summary>
            Exception which is thrown when a constraint is violated.  This
            occurs when an observation does not hold true or a weight is 0.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstraintViolatedException.#ctor(System.String)">
            <summary>
            Construct a constraint violated exception with a specified error message 
            </summary>
            <param name="s"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Constrain">
            <summary>
            A repository of commonly used constraint methods.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Constrain.EqualRandom``2(``0,``1)">
            <summary>
            Constrains a value to be equal to a sample from dist.
            </summary>
            <typeparam name="DomainType">Domain type</typeparam>
            <typeparam name="DistributionType">Distribution type</typeparam>
            <param name="value">Value</param>
            <param name="dist">Distribution instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Constrain.Equal``1(``0,``0)">
            <summary>
            Constrains a value to be equal to another value.
            </summary>
            <typeparam name="T">Value type</typeparam>
            <param name="A">First value</param>
            <param name="B">Second value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Constrain.Contain(System.Collections.Generic.IList{System.Int32},System.Int32)">
            <summary>
            Constrains a set of integers to contain a particular integer.
            </summary>
            <param name="set">The set of integers, specified as a list</param>
            <param name="i">The integer which the set must contain</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Constrain.EqualRandom``2(``0,``1)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.ValueAverageConditional``1(``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="dist">Constant value for 'dist'.</param>
            <returns>The outgoing EP message to the 'value' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = (dist)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.LogAverageFactor``1(``0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <param name="dist">Constant value for 'dist'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (value,dist)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.LogAverageFactor``1(`0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="value">Constant value for 'value'.</param>
            <param name="dist">Constant value for 'dist'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (value,dist)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.LogEvidenceRatio``1(``0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.LogEvidenceRatio``1(`0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.AverageLogFactor``1(``0,``0)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="dist">Constant value for 'dist'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (value,dist)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.AverageLogFactor``1(`0,``0)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="value">Constant value for 'value'.</param>
            <param name="dist">Constant value for 'dist'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (value,dist)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.ValueAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="dist">Constant value for 'dist'.</param>
            <returns>The outgoing VMP message to the 'value' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int log(f(value,x)) q(x) dx</c> where <c>x = (dist)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Constrain.Equal``1(``0,``0)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogAverageFactor``1(``0,``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="a">Incoming message from 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(A,B) p(A,B) factor(A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogAverageFactor``1(`0,``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Incoming message from 'B'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(B) p(B) factor(A,B))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogAverageFactor``1(``0,`0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="a">Incoming message from 'A'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(A) p(A) factor(A,B))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogAverageFactor(`0,`0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogEvidenceRatio``1(``0,``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="a">Incoming message from 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(A,B) p(A,B) factor(A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogEvidenceRatio``1(`0,``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(B) p(B) factor(A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogEvidenceRatio``1(``0,`0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="a">Incoming message from 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(A) p(A) factor(A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogEvidenceRatio(`0,`0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'A'
            </summary>
            <param name="B">Incoming message from 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'A' as the random arguments are varied.
            The formula is <c>proj[p(A) sum_(B) p(B) factor(A,B)]/p(A)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AAverageConditional``1(`0,``0)">
            <summary>
            EP message to 'A'
            </summary>
            <param name="B">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'A' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'B'
            </summary>
            <param name="A">Incoming message from 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'B' as the random arguments are varied.
            The formula is <c>proj[p(B) sum_(A) p(A) factor(A,B)]/p(B)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BAverageConditional``1(`0,``0)">
            <summary>
            EP message to 'B'
            </summary>
            <param name="A">Constant value for 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'B' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AAverageLogarithm``1(``0,``0)">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="B">Incoming message from 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'A'.
            The formula is <c>exp(sum_(B) p(B) log(factor(A,B)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BAverageLogarithm``1(``0,``0)">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="A">Incoming message from 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'B'.
            The formula is <c>exp(sum_(A) p(A) log(factor(A,B)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AAverageLogarithm``1(`0,``0)">
            <summary>
            VMP message to 'A'
            </summary>
            <param name="B">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'A' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BAverageLogarithm``1(`0,``0)">
            <summary>
            VMP message to 'B'
            </summary>
            <param name="A">Constant value for 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'B' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AMaxConditional``1(``0,``0)">
            <summary>
            Max product message to 'A' 
            </summary>
            <param name="B">Incoming message from 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BMaxConditional``1(``0,``0)">
            <summary>
            Max product message to 'B'
            </summary>
            <param name="A">Incoming message from 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainContainOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Constrain.Contain(System.Collections.Generic.IList{System.Int32},System.Int32)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainContainOp.SetAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            VMP message to 'set'
            </summary>
            <param name="i">Constant value for 'i'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'set' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.WishartEstimator">
            <summary>
            Estimates a Wishart distribution from samples.
            </summary>
            <remarks><code>
            The distribution is estimated via moment matching (not maximum-likelihood).
            E[X] = (a+(d+1)/2)/B
            var(X_ii) = (a+(d+1)/2)*diag(inv(B))^2
            because X_ii ~ Gamma(a+(d+1)/2, 1/diag(inv(B))).
            Therefore: 
            a = E[X_ii]^2/var(X_ii) - (d+1)/2
            B = (a+(d+1)/2)/E[X]
            </code></remarks>
            In the one-dimensional case,
            E[log(x)] = -log(b) + digamma(a+1) 
                      =approx -log(b) + log(a+1) - 1/2/(a+1) 
                      = log(E[x]) - 1/2/(a+1)
            In the Wishart case,
            E[logdet(X)] = -logdet(B) + sum_{i=0..d-1} digamma(a + (d+1-i)/2)
                         =approx -logdet(B) + d*digamma(a+(d+1)/2)
                         =approx -logdet(B) + d*log(a+(d+1)/2) - d/2/(a+(d+1)/2) 
                         = log(E[X}) - d/2/(a+(d+1)/2)
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.WishartEstimator.mva">
            <summary>
            Where to accumulate mean and variance matrices
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new Wishart estimator
            </summary>
            <param name="dimension">The dimension of the Wishart distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Retrieves the Wishart estimator
            </summary>
            <param name="result">Where to put the result</param>
            <returns>The resulting distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.Add(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Adds a Wishart distribution item to the estimator
            </summary>
            <param name="item">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.Add(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="item">The sample to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.SetTo(MicrosoftResearch.Infer.Distributions.WishartEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.WishartEstimator.Dimension">
            <summary>
            The dimension of the Wishart distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.mva">
            <summary>
            Where to accumulate means and variances
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.#ctor">
            <summary>
            Creates a new TruncatedGaussian estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.Add(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Adds a TruncatedGaussian distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.TruncatedGaussian)">
            <summary>
            Computes the maximum-likelihood TruncatedGaussian from the samples.
            </summary>
            <param name="result"></param>
            <returns>Returns a new TruncatedGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.SetTo(MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.TruncatedGaussianEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.KernelFactory">
            <summary>
            Kernel Factory - singleton class. It maintains a list
            of Kernel names and their types
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFactory.RegisterKernelFunction(MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunctionWithParams)">
            <summary>
            Registers a kernel function. The factory is primed with stock
            kernel functions. This function allows clients to add in custom
            kernel functions
            </summary>
            <param name="ikf">Type instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFactory.CreateKernelFunction(System.String)">
            <summary>
            Creates a kernel function by specifying the kernel function name
            </summary>
            <param name="name">Name of the kernel function</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFactory.Instance">
            <summary>
            Kernel function factory singleton instance
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1">
            <summary>
            A discrete distribution over the values of an enum.
            </summary>
            <typeparam name="TEnum"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.#ctor">
            <summary>
            Creates a uniform distribution over the enum values.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.#ctor(System.Double[])">
            <summary>
            Creates a distribution over the enum values using the specified probs.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.ConvertFromInt(System.Int32)">
            <summary>
            Converts from an integer to an enum value
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.ConvertToInt(`0)">
            <summary>
            Converts the enum value to an integer
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Sparsity">
            <summary>
            Defines sparsity settings for vectors. The sparsity handling has been designed to
            deal with large dimensional distributions such as Discrete and Dirichlet distributions.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.ApproximateWithTolerance(System.Double)">
            <summary>
            Static read-only property giving Sparsity settings for approximate vector with the given tolerance.
            </summary>
            <param name="tolerance">At what tolerance are vector values considered equal to the common value.</param>
            <returns></returns>
            <remarks><see cref="T:MicrosoftResearch.Infer.Maths.ApproximateSparseVector"/> supports this specification.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.FromSpec(MicrosoftResearch.Infer.Maths.StorageType,System.Double,System.Int32)">
            <summary>
            Static method to create a general sparsity specification
            </summary>
            <param name="storage">The storage method the vector should use</param>
            <param name="tolerance">The tolerance at which vector element values are considered equal to the common value.</param>
            <param name="countTolerance">The maximum allowed count of vector elements not set to the common value.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.CreateZeroVector(System.Int32)">
            <summary>
            Creates a vector of all zeros with these sparsity settings
            </summary>
            <param name="count">Size of vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.CreateConstantVector(System.Int32,System.Double)">
            <summary>
            Creates a constant vector with these sparsity settings
            </summary>
            <param name="count">Size of vector</param>
            <param name="value">Constant value</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.ToString">
            <summary>
            Instance description
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.Equals(System.Object)">
            <summary>
            Determines the equality of this instance with another
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.op_Equality(MicrosoftResearch.Infer.Maths.Sparsity,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Equality operator.
            </summary>
            <param name="a">First sparsity.</param>
            <param name="b">Second sparsity.</param>
            <returns>True if the sparsity specifications are equal.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Sparsity.op_Inequality(MicrosoftResearch.Infer.Maths.Sparsity,MicrosoftResearch.Infer.Maths.Sparsity)">
            <summary>
            Inequality operator.
            </summary>
            <param name="a">First sparsity specification.</param>
            <param name="b">Second sparsity specification.</param>
            <returns>True if sparsity specifications are not equal.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.Sparse">
            <summary>
            Static read-only property giving Sparsity settings for sparse, exact vectors.
            </summary>
            <remarks>A vector class which uses this sparsity will maintain a common background
            value. It is expected that only a small percentage of values will differ from this
            common value, and this enables the vector class to be efficient computationally and
            memory-wise. <see cref="T:MicrosoftResearch.Infer.Maths.SparseVector"/> uses this specification.</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.Piecewise">
            <summary>
            Static read-only property giving Sparsity settings for piecewise, exact vectors.
            </summary>
            <remarks>A vector class which uses this sparsity is expected to have ranges of elements
            that have the same values. <see cref="T:MicrosoftResearch.Infer.Maths.PiecewiseVector"/> uses this specification.
            </remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.Dense">
            <summary>
            Static read-only property giving Sparsity settings for dense vectors.
            </summary>
            <remarks> <see cref="T:MicrosoftResearch.Infer.Maths.DenseVector"/> uses this specification.</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.Storage">
            <summary>
            The storage method used by this vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.IsDense">
            <summary>
            True if is the vector is dense
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.IsSparse">
            <summary>
            True if the vector is sparse (exact or approximate)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.IsPiecewise">
            <summary>
            True if is the vector is piecewise
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.IsApproximate">
            <summary>
            True if the sparsity is approximate
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.IsExact">
            <summary>
            True if the sparsity is exact
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.Tolerance">
            <summary>
            The tolerance at which vector element values are considered equal to the common value.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Sparsity.CountTolerance">
            <summary>
            The maximum allowed count of vector elements not set to the common value.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.StorageType">
            <summary>
            The type of storage used in a vector, which is 
            specified as part of the Sparsity class.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.StorageType.Dense">
            <summary>
            The vector is stored as a dense array with memory allocated
            for each element.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.StorageType.Sparse">
            <summary>
            The vector is stored as a sparse array with memory allocated
            only for elements that do not have a particular common value.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.StorageType.Piecewise">
            <summary>
            The vector is stored as a set of pieces with each piece
            having a constant value, and all elements not in any piece 
            having a particular common value.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncExtensions">
            <summary>
            Provides extension methods for Func that support collection and sparse collections
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncExtensions.Map``2(System.Func{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Maps one enumerable sequence to another. Supports sparse representations.
            </summary>
            <typeparam name="T">Source sequence element type</typeparam>
            <typeparam name="TRes">Result sequence element type</typeparam>
            <param name="fun">The function</param>
            <param name="a">The source sequence</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncExtensions.Map``3(System.Func{``0,``1,``2},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Maps two enumerable sequences to another. Supports sparse representations.
            </summary>
            <typeparam name="T1">First source sequence element type</typeparam>
            <typeparam name="T2">Second source sequence element type</typeparam>
            <typeparam name="TRes">Result sequence element type</typeparam>
            <param name="fun">The function</param>
            <param name="a">First source sequence</param>
            <param name="b">Second source sequence</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncExtensions.Map``4(System.Func{``0,``1,``2,``3},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
            <summary>
            Maps three enumerable sequences to another. Supports sparse representations.
            </summary>
            <typeparam name="T1">First source sequence element type</typeparam>
            <typeparam name="T2">Second source sequence element type</typeparam>
            <typeparam name="T3">Third source sequence element type</typeparam>
            <typeparam name="TRes">Result sequence element type</typeparam>
            <param name="fun">The function</param>
            <param name="a">First source sequence</param>
            <param name="b">Second source sequence</param>
            <param name="c">Second source sequence</param>
            <returns></returns>		
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncExtensions.Map``5(System.Func{``0,``1,``2,``3,``4},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3})">
            <summary>
            Maps four enumerable sequences to another. Supports sparse representations.
            </summary>
            <typeparam name="T1">First source sequence element type</typeparam>
            <typeparam name="T2">Second source sequence element type</typeparam>
            <typeparam name="T3">Third source sequence element type</typeparam>
            <typeparam name="T4">Fourth source sequence element type</typeparam>
            <typeparam name="TRes">Result sequence element type</typeparam>
            <param name="fun">The function</param>
            <param name="a">First source sequence</param>
            <param name="b">Third source sequence</param>
            <param name="c">Fourth source sequence</param>
            <param name="d">Fifth source sequence</param>
            <returns></returns>		
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncExtensions.Map``6(System.Func{``0,``1,``2,``3,``4,``5},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Collections.Generic.IEnumerable{``4})">
            <summary>
            Maps four enumerable sequences to another. Supports sparse representations.
            </summary>
            <typeparam name="T1">First source sequence element type</typeparam>
            <typeparam name="T2">Second source sequence element type</typeparam>
            <typeparam name="T3">Third source sequence element type</typeparam>
            <typeparam name="T4">Fourth source sequence element type</typeparam>
            <typeparam name="T5">Fifth source sequence element type</typeparam>
            <typeparam name="TRes">Result sequence element type</typeparam>
            <param name="fun">The function</param>
            <param name="a">First source sequence</param>
            <param name="b">Second source sequence</param>
            <param name="c">Third source sequence</param>
            <param name="d">Fourth source sequence</param>
            <param name="d">Fifth source sequence</param>
            <returns></returns>		
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`2">
            <summary>
            Sparse iterator class for a function of one sparse collection
            </summary>
            <typeparam name="T">Type of source collection</typeparam>
            <typeparam name="TRes">Type of result collection</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`2.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`2.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`3">
            <summary>
            Sparse iterator class for a function of two sparse collections
            </summary>
            <typeparam name="T1">Type of first source collection</typeparam>
            <typeparam name="T2">Type of second source collection</typeparam>
            <typeparam name="TRes">Type of result collection</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`3.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`3.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`4">
            <summary>
            Sparse iterator class for a function of three sparse collections
            </summary>
            <typeparam name="T1">Type of first source collection</typeparam>
            <typeparam name="T2">Type of second source collection</typeparam>
            <typeparam name="T3">Type of third source collection</typeparam>
            <typeparam name="TRes">Type of result collection</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`4.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`4.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`5">
            <summary>
            Sparse iterator class for a function of four sparse collections
            </summary>
            <typeparam name="T1">Type of first source collection</typeparam>
            <typeparam name="T2">Type of second source collection</typeparam>
            <typeparam name="T3">Type of third source collection</typeparam>
            <typeparam name="T4">Type of fourth source collection</typeparam>
            <typeparam name="TRes">Type of result collection</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`5.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`5.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`6">
            <summary>
            Sparse iterator class for a function of four sparse collections
            </summary>
            <typeparam name="T1">Type of first source collection</typeparam>
            <typeparam name="T2">Type of second source collection</typeparam>
            <typeparam name="T3">Type of third source collection</typeparam>
            <typeparam name="T4">Type of fourth source collection</typeparam>
            <typeparam name="T5">Type of fifth source collection</typeparam>
            <typeparam name="TRes">Type of result collection</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`6.MoveNext">
            <summary>
            Advances the enumerator to the next sparse element of the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerator`6.Reset">
            <summary>
            Resets this enumeration to the beginning
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncEnumerable`2">
            <summary>
            Enumerable generated as a function of the elements of another enumerable
            </summary>
            <typeparam name="T">Type for source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`2.#ctor(System.Func{`0,`1},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new enumerator for a function of one variable to act on a collection
            </summary>
            <param name="fun">The function</param>
            <param name="a">The source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`2.GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncEnumerable`3">
            <summary>
            Enumerable generated as a function of the elements of two other enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`3.#ctor(System.Func{`0,`1,`2},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Creates a new enumerator for a function of two variables to act on two collections
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`3.GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`3.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncEnumerable`4">
            <summary>
            Enumerable generated as a function of the elements of three other enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="T3">Type for third source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`4.#ctor(System.Func{`0,`1,`2,`3},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2})">
            <summary>
            Creates a new enumerator for a function of one variable to act on a collection
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
            <param name="c">The third source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`4.GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`4.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncEnumerable`5">
            <summary>
            Enumerable generated as a function of the elements of four other enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="T3">Type for third source enumerable</typeparam>
            <typeparam name="T4">Type for fourth source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`5.#ctor(System.Func{`0,`1,`2,`3,`4},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3})">
            <summary>
            Creates a new enumerator for a function of one variable to act on a collection
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
            <param name="c">The third source collection</param>
             <param name="d">The fourth source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`5.GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`5.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncEnumerable`6">
            <summary>
            Enumerable generated as a function of the elements of five other enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="T3">Type for third source enumerable</typeparam>
            <typeparam name="T4">Type for fourth source enumerable</typeparam>
             <typeparam name="T5">Type for fifth source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`6.#ctor(System.Func{`0,`1,`2,`3,`4,`5},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`1},System.Collections.Generic.IEnumerable{`2},System.Collections.Generic.IEnumerable{`3},System.Collections.Generic.IEnumerable{`4})">
            <summary>
            Creates a new enumerator for a function of one variable to act on a collection
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
            <param name="c">The third source collection</param>
            <param name="d">The fourth source collection</param>
            <param name="e">The fifth source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`6.GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncEnumerable`6.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`2">
            <summary>
            Sparse enumerable generated as a function of the elements of another sparse enumerable
            </summary>
            <typeparam name="T">Type for source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`2.#ctor(System.Func{`0,`1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`0})">
            <summary>
            Creates a new enumerator for a function of one variable to act on a sparse collection
            </summary>
            <param name="fun">The function</param>
            <param name="a">The source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`2.GetSparseEnumerator">
            <summary>
            Gets an enumerator over sparse values
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`3">
            <summary>
            Sparse enumerable generated as a function of the elements of two other sparse enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`3.#ctor(System.Func{`0,`1,`2},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`1})">
            <summary>
            Creates a new enumerator for a function of two variables to act on two sparse collections
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`3.GetSparseEnumerator">
            <summary>
            Gets an enumerator over sparse values
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`4">
            <summary>
            Sparse enumerable generated as a function of the elements of three other sparse enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="T3">Type for third source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`4.#ctor(System.Func{`0,`1,`2,`3},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`2})">
            <summary>
            Creates a new enumerator for a function of three variables to act on three sparse collections
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
            <param name="c">The third source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`4.GetSparseEnumerator">
            <summary>
            Gets an enumerator over sparse values
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`5">
            <summary>
            Sparse enumerable generated as a function of the elements of four other sparse enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="T3">Type for third source enumerable</typeparam>
            <typeparam name="T4">Type for fourth source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`5.#ctor(System.Func{`0,`1,`2,`3,`4},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`2},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`3})">
            <summary>
            Creates a new enumerator for a function of three variables to act on three sparse collections
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
            <param name="c">The third source collection</param>
            <param name="d">The fourth source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`5.GetSparseEnumerator">
            <summary>
            Gets an enumerator over sparse values
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`6">
            <summary>
            Sparse enumerable generated as a function of the elements of four other sparse enumerables
            </summary>
            <typeparam name="T1">Type for first source enumerable</typeparam>
            <typeparam name="T2">Type for second source enumerable</typeparam>
            <typeparam name="T3">Type for third source enumerable</typeparam>
            <typeparam name="T4">Type for fourth source enumerable</typeparam>
            <typeparam name="T5">Type for fifth source enumerable</typeparam>
            <typeparam name="TRes">Type for result</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`6.#ctor(System.Func{`0,`1,`2,`3,`4,`5},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`0},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`1},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`2},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`3},MicrosoftResearch.Infer.Collections.ISparseEnumerable{`4})">
            <summary>
            Creates a new enumerator for a function of three variables to act on three sparse collections
            </summary>
            <param name="fun">The function</param>
            <param name="a">The first source collection</param>
            <param name="b">The second source collection</param>
            <param name="c">The third source collection</param>
            <param name="d">The fourth source collection</param>
            <param name="e">The fifth source collection</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.FuncSparseEnumerable`6.GetSparseEnumerator">
            <summary>
            Gets an enumerator over sparse values
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IntegerPlusOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Int32,System.Int32)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Incoming message from 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Incoming message from 'Sum'.</param>
            <param name="a">Incoming message from 'A'.</param>
            <param name="to_sum">Outgoing message to 'sum'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Sum,A) p(Sum,A) factor(Sum,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Incoming message from 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <param name="to_sum">Outgoing message to 'sum'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Sum,B) p(Sum,B) factor(Sum,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Incoming message from 'Sum'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Sum) p(Sum) factor(Sum,A,B) / sum_Sum p(Sum) messageTo(Sum))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Incoming message from 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(A,B) p(A,B) factor(Sum,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(B) p(B) factor(Sum,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Incoming message from 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(A) p(A) factor(Sum,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogAverageFactor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Sum,A,B))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Incoming message from 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(A,B) p(A,B) factor(Sum,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogEvidenceRatio(System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(B) p(B) factor(Sum,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Incoming message from 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(A) p(A) factor(Sum,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.LogEvidenceRatio(System.Int32,System.Int32,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Sum,A,B))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'Sum'
            </summary>
            <param name="a">Incoming message from 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[p(Sum) sum_(A,B) p(A,B) factor(Sum,A,B)]/p(Sum)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.SumAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'Sum'
            </summary>
            <param name="a">Constant value for 'A'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[p(Sum) sum_(B) p(B) factor(Sum,A,B)]/p(Sum)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'Sum'
            </summary>
            <param name="a">Incoming message from 'A'.</param>
            <param name="b">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Sum' as the random arguments are varied.
            The formula is <c>proj[p(Sum) sum_(A) p(A) factor(Sum,A,B)]/p(Sum)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'A'
            </summary>
            <param name="sum">Incoming message from 'Sum'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'A' as the random arguments are varied.
            The formula is <c>proj[p(A) sum_(Sum,B) p(Sum,B) factor(Sum,A,B)]/p(A)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'A'
            </summary>
            <param name="sum">Incoming message from 'Sum'.</param>
            <param name="b">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'A' as the random arguments are varied.
            The formula is <c>proj[p(A) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(A)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.AAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'A'
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="b">Incoming message from 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'A' as the random arguments are varied.
            The formula is <c>proj[p(A) sum_(B) p(B) factor(Sum,A,B)]/p(A)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.AAverageConditional(System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'A'
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="b">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'A' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'B'
            </summary>
            <param name="sum">Incoming message from 'Sum'.</param>
            <param name="a">Incoming message from 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'B' as the random arguments are varied.
            The formula is <c>proj[p(B) sum_(Sum,A) p(Sum,A) factor(Sum,A,B)]/p(B)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'B'
            </summary>
            <param name="sum">Incoming message from 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'B' as the random arguments are varied.
            The formula is <c>proj[p(B) sum_(Sum) p(Sum) factor(Sum,A,B)]/p(B)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.BAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'B'
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Incoming message from 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'B' as the random arguments are varied.
            The formula is <c>proj[p(B) sum_(A) p(A) factor(Sum,A,B)]/p(B)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntegerPlusOp.BAverageConditional(System.Int32,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'B'
            </summary>
            <param name="sum">Constant value for 'Sum'.</param>
            <param name="a">Constant value for 'A'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'B' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteFromDiscreteOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Discrete(System.Int32,MicrosoftResearch.Infer.Maths.Matrix)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDiscreteOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="selector">Incoming message from 'selector'.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,selector,probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDiscreteOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="selector">Incoming message from 'selector'.</param>
            <param name="probs">Constant value for 'probs'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDiscreteOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="selector">Incoming message from 'selector'.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (selector,probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDiscreteOp.SelectorAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'selector'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'selector'.
            The formula is <c>int f(selector,x) q(x) dx</c> where <c>x = (sample,probs)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1">
            <summary>
            A distribution over a 2D array, where each element is independent and has distribution type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">The distribution type.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.SetToUniform">
            <summary>
            Set the distribution to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.IsUniform">
            <summary>
            True if the distribution is uniform
            </summary>
            <returns>True if all uniform, otherwise false</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.MaxDiff(System.Object)">
            <summary>
            The maximum difference the parameters of this distribution and that distribution
            </summary>
            <param name="that">That distribution array</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2">
            <summary>
            A distribution over an array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Distribution type of an element.  Must be a value type all the way down, i.e. must not hold any references.</typeparam>
            <typeparam name="DomainType">Domain type of an element</typeparam>
            <remarks>
            This is an extension of DistributionArray that implements IDistribution and Sampleable.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.GetLogProb(`1[0:,0:])">
            <summary>
            Gets the log probability density at a point
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.Sample">
            <summary>
            Sample from the distribution
            </summary>
            <returns>A sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.Sample(`1[0:,0:])">
            <summary>
            Sample from the distribution
            </summary>
            <param name="result">Where to put the results</param>
            <returns>A sample</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.Point">
            <summary>
            Sets/gets the 2-D distribution array as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.IsPointMass">
            <summary>
            True if the distribution is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2">
            <summary>
            A distribution over a 2D array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Distribution type of an element.  Must be a value type all the way down, i.e. must not hold any references.</typeparam>
            <typeparam name="DomainType">Domain type of an element</typeparam>
            <remarks>
            This is an extension of DistributionArray that requires T to be a value type.
            This class only exists for efficiency, to avoid unnecessary cloning.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,`0})">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension and initial values.
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="init">Function that maps an index to a value.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(`0,System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension, and a value
            </summary>
            <param name="value"></param>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.Clone">
            <summary>
            Clone the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.MaxDiff(System.Object)">
            <summary>
            The maximum difference in parameters between
            this distribution array and that distribution array
            </summary>
            <param name="that">That distribution array</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.Sample(`1[0:,0:])">
            <summary>
            Sample from the distribution 
            </summary>
            <param name="result">Where to put the result</param>
            <returns>A sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            Set the parameters of this distribution to match those of the given distribution (by value)
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            Set the parameters to represent the product of two distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},System.Boolean)">
            <summary>
            Set the parameters to represent the ratio of two distributions
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},System.Double)">
            <summary>
            Set the parameters to represent the power of a source distribution to some exponent
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            Set the parameters to match the moments of a mixture of two distributions
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2">
            <summary>
            A distribution over a 2D array of type <typeparamref name="DomainType"/>, where each element is independent and has distribution of type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">Distribution type of an element</typeparam>
            <typeparam name="DomainType">Domain type of an element</typeparam>
            <remarks>
            This is an extension of DistributionArray that requires T to be a reference type.
            The SetTo and CopyTo methods are overriden to use cloning instead of assignment.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,`0})">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension and initial values.
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="init">Function that maps an index to a value.</param>
            <returns></returns>
            <remarks>
            The references returned by <paramref name="init"/> are not copied.  They are placed directly into the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(`0,System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension, and a value
            </summary>
            <param name="value"></param>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.InitializeTo(`0[0:,0:])">
            <summary>
            Initialise the values in this 2-D distribution array to clones of the values in a given 2-D array of distributions
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length in each dimension</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetTo(`0[0:,0:])">
            <summary>
            Set the parameters of this distribution so that the marginals match the given distributions (by value)
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length in each dimension</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.InitializeTo(`0)">
            <summary>
            Initialises all the values in this 2-D distribution array to clones of the given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetAllElementsTo(`0)">
            <summary>
            Set the parameters of this distribution so that all marginals equal the given distribution (by value)
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.CopyTo(`0[0:,0:])">
            <summary>
            Set the parameters of array[i,j] to match the marginal distribution of element (i,j), creating a new distribution if array[i,j] was null
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetItemsOf(`0[0:,0:])">
            <summary>
            Set the parameters of array[i,j] to match the marginal distribution of element (i,j)
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetItemsOf(`0[],System.Int32)">
            <summary>
            Set the parameters of array[i] to match the marginal distribution of element i,
            starting at a given index
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.CopyTo(`0[],System.Int32)">
            <summary>
            Set the parameters of array[i] to match the marginal distribution of element i, creating a new distribution if array[i] was null,
            starting at a given index
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.Clone">
            <summary>
            Clone the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.Sample(`1[0:,0:])">
            <summary>
            Get a sample from the distribution
            </summary>
            <param name="result">Where to put the result</param>
            <returns>A sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            Set the parameters of this distribution to match those of the given distribution (by value)
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            Set the parameters to represent the product of two distributions
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},System.Boolean)">
            <summary>
            Set the parameters to represent the ratio of two distributions
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
            <param name="forceProper">Argument passed to T.SetToRatio</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},System.Double)">
            <summary>
            Set the parameters to represent the power of a source distribution to some exponent
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            Set the parameters to match the moments of a mixture of two distributions
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.NonSerializedPropertyAttribute">
            <summary>
            Attribute that can be attached to properties to signal
            that the property should not be serialised
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.ConstructionAttribute">
            <summary>
            Attribute that can be attached to a constructor or factory method, to provide information about
            how to set the parameters of the constructor/method to copy an instance of the object.
            For example, it can indicate that the parameters correspond to properties of the object.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Utils.ConstructionAttribute.TargetMember">
            <summary>
            The construction method
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Utils.ConstructionAttribute.paramMembers">
            <summary>
            The methods/properties to call to get constructor parameters.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.ConstructionAttribute.GetParamValue(System.Int32,System.Object,System.Type@)">
            <summary>
            Gets the value of the constructor parameter at the given index needed to
            reconstruct the supplied instance.
            </summary>
            <param name="instance">The instance</param>
            <param name="paramIndex">The parameter index</param>
            <param name="type">Type of the parameter (output)</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.ConstructionAttribute.IsApplicable(System.Object)">
            <summary>
            Whether this construction attribute should be used for the supplied instance.
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Utils.ConstructionAttribute.cache">
            <summary>
            Cache of construction attributes
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Utils.ConstructionAttribute.Params">
            <summary>
            The names of the properties, fields or methods to call on an object instance
            to get parameter values to construct a duplicate of that instance.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Utils.ConstructionAttribute.UseWhen">
            <summary>
            The name of a boolean property or method on the object instance which
            indicates when this construction method should be used.
            </summary>
            <remarks>
            There are often special case constructors or factory methods which apply
            when an object is in a particular state e.g. when a distribution is uniform.  
            This parameter allows a constructor to be used only when the object is in
            a state, as indicated by a bool property or method e.g. IsUniform().
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide">
            <summary>
            Messages from random variables that are defined by deterministic factors.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide.UsesAverageConditional``1(``0,``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="marginal">Buffer 'marginal'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Uses' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide.MarginalInit``1(``0)">
            <summary>
            Initialise the buffer 'marginal'
            </summary>
            <param name="Def">Incoming message from 'Def'.</param>
            <returns>Initial value of buffer 'marginal'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide.Marginal``1(``0,``0,``0)">
            <summary>
            Update the buffer 'marginal'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_Divide.ToDefInit``1(``0)">
            <summary>
            Initialise the buffer 'toDef'
            </summary>
            <param name="Def">Incoming message from 'Def'.</param>
            <returns>Initial value of buffer 'toDef'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Replicate2BufferOp">
            <summary>
            Messages from random variables that are defined by deterministic factors.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.UsesAverageConditional``1(System.Collections.Generic.IList{``0},``0,``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="marginal">Buffer 'marginal'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Uses' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.UsesAverageConditional``1(``0[],``0,``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="marginal">Buffer 'marginal'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Uses' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.MarginalInit``1(``0)">
            <summary>
            Initialise the buffer 'marginal'
            </summary>
            <param name="Def">Incoming message from 'Def'.</param>
            <returns>Initial value of buffer 'marginal'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.Marginal``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            Update the buffer 'marginal'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.DefAverageConditional``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            EP message to 'Def'
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Def' as the random arguments are varied.
            The formula is <c>proj[p(Def) sum_(Uses) p(Uses) factor(Uses,Def,Marginal)]/p(Def)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Replicate2BufferOp.DefAverageConditional``1(``0[],``0)">
            <summary>
            EP message to 'Def'
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Def' as the random arguments are varied.
            The formula is <c>proj[p(Def) sum_(Uses) p(Uses) factor(Uses,Def,Marginal)]/p(Def)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateBufferOp">
            <summary>
            Messages from random variables that are defined by deterministic factors.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateBufferOp.UsesAverageConditional``1(System.Collections.Generic.IList{``0},``0,``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Uses' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateBufferOp.UsesAverageConditional``1(``0[],``0,``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Uses' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1">
            <summary>
            Messages from random variables that are defined by deterministic factors.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},`0)">
            <summary>
            Gibbs evidence
            </summary>
            <returns></returns>
            <remarks><para>
            Returns 0.0
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.GibbsEvidence``1(System.Collections.Generic.IList{``0},`0)">
            <summary>
            Gibbs evidence
            </summary>
            <returns></returns>
            <remarks><para>
            Returns 0.0
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.UsesGibbs``1(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0},``0,System.Int32,`0)">
            <summary>
            Gibbs sample message to 'Uses'
            </summary>
            <param name="to_marginal">Incoming message from 'Marginal'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="to_marginal"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.UsesGibbs(`0,System.Int32,`0)">
            <summary>
            Gibbs sample message to 'Uses'
            </summary>
            <param name="def">Incoming message from 'Def'.</param>
            <param name="resultIndex">'Uses' index for result (unused)</param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the message from def.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.UsesGibbs``1(``0,System.Int32,``0)">
            <summary>
            Gibbs distribution message to 'Uses'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <param name="def">Incoming message from 'Def'.</param>
            <param name="resultIndex">'Uses' index for result (unused)</param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the message from def.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.DefGibbs``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of all the 'Uses' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.DefGibbs``1(``0[],``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Uses</param>
            <param name="result">Result</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.DefGibbs``1(MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0},`0)">
            <summary>
            Gibbs sample message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="to_marginal">The Gibbs marginal</param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.MarginalGibbs``1(System.Collections.Generic.IList{``0},``0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0})">
            <summary>
            Gibbs message to 'Marginal' for distribution Def
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <returns><paramref name="to_marginal"/></returns>
            <remarks><para>
            The outgoing message is the product of 'Def' and 'Uses' messages.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.MarginalGibbs``1(`0,MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0})">
            <summary>
            Gibbs message to 'Marginal' for sample Def
            </summary>
            <typeparam name="TDist"></typeparam>
            <param name="Def"></param>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <returns><paramref name="to_marginal"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp`1.MarginalGibbs``1(`0[],MicrosoftResearch.Infer.Distributions.GibbsMarginal{``0,`0})">
            <summary>
            Gibbs message to 'Marginal' for sample Uses
            </summary>
            <typeparam name="TDist"></typeparam>
            <param name="Uses"></param>
            <param name="to_marginal">Previous outgoing message to 'marginal'.</param>
            <returns><paramref name="to_marginal"/></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1">
            <summary>
            Provides outgoing Gibbs messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,System.Int32,``0@)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.GibbsEvidence``1(System.Collections.Generic.IList{``0},`0)">
            <summary>
            Gibbs evidence
            </summary>
            <returns></returns>
            <remarks><para>
            Returns 0.0
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.UsesGibbs(`0,System.Int32,`0)">
            <summary>
            Gibbs sample message to 'Uses'
            </summary>
            <param name="def">Incoming message from 'Def'.</param>
            <param name="resultIndex">'Uses' index for result (unused)</param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the message from def.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.UsesGibbs``1(``0,`0,System.Int32,`0)">
            <summary>
            Gibbs sample message to 'Uses'
            </summary>
            <param name="sample">Current sample.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.UsesGibbs``1(System.Collections.Generic.ICollection{``0},``0,System.Int32,``0)">
            <summary>
            Gibbs distribution message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of the 'Def' message with all 'Uses' messages except the current
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateGibbsOp2`1.DefGibbs``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of all the 'Uses' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide">
            <summary>
            Messages from random variables that are defined by deterministic factors.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide.MarginalAverageConditional``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            EP message to 'Marginal'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Marginal' as the random arguments are varied.
            The formula is <c>proj[p(Marginal) sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,Marginal)]/p(Marginal)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide.MarginalAverageConditional``1(``0[],``0,``0)">
            <summary>
            EP message to 'Marginal'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Marginal' as the random arguments are varied.
            The formula is <c>proj[p(Marginal) sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,Marginal)]/p(Marginal)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide.UsesAverageConditional``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Uses' as the random arguments are varied.
            The formula is <c>proj[p(Uses) sum_(Def) p(Def) factor(Uses,Def,Marginal)]/p(Uses)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide.UsesAverageConditional``1(``0[],``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Uses' as the random arguments are varied.
            The formula is <c>proj[p(Uses) sum_(Def) p(Def) factor(Uses,Def,Marginal)]/p(Uses)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide.DefAverageConditional``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            EP message to 'Def'
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Def' as the random arguments are varied.
            The formula is <c>proj[p(Def) sum_(Uses) p(Uses) factor(Uses,Def,Marginal)]/p(Def)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp_NoDivide.DefAverageConditional``1(``0[],``0)">
            <summary>
            EP message to 'Def'
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Def' as the random arguments are varied.
            The formula is <c>proj[p(Def) sum_(Uses) p(Uses) factor(Uses,Def,Marginal)]/p(Def)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateOp">
            <summary>
            Messages from random variables that are defined by deterministic factors.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.LogAverageFactor">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Uses,Def,Marginal))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IList{``0})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(Uses,Def) p(Uses,Def) factor(Uses,Def,Marginal) / sum_Uses p(Uses) messageTo(Uses))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(Uses,Def,Marginal))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.MarginalAverageLogarithm``2(``1,``0)">
            <summary>
            VMP message to 'Marginal'
            </summary>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'Marginal'.
            The formula is <c>exp(sum_(Def) p(Def) log(factor(Uses,Def,Marginal)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.UsesAverageLogarithm``2(``1,System.Int32,``0)">
            <summary>
            VMP message to 'Uses'
            </summary>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Uses' as the random arguments are varied.
            The formula is <c>proj[sum_(Def) p(Def) factor(Uses,Def,Marginal)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.UsesAverageLogarithm``2(``1,``0)">
            <summary>
            VMP message to 'Uses'
            </summary>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'Uses' as the random arguments are varied.
            The formula is <c>proj[sum_(Def) p(Def) factor(Uses,Def,Marginal)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.DefAverageLogarithm``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            VMP message to 'Def'
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Def' with 'Uses' integrated out.
            The formula is <c>sum_Uses p(Uses) factor(Uses,Def,Marginal)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.DefAverageLogarithm``1(``0[],``0)">
            <summary>
            VMP message to 'Def'
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'Def' with 'Uses' integrated out.
            The formula is <c>sum_Uses p(Uses) factor(Uses,Def,Marginal)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateMaxOp.UsesMaxConditional``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>
            Max product message to 'Uses'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateMaxOp.DefMaxConditional``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Max product message to 'Def'
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateMaxOp.MarginalMaxConditional``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            Max product message to 'Marginal'
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MultinomialOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Multinomial(System.Int32,MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
            <remarks>The factor is f(sample,p,n) = n!/prod_k sample[k]!  prod_k p[k]^sample[k]</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Discrete})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,trialCount,p) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.LogAverageFactor(System.Collections.Generic.IList{System.Int32},System.Int32,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <param name="p">Incoming message from 'p'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,p) p(sample,p) factor(sample,trialCount,p))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.LogAverageFactor(System.Collections.Generic.IList{System.Int32},System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <param name="p">Incoming message from 'p'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,p) p(sample,p) factor(sample,trialCount,p))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.LogEvidenceRatio(System.Collections.Generic.IList{System.Int32},System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <param name="p">Incoming message from 'p'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,p) p(sample,p) factor(sample,trialCount,p) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.PAverageConditional(System.Collections.Generic.IList{System.Int32},System.Int32)">
            <summary>
            EP message to 'p'
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <returns>The outgoing EP message to the 'p' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'p' as the random arguments are varied.
            The formula is <c>proj[p(p) sum_(sample) p(sample) factor(sample,trialCount,p)]/p(p)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.AverageLogFactor(System.Collections.Generic.IList{System.Int32},System.Int32,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <param name="p">Incoming message from 'p'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,p) p(sample,p) log(factor(sample,trialCount,p))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.MeanLog(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Update the buffer 'MeanLog'
            </summary>
            <param name="p">Incoming message from 'p'.</param>
            <returns>New value of buffer 'MeanLog'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.AverageLogFactor(System.Collections.Generic.IList{System.Int32},System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <param name="p">Incoming message from 'p'.</param>
            <param name="MeanLog">Buffer 'MeanLog'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,p) p(sample,p) log(factor(sample,trialCount,p))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MultinomialOp.PAverageLogarithm(System.Collections.Generic.IList{System.Int32},System.Int32)">
            <summary>
            VMP message to 'p'
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="trialCount">Constant value for 'trialCount'.</param>
            <returns>The outgoing VMP message to the 'p' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'p'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,trialCount,p)))</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExitingVariableOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.ExitingVariable``1(``0,``0@)"/>, given random arguments to the function.
            </summary>
            <remarks><para>
            This factor is like ReplicateWithMarginal except Uses[0] plays the role of Def, and Def is
            considered a Use.  Needed only when a variable exits a gate in VMP.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateExitingOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.ReplicateExiting``1(``0,System.Int32)"/>, given random arguments to the function.
            </summary>
            <remarks><para>
            This factor is like Replicate except Uses[0] plays the role of Def, and Def is
            considered a Use.  Needed only when a variable exits a gate in VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateExitingOp.UsesAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>
            VMP message to 'Uses'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Uses'.
            The formula is <c>int log(f(Uses,x)) q(x) dx</c> where <c>x = (Def,Marginal)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateExitingOp.DefAverageLogarithm``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            VMP message to 'Def'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Def'.
            The formula is <c>int log(f(Def,x)) q(x) dx</c> where <c>x = (Uses,Marginal)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateExitOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.Exit``1(System.Boolean[],``0[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.LogEvidenceRatio``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <param name="to_exit">Outgoing message to 'exit'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(exit,cases,values) p(exit,cases,values) factor(exit,cases,values) / sum_exit p(exit) messageTo(exit))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ValuesAverageConditional``2(``0,``1)">
            <summary>
            EP message to 'values'
            </summary>
            <param name="exit">Incoming message from 'exit'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'values' as the random arguments are varied.
            The formula is <c>proj[p(values) sum_(exit) p(exit) factor(exit,cases,values)]/p(values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exit"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.CasesAverageConditional``2(``0,System.Collections.Generic.IList{``0},``1)">
            <summary>
            EP message to 'cases'
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'cases' as the random arguments are varied.
            The formula is <c>proj[p(cases) sum_(exit,values) p(exit,values) factor(exit,cases,values)]/p(cases)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageConditional``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>
            EP message to 'exit'
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'exit' as the random arguments are varied.
            The formula is <c>proj[p(exit) sum_(cases,values) p(cases,values) factor(exit,cases,values)]/p(exit)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageConditional2``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>
            EP message to 'exit'.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'exit'.
            The formula is <c>int f(exit,x) q(x) dx</c> where <c>x = (cases,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.CasesAverageConditional``2(``0,System.Collections.Generic.IList{`0},``1)">
            <summary>
            EP message to 'cases'
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'cases' as the random arguments are varied.
            The formula is <c>proj[p(cases) sum_(exit,values) p(exit,values) factor(exit,cases,values)]/p(cases)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageConditional``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{`0},``0)">
            <summary>
            EP message to 'exit'
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'exit' as the random arguments are varied.
            The formula is <c>proj[p(exit) sum_(cases,values) p(cases,values) factor(exit,cases,values)]/p(exit)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.AverageLogFactor``1(``0,``0)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="to_exit">Outgoing message to 'exit'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ValuesAverageLogarithm``2(``0,``1)">
            <summary>
            VMP message to 'values'
            </summary>
            <param name="exit">Incoming message from 'exit'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'values' with 'exit' integrated out.
            The formula is <c>sum_exit p(exit) factor(exit,cases,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exit"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.CasesAverageLogarithm``2(``0,System.Collections.Generic.IList{``0},``1)">
            <summary>
            VMP message to 'cases'
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'cases'.
            Because the factor is deterministic, 'exit' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(values) p(values) log(sum_exit p(exit) factor(exit,cases,values)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp`1.ExitAverageLogarithm``1(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>
            VMP message to 'exit'
            </summary>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'exit' as the random arguments are varied.
            The formula is <c>proj[sum_(cases,values) p(cases,values) factor(exit,cases,values)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateExitTwoOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.ExitTwo``1(System.Boolean,System.Boolean,``0[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ValuesAverageConditional``2(``0,``1)">
            <summary>
            EP message to 'values'
            </summary>
            <param name="exitTwo">Incoming message from 'exitTwo'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'values' as the random arguments are varied.
            The formula is <c>proj[p(values) sum_(exitTwo) p(exitTwo) factor(exitTwo,case0,case1,values)]/p(values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exitTwo"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case0AverageConditional``1(System.Collections.Generic.IList{``0})">
            <summary>
            EP message to 'case0'
            </summary>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'case0' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'case0' as the random arguments are varied.
            The formula is <c>proj[p(case0) sum_(values) p(values) factor(exitTwo,case0,case1,values)]/p(case0)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case1AverageConditional``1(System.Collections.Generic.IList{``0})">
            <summary>
            EP message to 'case1'
            </summary>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'case1' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'case1' as the random arguments are varied.
            The formula is <c>proj[p(case1) sum_(values) p(values) factor(exitTwo,case0,case1,values)]/p(case1)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ExitTwoAverageConditional``1(``0,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``0},``0)">
            <summary>
            EP message to 'exitTwo'
            </summary>
            <param name="exitTwo">Incoming message from 'exitTwo'.</param>
            <param name="case0">Incoming message from 'case0'.</param>
            <param name="case1">Incoming message from 'case1'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'exitTwo' as the random arguments are varied.
            The formula is <c>proj[p(exitTwo) sum_(case0,case1,values) p(case0,case1,values) factor(exitTwo,case0,case1,values)]/p(exitTwo)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case0AverageConditional``2(``0,System.Collections.Generic.IList{``1})">
            <summary>
            EP message to 'case0'
            </summary>
            <param name="exitTwo">Incoming message from 'exitTwo'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <returns>The outgoing EP message to the 'case0' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'case0' as the random arguments are varied.
            The formula is <c>proj[p(case0) sum_(exitTwo,values) p(exitTwo,values) factor(exitTwo,case0,case1,values)]/p(case0)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case1AverageConditional``2(``0,System.Collections.Generic.IList{``1})">
            <summary>
            EP message to 'case1'
            </summary>
            <param name="exitTwo">Incoming message from 'exitTwo'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <returns>The outgoing EP message to the 'case1' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'case1' as the random arguments are varied.
            The formula is <c>proj[p(case1) sum_(exitTwo,values) p(exitTwo,values) factor(exitTwo,case0,case1,values)]/p(case1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ExitTwoAverageConditional``2(``0,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``1},``0)">
            <summary>
            EP message to 'exitTwo'
            </summary>
            <param name="exitTwo">Incoming message from 'exitTwo'.</param>
            <param name="case0">Incoming message from 'case0'.</param>
            <param name="case1">Incoming message from 'case1'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'exitTwo' as the random arguments are varied.
            The formula is <c>proj[p(exitTwo) sum_(case0,case1,values) p(case0,case1,values) factor(exitTwo,case0,case1,values)]/p(exitTwo)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``0},``0)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="exitTwo">Incoming message from 'exitTwo'.</param>
            <param name="case0">Incoming message from 'case0'.</param>
            <param name="case1">Incoming message from 'case1'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <param name="to_exitTwo">Outgoing message to 'exitTwo'.</param>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ValuesAverageLogarithm``2(``0,``1)">
            <summary>
            VMP message to 'values'
            </summary>
            <param name="exitTwo">Incoming message from 'exitTwo'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'values' with 'exitTwo' integrated out.
            The formula is <c>sum_exitTwo p(exitTwo) factor(exitTwo,case0,case1,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exitTwo"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case0AverageLogarithm``1(``0,System.Collections.Generic.IList{``0})">
            <summary>
            VMP message to 'case0'
            </summary>
            <param name="exitTwo">Incoming message from 'exitTwo'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'case0' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'case0'.
            Because the factor is deterministic, 'exitTwo' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(values) p(values) log(sum_exitTwo p(exitTwo) factor(exitTwo,case0,case1,values)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case1AverageLogarithm``1(``0,System.Collections.Generic.IList{``0})">
            <summary>
            VMP message to 'case1'
            </summary>
            <param name="exitTwo">Incoming message from 'exitTwo'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'case1' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'case1'.
            Because the factor is deterministic, 'exitTwo' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(values) p(values) log(sum_exitTwo p(exitTwo) factor(exitTwo,case0,case1,values)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ExitTwoAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``0},``0)">
            <summary>
            VMP message to 'exitTwo'
            </summary>
            <param name="case0">Incoming message from 'case0'.</param>
            <param name="case1">Incoming message from 'case1'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'exitTwo' as the random arguments are varied.
            The formula is <c>proj[sum_(case0,case1,values) p(case0,case1,values) factor(exitTwo,case0,case1,values)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateExitRandomOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.ExitRandom``1(System.Boolean[],``0[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ValuesAverageConditional``1(``0,``0[])">
            <summary>
            Gibbs message to 'values'.
            </summary>
            <param name="exit">Incoming point message from 'Exit'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ValuesAverageConditional``2(``0,``1)">
            <summary>
            Gibbs message to 'values'.
            </summary>
            <param name="exit">Incoming message from 'Exit'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'values'.
            The formula is <c>int log(f(values,x)) q(x) dx</c> where <c>x = (Exit,cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exit"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.CasesAverageConditional``1(``0)">
            <summary>
            Gibbs message to 'cases'.
            </summary>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ExitAverageConditional``1(System.Boolean[],System.Collections.Generic.IList{``0})">
            <summary>
            Gibbs message to 'Exit'
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cases"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (Exit,cases,values)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ValuesAverageLogarithm``2(``0,``1)">
            <summary>
            VMP message to 'values'.
            </summary>
            <param name="exit">Incoming message from 'Exit'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'values'.
            The formula is <c>int log(f(values,x)) q(x) dx</c> where <c>x = (Exit,cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exit"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.CasesAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'cases'.
            </summary>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (Exit,values)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ExitAverageLogarithm``1(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>
            VMP message to 'Exit'.
            </summary>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Exit'.
            The formula is <c>int log(f(Exit,x)) q(x) dx</c> where <c>x = (cases,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IndexOfMaximumOp">
            <summary>
            TODO: comments
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IndexOfMaximumStochasticOp">
            <summary>
            TODO: comments
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromBoolean(System.Boolean,System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.SampleConditional(System.Boolean,System.Double,System.Double)">
            <summary>
            Gibbs message to 'sample'.
            </summary>
            <param name="choice">Constant value for 'choice'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing Gibbs message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.SampleAverageConditional(System.Boolean,System.Double,System.Double)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="choice">Constant value for 'choice'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (choice,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.SampleAverageLogarithm(System.Boolean,System.Double,System.Double)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="choice">Constant value for 'choice'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (choice,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.ChoiceConditional(System.Boolean,System.Double,System.Double)">
            <summary>
            Gibbs message to 'choice'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing Gibbs message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'choice' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.ChoiceAverageConditional(System.Boolean,System.Double,System.Double)">
            <summary>
            EP message to 'choice'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing EP message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'choice'.
            The formula is <c>int f(choice,x) q(x) dx</c> where <c>x = (sample,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.ChoiceAverageLogarithm(System.Boolean,System.Double,System.Double)">
            <summary>
            VMP message to 'choice'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing VMP message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'choice'.
            The formula is <c>int log(f(choice,x)) q(x) dx</c> where <c>x = (sample,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="choice">Incoming message from 'choice'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (choice,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.ChoiceAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double)">
            <summary>
            EP message to 'choice'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing EP message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'choice'.
            The formula is <c>int f(choice,x) q(x) dx</c> where <c>x = (sample,probTrue0,probTrue1)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="choice">Incoming message from 'choice'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (choice,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanOp.ChoiceAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double)">
            <summary>
            VMP message to 'choice'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing VMP message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'choice'.
            The formula is <c>int log(f(choice,x)) q(x) dx</c> where <c>x = (sample,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromBoolean(System.Boolean,System.Double[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[])">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="choice">Incoming message from 'choice'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (choice,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.SampleAverageConditional(System.Boolean,System.Double[])">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="choice">Constant value for 'choice'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (choice,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.ChoiceAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[])">
            <summary>
            EP message to 'choice'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing EP message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'choice'.
            The formula is <c>int f(choice,x) q(x) dx</c> where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[])">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="choice">Incoming message from 'choice'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (choice,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.ChoiceAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[])">
            <summary>
            VMP message to 'choice'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing VMP message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'choice'.
            The formula is <c>int log(f(choice,x)) q(x) dx</c> where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseGPFixed">
            <summary>
            This class maintains all the fixed parameters for a sparse GP
            - i.e. parameters which the inference does not change.
            All SparseGP messages can refer to a single SparseGPFixed
            class, and cloning of SparseGP instances will just copy the
            reference
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.prior">
            <summary>
            field for Prior property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.basis">
            <summary>
            Field for basis property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.kBB">
            <summary>
            Field for calculated KernelOf_B_B property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.invKBB">
            <summary>
            Field for calculated InvKernelOf_B_B property
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.ClearCachedValues">
            <summary>
            Function to signal recalculation of KBB and InvKBB.
            This is be called by the basis and kernel
            function property set functions, and should
            also be called by any external program
            which directly modifies the kernel
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.Recalculate">
            <summary>
            Function to recalulate KBB and InvKBB
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.KernelOf_X_B(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel of a point against the basis
            </summary>
            <param name="x">Input</param>
            <returns>Kernel values</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.KernelOf_X_B(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Evaluates the kernel of a list of points against the basis
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Kernel values</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.#ctor(MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction,System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Constructor from kernel function and basis
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.#ctor(MicrosoftResearch.Infer.Distributions.IGaussianProcess,System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Constructor from prior and basis
            </summary>
            <param name="prior"></param>
            <param name="basis"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.Prior">
            <summary>
            Prior distribution to which basis points are added.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.Basis">
            <summary>
            List of basis vectors
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.KernelOf_B_B">
            <summary>
            Kernel evaluated at the basis points
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.InvKernelOf_B_B">
            <summary>
            Inverse of the kernel evaluated at the basis points
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.NumberFeatures">
            <summary>
            Number of features - i.e. the dimension of the
            GP index space
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.NumberBasisPoints">
            <summary>
            Number of basis points
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.BetaEstimator">
            <summary>
            Estimates a Beta distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BetaEstimator.mva">
            <summary>
            Where to accumulate means and variances
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.#ctor">
            <summary>
            Creates a new Beta estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Gets the estimated distribution
            </summary>
            <param name="result">Where to put the estimated distribution</param>
            <returns>The estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Add(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Adds a Beta item to the estimator
            </summary>
            <param name="distribution">A Beta instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Add(System.Double)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.SetTo(MicrosoftResearch.Infer.Distributions.BetaEstimator)">
            <summary>
            Sets the state of this estimator from the supplied estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Clone">
            <summary>
            Returns a copy of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.SetToProduct``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Set result to the product of all items in list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <param name="list">Must have Count > 1.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.CreateArray``1(System.Int32[])">
            <summary>
            Like <see cref="M:System.Array.CreateInstance(System.Type,System.Int32[])"/> but 5x faster.
            </summary>
            <typeparam name="T">Array element type.</typeparam>
            <param name="lengths"></param>
            <returns>A new array.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.ChangeElementType(System.Type,System.Type)">
            <summary>
            Change the element type of an array type to another type.
            </summary>
            <param name="arrayType">A scalar, array, multidimensional array, or nested array type.</param>
            <param name="newElementType">Any type.</param>
            <returns>A type with the same structure as <paramref name="arrayType"/> but whose element type is <paramref name="newElementType"/></returns>
            <remarks>
            For example, <c>ChangeElementType(typeof(int[,][]), typeof(double))</c> returns
            <c>typeof(double[,][])</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.GetArrayDepth(System.Type,System.Type)">
            <summary>
            The number of indexing brackets needed to turn arrayType into innermostElementType.
            </summary>
            <param name="arrayType"></param>
            <param name="innermostElementType"></param>
            <returns>An integer between 0 and the full depth of arrayType.</returns>
            <remarks>
            For example, if <paramref name="arrayType"/> is <c>int[][]</c> and <paramref name="innermostElementType"/> is <c>int</c>, the
            result is 2. If <paramref name="arrayType"/> is <c>int[][]</c> and <paramref name="innermostElementType"/> is <c>int[]</c>, the
            result is 1. If <paramref name="arrayType"/> is <c>int[][]</c> and <paramref name="innermostElementType"/> is <c>int[][]</c>, the
            result is 0. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.IArrayFromFunc``1(System.Int32,System.Func{System.Int32,``0})">
            <summary>
            Create an implicit array that calls a delegate whenever an element is read
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="length">The length of the array</param>
            <param name="getItem">The delegate to call on every element read</param>
            <returns>An IArray</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.IArrayFromFunc``1(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,``0})">
            <summary>
            Create an implicit 2D array that calls a delegate whenever an element is read
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="length0">The length of the first dimension</param>
            <param name="length1">The length of the second dimension</param>
            <param name="getItem">The delegate to call on every element read</param>
            <returns>An IArray2D</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.CloneInnerException(System.Reflection.TargetInvocationException)">
            <summary>
            Returns a copy of the inner exception of a target invocation exception, preserving the original stack trace.
            </summary>
            <param name="tie"></param>
            <returns>A new Exception</returns>
            <remarks>
            The original stack trace is stored in the InnerException of the returned exception.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.SchemaProvider(System.Xml.Schema.XmlSchemaSet,System.Type,System.Func{System.Xml.Schema.XmlSchemaSet,System.Xml.XmlQualifiedName})">
            <summary>
            Add a schema describing a type to an XmlSchemaSet (for use with XmlSchemaProviderAttribute)
            </summary>
            <param name="xs"></param>
            <param name="className">The name of the XML type to create</param>
            <param name="baseProvider">The SchemaProvider of the base type, if any</param>
            <returns>The qualified name of the XML type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.WriteTypeAttribute(System.Xml.XmlWriter,System.Type)">
            <summary>
            Write attributes describing the type being serialized (for use in ISerializable.WriteXml)
            </summary>
            <param name="writer"></param>
            <param name="type">The type being serialized</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Rand">
            <summary>
            This class provides a source of non-uniform random numbers.
            It cannot be instantiated and consists of only static functions.
            </summary>
            <remarks>A thread-static <c>System.Random</c> object provides the underlying random numbers.</remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Rand._gen">
            <summary>
            Supplies uniform random numbers.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Rand.usePreviousSample">
            <summary>
            If true, Normal() returns previousSample.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Rand.previousSample">
            <summary>
            If usePreviousSample = true, this is the next value Normal() 
            will return.  Otherwise its value is unspecified.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Restart(System.Int32)">
            <summary>
            Restarts the random number sequence.
            </summary>
            <param name="seed">A number used to calculate a starting value for the pseudo-random number sequence.
            If a negative number is specified, the absolute value of the number is used.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Int">
            <summary>
            Generates a non-negative random integer.
            </summary>
            <returns>A random integer &gt;= 0.</returns>
            <remarks>Same as <see cref="M:System.Random.Next"/>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Int(System.Int32)">
            <summary>
            Generates a random integer x, 0 &lt;= x &lt; <paramref name="maxPlus1"/>
            </summary>
            <param name="maxPlus1">Upper bound.  Must be &gt;= 0.</param>
            <returns>A random integer x, 0 &lt;= x &lt; <paramref name="maxPlus1"/>.  If <paramref name="maxPlus1"/> is zero, zero is returned.</returns>
            <remarks>Same as <see cref="M:System.Random.Next(System.Int32)"/>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Int(System.Int32,System.Int32)">
            <summary>
            Generates a random integer x, <paramref name="min"/> &lt;= x &lt; <paramref name="maxPlus1"/>.
            </summary>
            <param name="min">Minimum value.</param>
            <param name="maxPlus1">Maximum value.  Must be &gt;= <paramref name="min"/>.</param>
            <returns>A random integer x, <paramref name="min"/> &lt;= x &lt; <paramref name="maxPlus1"/>.  If <paramref name="maxPlus1"/> == <paramref name="min"/>, <paramref name="min"/> is returned.</returns>
            <remarks>Same as <see cref="M:System.Random.Next(System.Int32,System.Int32)"/>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Double">
            <summary>
            Generates a random double-precision value in [0,1).
            </summary>
            <returns>A random double.</returns>
            <remarks>Same as <see cref="M:System.Random.NextDouble"/>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Perm(System.Int32)">
            <summary>
            Generates a random permutation.
            </summary>
            <param name="n">The length of permutation to make. Must be > 0.</param>
            <returns>An array of <paramref name="n"/> unique integers, each in the range [0,<paramref name="n"/>-1].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Shuffle``1(``0[])">
            <summary>
            Permute the elements of an array.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="array">The array to shuffle.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
            Permute the elements of a list.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="list">The list to shuffle.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Sample(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a finite discrete distribution.
            </summary>
            <param name="prob">prob[i] &gt;= 0 is the probability of outcome i, times an arbitrary constant.</param>
            <returns>An integer from 0 to <c>prob.Count</c>-1.</returns>
            <exception cref="T:MicrosoftResearch.Infer.Maths.AllZeroException">Thrown when prob is all zeros.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Sample(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Generates a random sample from a finite discrete distribution.
            </summary>
            <param name="prob">prob[i] is the probability of outcome i, times <paramref name="sum"/>.  Must be >= 0.</param>
            <param name="sum">The sum of the prob array.  Must be > 0.</param>
            <returns>An integer from 0 to <c>prob.Count</c>-1.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Sample(System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Generates a random sample from a finite discrete distribution.
            </summary>
            <param name="prob">prob[i] is the probability of outcome i, times <paramref name="sum"/>.  Must be >= 0.</param>
            <param name="sum">The sum of the prob array.  Must be > 0.</param>
            <returns>An integer from 0 to <c>prob.Count</c>-1.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Normal">
            <summary>
            Generates a random sample from a normal distribution.
            </summary>
            <returns>A finite real number.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Normal(System.Double,System.Double)">
            <summary>
            Generates a random sample from a normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="stdDev">The standard deviation (sqrt of the variance).</param>
            <returns>A finite real number.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Normal(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a multivariate normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="variance">The covariance matrix.  Must be positive-definite.</param>
            <param name="result">Receives the result.  Must be non-null and the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalP(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a multivariate normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="precision">The inverse of the covariance matrix.  Must be positive-definite.</param>
            <param name="result">Receives the result.  Must be non-null and the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalChol(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a multivariate normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="varChol">The lower triangular Cholesky factor of the covariance matrix.  Must be positive-definite.</param>
            <param name="result">Receives the result.  Must be non-null and the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalPChol(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.UpperTriangularMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a multivariate normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="precCholT">The upper triangular transpose of the Cholesky factor of the precision matrix.  Must be positive-definite.</param>
            <param name="result">Receives the result.  Must be non-null and the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalGreaterThan(System.Double)">
            <summary>
            Sample from a Gaussian(0,1) truncated at the given lower bound
            </summary>
            <param name="lowerBound">The truncation point.  Can be -Infinity.</param>
            <returns>A real number &gt;= <paramref name="lowerBound"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalBetween(System.Double,System.Double)">
            <summary>
            Sample from a Gaussian(0,1) truncated at the given upper and lower bounds
            </summary>
            <param name="lowerBound">Can be -Infinity.</param>
            <param name="upperBound">Must be &gt;= <paramref name="lowerBound"/>.  Can be Infinity.</param>
            <returns>A real number &gt;= <paramref name="lowerBound"/> and &lt; <paramref name="upperBound"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Gamma(System.Double)">
            <summary>
            Generates a random sample from a Gamma distribution.
            </summary>
            <param name="a">The shape parameter.  Must be finite and > 0.</param>
            <returns>A nonnegative finite real number.  May be zero.</returns>
            <remarks>The distribution is defined as p(x) = x^(a-1)*exp(-x)/Gamma(a).
            To incorporate a scale parameter b, multiply the result by b.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Wishart(System.Double,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Generates a random sample from a Wishart distribution.
            </summary>
            <param name="a">The shape parameter.  Must be finite and > 0.</param>
            <param name="result">Receives the lower triangular Cholesky factor of the sampled matrix.  Must be non-null, square, and already allocated to the desired size.</param>
            <remarks><para>
            The <a href="http://en.wikipedia.org/wiki/Wishart_distribution">Wishart distribution</a> 
            is defined as
            </para><para>
            p(X) = |X|^((n-d-1)/2)*exp(-tr(X))/Gamma_d(n/2) (using parameter n)
            </para><para>
            or 
            </para><para>
            p(X) = |X|^(a-(d+1)/2)*exp(-tr(X))/Gamma_d(a) (using parameter a)
            </para><para>
            This routine returns chol(X).  To incorporate a scale parameter C, 
            set Y = chol(C)*X*chol(C)', which implies chol(Y) = chol(C)*chol(X). 
            If you invert and transpose chol(X), then you have chol(inv(X)), 
            where inv(X) is a sample from the inverse Wishart distribution: 
            </para><para>
            p(X) = |X|^(-a-(d+1)/2)*exp(-tr(inv(X)))/Gamma_d(a)
            </para></remarks>
            <example>
            <code>
            Matrix L = new Matrix(d,d);
            Rand.Wishart(a,L);
            Matrix X = new Matrix(d,d);
            X.SetToProduct(L, L.Transpose());
            </code>
            </example>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Beta(System.Double,System.Double)">
            <summary>
            Generates a random sample from the Beta distribution with given parameters.
            </summary>
            <param name="trueCount"></param>
            <param name="falseCount"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Dirichlet(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from the Dirichlet distribution with the given
            pseudo-count
            </summary>
            <param name="pseudoCount">Pseudo-count</param>
            <param name="result">Where to put the result</param>
            <returns>The sample</returns>
            <remarks>If pseudoCount is a sparse vector and the common
            value for the sparse vector is not 0, then the result will be dense; in such
            a case it is recommended that 'result' be a dense vector type.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Binomial(System.Int32,System.Double)">
            <summary>
            Generates a random sample from the Binomial distribution with parameters p and n.
            </summary>
            <param name="n">Number of trials</param>
            <param name="p">Probability of success per trial</param>
            <remarks>
            Reference:
             [1]  L. Devroye, "Non-Uniform Random Variate Generation", 
             Springer-Verlag, 1986.
             [2] Kachitvichyanukul, V., and Schmeiser, B. W. "Binomial Random Variate Generation." 
             Comm. ACM, 31, 2 (Feb. 1988), 216.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Multinomial(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a Multinomial distribution with specified probabilities and number of trials.
            </summary>
            <param name="trialCount">Number of trials, >= 0</param>
            <param name="probs">Must sum to 1</param>
            <returns>An array of length <c>probs.Count</c> of integers between 0 and trialCount, whose sum is trialCount.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Multinomial(System.Int32,MicrosoftResearch.Infer.Maths.DenseVector)">
            <summary>
            Sample from a Multinomial distribution with specified dense vector of probabilities and number of trials.
            </summary>
            <param name="trialCount"></param>
            <param name="probs"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Poisson(System.Double)">
            <summary>
            Sample from a Poisson distribution with specified mean.
            </summary>
            <param name="mean">Must be >= 0</param>
            <returns>An integer in [0,infinity)</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Rand.gen">
            <summary>
            This must be set up as a property to allow correct initialisation across threads
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.AllZeroException">
            <summary>
            Exception type thrown when probability vector = (0,0,0,...,0).
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.AllZeroException.#ctor">
            <summary>
            Constructs the exception.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.AllZeroException.#ctor(System.String)">
            <summary>
            Constructs the exception with a message
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Stochastic">
            <summary>
            When applied to a method, indicates that the method is non-deterministic.
            </summary>
            <remarks>
            A method is non-deterministic if its return value is not completely determined by its arguments.
            For a void method, this attribute is meaningless.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix">
            <summary>
            A subclass of Matrix with extra methods appropriate to positive-definite matrices.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor">
            <summary>
            Parameterless constructor needed for serialization
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a zero matrix of the given dimensions.
            </summary>
            <param name="rows">Number of rows >= 0.</param>
            <param name="cols">Number of columns >= 0.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Constructs a matrix from data in a 2D array.
            </summary>
            <param name="data">2D array of elements.</param>
            <remarks>The 2D array is copied into new storage.
            The size of the matrix is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor(System.Int32,System.Int32,System.Double[])">
            <summary>
            Constructs a matrix by referencing an array.
            </summary>
            <param name="data">Storage for the matrix elements.</param>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Constructs a positive-definite matrix type which references an existing matrix.
            </summary>
            <param name="A">A positive-definite matrix.</param>
            <remarks>This method is similar to a typecast, except it creates a new wrapper around the matrix.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.Identity(System.Int32)">
            <summary>
            Creates a positive-definite identity matrix of a given dimension
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.IdentityScaledBy(System.Int32,System.Double)">
            <summary>
            Creates a positive-definite identity matrix of a given dimension, scaled by a given value
            </summary>
            <param name="dimension"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.Clone">
            <summary>
            Creates a full clone of this positive-definite matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.SetToSum(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets this positive-definite matrix to the sum of two positive-definite matrices.
            Assumes compatible matrices
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.op_Addition(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Add two positive-definite matrices.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <returns>Their sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.op_Multiply(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Multiply matrix times scalar
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>A new matrix with entry [i,j] equal to a[i,j]*b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.Determinant">
            <summary>
            Returns the determinant of this positive-definite matrix.
            </summary>
            <returns>The determinant of <c>this</c>.</returns>
            <remarks>Throws a MatrixSingularException
            if the matrix is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.LogDeterminant(System.Boolean)">
            <summary>
            Returns the natural logarithm of the determinant of this positive-definite matrix.
            </summary>
            <param name="ignoreInfinity">If true, +infinity on the diagonal is treated as 1.</param>
            <returns>The log-determinant of <c>this</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.LogDeterminant(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,System.Boolean)">
            <summary>
            Returns the natural logarithm of the determinant of this positive-definite matrix
            where a lower triangular workspace is passed in.
            </summary>
            <param name="L">A temporary workspace, same size as <c>this</c>.</param>
            <param name="ignoreInfinity">If true, +infinity on the diagonal is treated as 1.</param>
            <returns>The log-determinant.</returns>
            <remarks>Throws a MatrixSingularException
            if the matrix is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.Inverse">
            <summary>
            Returns the inverse of a positive-definite matrix.
            </summary>
            <returns>A new matrix which is the inverse of <c>this</c></returns>
            <remarks>
            Because <c>this</c> is positive definite, it must be 
            invertible, so this routine never throws MatrixSingularException.
            </remarks>
            <exception cref="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException">If <c>this</c> is not positive definite.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.SetToInverse(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets this positive-definite matrix to inverse of a given positive-definite matrix.
            </summary>
            <param name="A">A symmetric positive-definite matrix, same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            Because <paramref name="A"/> is positive definite, it must be 
            invertible, so this routine never throws MatrixSingularException.
            <c>this</c> must already be the correct size to receive the inverse.
            </remarks>
            <exception cref="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException">If <paramref name="A"/> is not positive definite.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.SetToInverse(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Sets this positive-definite matrix to inverse of a given positive-definite matrix
            where a lower triangular workspace is passed.
            </summary>
            <param name="A">A symmetric positive-definite matrix, same size as <c>this</c>.</param>
            <param name="L">A workspace, same size as <paramref name="A"/>.</param>
            <returns><c>this</c></returns>
            <remarks>
            Because <paramref name="A"/> is positive definite, it must be 
            invertible, so this routine never throws MatrixSingularException.
            <c>this</c> must already be the correct size to receive the inverse.
            </remarks>
            <exception cref="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException">If <paramref name="A"/> is not positive definite.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException">
            <summary>
            Exception thrown when a matrix is not positive definite.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException.#ctor">
            <summary>
            Creates a new positive definite matrix exception
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ShiftAlpha">
            <summary>
            Factors that change a message channel's alpha factor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlpha.ToFactor``1(``0,System.Double,System.Double)">
            <summary>
            Changes a message channel's alpha value, going to a factor.
            </summary>
            <typeparam name="T">The domain type.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlpha.FromFactor``1(``0,System.Double,System.Double)">
            <summary>
            Changes a message channel's alpha value, coming from a factor.
            </summary>
            <typeparam name="T">The domain type.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ShiftAlphaToFactorOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.ShiftAlpha.ToFactor``1(``0,System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaToFactorOp.FactorAverageConditional``1(``0,``0,System.Double,System.Double,``0)">
            <summary>
            EP message to 'factor'
            </summary>
            <param name="factor">Incoming message from 'factor'.</param>
            <param name="variable">Incoming message from 'variable'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="variableAlpha">Constant value for 'variableAlpha'.</param>
            <param name="factorAlpha">Constant value for 'factorAlpha'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'factor' as the random arguments are varied.
            The formula is <c>proj[p(factor) sum_(variable) p(variable) factor(factor,variable,variableAlpha,factorAlpha)]/p(factor)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="variable"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaToFactorOp.VariableAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'variable'
            </summary>
            <param name="factor">Incoming message from 'factor'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'variable' as the random arguments are varied.
            The formula is <c>proj[p(variable) sum_(factor) p(factor) factor(factor,variable,variableAlpha,factorAlpha)]/p(variable)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="factor"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaToFactorOp.LogEvidenceRatioOld``1(``0,``0,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="factor">Incoming message from 'factor'.</param>
            <param name="variable">Incoming message from 'variable'.</param>
            <param name="variableAlpha">Constant value for 'variableAlpha'.</param>
            <param name="factorAlpha">Constant value for 'factorAlpha'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (factor,variable,variableAlpha,factorAlpha)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ShiftAlphaFromFactorOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.ShiftAlpha.FromFactor``1(``0,System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaFromFactorOp.FactorAverageConditional``1(``0,``0,System.Double,System.Double,``0)">
            <summary>
            EP message to 'factor'
            </summary>
            <param name="factor">Incoming message from 'factor'.</param>
            <param name="variable">Incoming message from 'variable'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="factorAlpha">Constant value for 'factorAlpha'.</param>
            <param name="variableAlpha">Constant value for 'variableAlpha'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'factor' as the random arguments are varied.
            The formula is <c>proj[p(factor) sum_(variable) p(variable) factor(variable,factor,factorAlpha,variableAlpha)]/p(factor)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="variable"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaFromFactorOp.VariableAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'variable'
            </summary>
            <param name="factor">Incoming message from 'factor'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'variable' as the random arguments are varied.
            The formula is <c>proj[p(variable) sum_(factor) p(factor) factor(variable,factor,factorAlpha,variableAlpha)]/p(variable)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="factor"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaFromFactorOp.LogEvidenceRatioOld``1(``0,``0,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="factor">Incoming message from 'factor'.</param>
            <param name="variable">Incoming message from 'variable'.</param>
            <param name="variableAlpha">Constant value for 'variableAlpha'.</param>
            <param name="factorAlpha">Constant value for 'factorAlpha'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (variable,factor,factorAlpha,variableAlpha)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PoissonOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Poisson(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogAverageFactor(System.Int32,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogEvidenceRatio(System.Int32,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_mean">Outgoing message to 'mean'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="to_mean">Outgoing message to 'mean'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.MeanAverageConditional(System.Int32)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(sample) p(sample) factor(sample,mean)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.SampleAverageConditional(System.Double)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(mean) p(mean) factor(sample,mean)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(mean) p(mean) log(factor(sample,mean))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,mean) p(sample,mean) log(factor(sample,mean))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Poisson,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,mean))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.MeanAverageLogarithm(System.Int32)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.SampleAverageLogarithm(System.Double)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LogOp_EP">
            <summary>
            Provides outgoing messages for <see cref="M:System.Math.Log(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageFactor(System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="log">Constant value for 'log'.</param>
            <param name="d">Constant value for 'd'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(log,d))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogEvidenceRatio(System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="log">Constant value for 'log'.</param>
            <param name="d">Constant value for 'd'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(log,d))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.AverageLogFactor(System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="log">Constant value for 'log'.</param>
            <param name="d">Constant value for 'd'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(log,d))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="log">Constant value for 'log'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(d) p(d) factor(log,d))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="log">Incoming message from 'log'.</param>
            <param name="d">Constant value for 'd'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(log) p(log) factor(log,d))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="log">Incoming message from 'log'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <param name="to_log">Previous outgoing message to 'log'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(d,log) p(d,log) factor(log,d))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="log">Incoming message from 'log'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <param name="to_log">Outgoing message to 'log'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(d,log) p(d,log) factor(log,d) / sum_log p(log) messageTo(log))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="d">Constant value for 'd'.</param>
            <param name="log">Incoming message from 'log'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(log) p(log) factor(log,d) / sum_log p(log) messageTo(log))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.DAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'd'
            </summary>
            <param name="log">Incoming message from 'log'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <param name="to_log">Previous outgoing message to 'log'.</param>
            <returns>The outgoing EP message to the 'd' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'd' as the random arguments are varied.
            The formula is <c>proj[p(d) sum_(log) p(log) factor(log,d)]/p(d)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.DAverageConditional(System.Double)">
            <summary>
            EP message to 'd'
            </summary>
            <param name="log">Constant value for 'log'.</param>
            <returns>The outgoing EP message to the 'd' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'd' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageConditional(System.Double)">
            <summary>
            EP message to 'log'
            </summary>
            <param name="d">Constant value for 'd'.</param>
            <returns>The outgoing EP message to the 'log' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'log' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_EP.LogAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'log'
            </summary>
            <param name="log">Incoming message from 'log'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'log' as the random arguments are varied.
            The formula is <c>proj[p(log) sum_(d) p(d) factor(log,d)]/p(log)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LogOp_VMP">
            <summary>
            Provides VMP messages for <see cref="M:System.Math.Log(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.LogOp_VMP.damping">
            <summary>
            Determines the amount of damping to use on the VMP updates for D. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.LogAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'log'
            </summary>
            <param name="log">Incoming message from 'log'.</param>
            <param name="d">Constant value for 'd'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'log' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.DAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'd'
            </summary>
            <param name="log">Constant value for 'log'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'd' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.LogAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'log'
            </summary>
            <param name="log">Incoming message from 'log'.</param>
            <param name="d">Incoming message from 'd'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'log' as the random arguments are varied.
            The formula is <c>proj[sum_(d) p(d) factor(log,d)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="d"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.DAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'd'
            </summary>
            <param name="log">Incoming message from 'log'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="d">Incoming message from 'd'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_D">Previous outgoing message to 'D'.</param>
            <returns>The outgoing VMP message to the 'd' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'd' with 'log' integrated out.
            The formula is <c>sum_log p(log) factor(log,d)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="d"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="log"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.LogAverageLogarithm(System.Double)">
            <summary>
            VMP message to 'log'
            </summary>
            <param name="d">Constant value for 'd'.</param>
            <returns>The outgoing VMP message to the 'log' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'log' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogOp_VMP.DAverageLogarithm(System.Double)">
            <summary>
            VMP message to 'd'
            </summary>
            <param name="log">Constant value for 'log'.</param>
            <returns>The outgoing VMP message to the 'd' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'd' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartial``1(System.Int32,``0,System.Int32[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.LogEvidenceRatio">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(enterPartial,cases,value,indices))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.LogAverageFactor">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(enterPartial,cases,value,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.EnterPartialAverageConditional``2(``0,``1)">
            <summary>
            EP message to 'enterPartial'
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'enterPartial' as the random arguments are varied.
            The formula is <c>proj[p(enterPartial) sum_(value) p(value) factor(enterPartial,cases,value,indices)]/p(enterPartial)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(enterPartial,cases,value,indices))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp`1.EnterPartialAverageLogarithm``2(``0,``1)">
            <summary>
            VMP message to 'enterPartial'
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'enterPartial' as the random arguments are varied.
            The formula is <c>proj[sum_(value) p(value) factor(enterPartial,cases,value,indices)]</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartialTwo``1(System.Boolean,System.Boolean,``0,System.Int32[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.LogEvidenceRatio">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(enterPartialTwo,case0,case1,value,indices))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.LogAverageFactor">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(enterPartialTwo,case0,case1,value,indices))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.EnterPartialTwoAverageConditional``2(``0,``1)">
            <summary>
            EP message to 'enterPartialTwo'
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'enterPartialTwo' as the random arguments are varied.
            The formula is <c>proj[p(enterPartialTwo) sum_(value) p(value) factor(enterPartialTwo,case0,case1,value,indices)]/p(enterPartialTwo)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.Case0AverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'case0'
            </summary>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'case0' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.Case1AverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'case1'
            </summary>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'case1' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.ValueAverageConditional``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,``0,System.Int32[],``0)">
            <summary>
            EP message to 'value'
            </summary>
            <param name="enterPartialTwo">Incoming message from 'enterPartialTwo'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="case0">Incoming message from 'case0'.</param>
            <param name="case1">Incoming message from 'case1'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'value' as the random arguments are varied.
            The formula is <c>proj[p(value) sum_(enterPartialTwo,case0,case1) p(enterPartialTwo,case0,case1) factor(enterPartialTwo,case0,case1,value,indices)]/p(value)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="enterPartialTwo"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.ValueAverageConditional``2(System.Collections.Generic.IList{``0},System.Boolean,System.Boolean,System.Int32[],``0)">
            <summary>
            EP message to 'value'
            </summary>
            <param name="enterPartialTwo">Incoming message from 'enterPartialTwo'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="case1">Constant value for 'case0'.</param>
            <param name="case2">Constant value for 'case1'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'value' as the random arguments are varied.
            The formula is <c>proj[p(value) sum_(enterPartialTwo,case0,case1) p(enterPartialTwo,case0,case1) factor(enterPartialTwo,case0,case1,value,indices)]/p(value)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="enterPartialTwo"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(enterPartialTwo,case0,case1,value,indices))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.EnterPartialTwoAverageLogarithm``2(``0,``1)">
            <summary>
            VMP message to 'enterPartialTwo'
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'enterPartialTwo' as the random arguments are varied.
            The formula is <c>proj[sum_(value) p(value) factor(enterPartialTwo,case0,case1,value,indices)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.Case0AverageLogarithm``1(System.Collections.Generic.IList{``0},``0,System.Int32[],MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'case0'
            </summary>
            <param name="enterPartialTwo">Incoming message from 'enterPartialTwo'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'case0'.
            Because the factor is deterministic, 'enterPartialTwo' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(value) p(value) log(sum_enterPartialTwo p(enterPartialTwo) factor(enterPartialTwo,case0,case1,value,indices)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.Case1AverageLogarithm``1(System.Collections.Generic.IList{``0},``0,System.Int32[],MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'case1'
            </summary>
            <param name="enterPartialTwo">Incoming message from 'enterPartialTwo'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'case1'.
            Because the factor is deterministic, 'enterPartialTwo' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(value) p(value) log(sum_enterPartialTwo p(enterPartialTwo) factor(enterPartialTwo,case0,case1,value,indices)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.ValueAverageLogarithm``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32[],``0)">
            <summary>
            VMP message to 'value'
            </summary>
            <param name="enterPartialTwo">Incoming message from 'enterPartialTwo'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="case0">Incoming message from 'case0'.</param>
            <param name="case1">Incoming message from 'case1'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'value'.
            Because the factor is deterministic, 'enterPartialTwo' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(case0,case1) p(case0,case1) log(sum_enterPartialTwo p(enterPartialTwo) factor(enterPartialTwo,case0,case1,value,indices)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="enterPartialTwo"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterOne``1(System.Int32,``0,System.Int32)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.LogEvidenceRatio">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(enterOne,cases,value,index))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.LogAverageFactor">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(enterOne,cases,value,index))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.EnterOneAverageConditional``1(``0)">
            <summary>
            EP message to 'enterOne'
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'enterOne' as the random arguments are varied.
            The formula is <c>proj[p(enterOne) sum_(value) p(value) factor(enterOne,cases,value,index)]/p(enterOne)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(enterOne,cases,value,index))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp`1.EnterOneAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'enterOne'
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'enterOne' as the random arguments are varied.
            The formula is <c>proj[sum_(value) p(value) factor(enterOne,cases,value,index)]</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateEnterOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.Enter``1(System.Int32,``0)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GateEnterOp`1.ForceProper">
            <summary>
            Force proper messages
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.LogEvidenceRatio">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(enter,cases,value))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.LogAverageFactor">
            <summary>
            Evidence message for EP
            </summary>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(enter,cases,value))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.EnterAverageConditional``2(``0,``1)">
            <summary>
            EP message to 'enter'
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'enter' as the random arguments are varied.
            The formula is <c>proj[p(enter) sum_(value) p(value) factor(enter,cases,value)]/p(enter)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(enter,cases,value))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp`1.EnterAverageLogarithm``2(``0,``1)">
            <summary>
            VMP message to 'enter'
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'enter' as the random arguments are varied.
            The formula is <c>proj[sum_(value) p(value) factor(enter,cases,value)]</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GammaFromShapeAndRate(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'y'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(y,shape,rate))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'y'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(y,shape,rate))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'y'.</param>
            <param name="to_sample">Outgoing message to 'y'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(y) p(y) factor(y,shape,rate))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'y'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(y) p(y) factor(y,shape,rate) / sum_y p(y) messageTo(y))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'y'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Incoming message from 'rate'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(rate) p(rate) factor(y,shape,rate))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'y'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Incoming message from 'rate'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(rate) p(rate) factor(y,shape,rate))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.SampleAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'y'
            </summary>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>The outgoing EP message to the 'y' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'y' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.RateAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'rate'
            </summary>
            <param name="sample">Constant value for 'y'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <returns>The outgoing EP message to the 'rate' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'rate' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Incoming message from 'rate'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(y,shape,rate) p(y,shape,rate) factor(y,shape,rate))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(y,shape) p(y,shape) factor(y,shape,rate))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Incoming message from 'rate'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(y,rate) p(y,rate) factor(y,shape,rate))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'y'.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Incoming message from 'rate'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(shape,rate) p(shape,rate) factor(y,shape,rate))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'y'.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(shape) p(shape) factor(y,shape,rate))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'y'
            </summary>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Incoming message from 'rate'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'y' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'y' as the random arguments are varied.
            The formula is <c>proj[p(y) sum_(shape,rate) p(shape,rate) factor(y,shape,rate)]/p(y)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            EP message to 'y'
            </summary>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>The outgoing EP message to the 'y' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'y' as the random arguments are varied.
            The formula is <c>proj[p(y) sum_(shape) p(shape) factor(y,shape,rate)]/p(y)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'y'
            </summary>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Incoming message from 'rate'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'y' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'y' as the random arguments are varied.
            The formula is <c>proj[p(y) sum_(rate) p(rate) factor(y,shape,rate)]/p(y)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.RateAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'rate'
            </summary>
            <param name="sample">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'rate' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'rate' as the random arguments are varied.
            The formula is <c>proj[p(rate) sum_(y,shape) p(y,shape) factor(y,shape,rate)]/p(rate)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.RateAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'rate'
            </summary>
            <param name="sample">Constant value for 'y'.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'rate' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'rate' as the random arguments are varied.
            The formula is <c>proj[p(rate) sum_(shape) p(shape) factor(y,shape,rate)]/p(rate)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.RateAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'rate'
            </summary>
            <param name="sample">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <returns>The outgoing EP message to the 'rate' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'rate' as the random arguments are varied.
            The formula is <c>proj[p(rate) sum_(y) p(y) factor(y,shape,rate)]/p(rate)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.ShapeAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'shape'
            </summary>
            <param name="sample">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'shape' as the random arguments are varied.
            The formula is <c>proj[p(shape) sum_(y) p(y) factor(y,shape,rate)]/p(shape)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.ShapeAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'shape'
            </summary>
            <param name="y">Constant value for 'y'.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Incoming message from 'rate'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'shape' as the random arguments are varied.
            The formula is <c>proj[p(shape) sum_(rate) p(rate) factor(y,shape,rate)]/p(shape)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.ShapeAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'shape'
            </summary>
            <param name="y">Constant value for 'y'.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'shape' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.ShapeAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'shape'
            </summary>
            <param name="y">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Incoming message from 'rate'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'shape' as the random arguments are varied.
            The formula is <c>proj[p(shape) sum_(y,rate) p(y,rate) factor(y,shape,rate)]/p(shape)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="y"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'y'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(y,shape,rate))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Incoming message from 'rate'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(y,shape,rate) p(y,shape,rate) log(factor(y,shape,rate))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(y) p(y) log(factor(y,shape,rate))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'y'
            </summary>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Incoming message from 'rate'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'y' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'y'.
            The formula is <c>exp(sum_(shape,rate) p(shape,rate) log(factor(y,shape,rate)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'y'
            </summary>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>The outgoing VMP message to the 'y' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'y'.
            The formula is <c>exp(sum_(shape) p(shape) log(factor(y,shape,rate)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.SampleAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'y'
            </summary>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Incoming message from 'rate'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'y' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'y'.
            The formula is <c>exp(sum_(rate) p(rate) log(factor(y,shape,rate)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'y'
            </summary>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Constant value for 'rate'..</param>
            <returns>The outgoing VMP message to the 'y' argument</returns>
            <remarks><para>
            The message is simply the factor itself.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.RateAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'rate'
            </summary>
            <param name="sample">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'rate' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'rate'.
            The formula is <c>exp(sum_(y,shape) p(y,shape) log(factor(y,shape,rate)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.RateAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'rate'
            </summary>
            <param name="sample">Constant value for 'y'.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'rate' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'rate'.
            The formula is <c>exp(sum_(shape) p(shape) log(factor(y,shape,rate)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.RateAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'rate'
            </summary>
            <param name="sample">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <returns>The outgoing VMP message to the 'rate' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'rate'.
            The formula is <c>exp(sum_(y) p(y) log(factor(y,shape,rate)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.RateAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'rate'
            </summary>
            <param name="sample">Constant value for 'y'..</param>
            <param name="shape">Constant value for 'shape'.</param>
            <returns>The outgoing VMP message to the 'rate' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'rate'.
            The formula is <c>exp(sum_(y) p(y) log(factor(y,shape,rate)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.ShapeAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'shape'
            </summary>
            <param name="sample">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="shape">Incoming message from 'shape'. Must be a proper distribution.  If uniform, the result will be uniform. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="rate">Incoming message from 'rate'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_shape">Previous outgoing message to 'shape'.</param>
            <returns>The outgoing VMP message to the 'shape' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'shape'.
            The formula is <c>exp(sum_(y,rate) p(y,rate) log(factor(y,shape,rate)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="shape"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="rate"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.NonconjugateProjection(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Project the standard VMP message onto a gradient matched Gamma message. 
            </summary>
            <param name="context">Incoming message.</param>
            <param name="gradS">Gradient of S=int factor(x) p(x) dx</param>
            <returns>Projected gamma message</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.twoByTwoInverse(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Two by two matrix inversion. 
            </summary>
            <param name="a">Matrix to invert</param>
            <returns>Inverted matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.CalculateDerivatives(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Calculate derivatives of \int G(x;a,b) LogGamma(x) dx wrt (a,b)
            </summary>
            <param name="q">The Gamma distribution G(x;a,b).</param>
            <returns>A 2-vector containing derivatives of \int G(x;a,b) LogGamma(x) dx wrt (a,b).</returns>
            <remarks><para>
             Calculates expectations in x=log(s) space using Gauss-Hermite quadrature. 
             For each integral the behaviour as x->0 is subtracted from the integrand 
             before performing quadrature to remove the singularity there. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp.ELogGamma(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Calculates \int G(x;a,b) LogGamma(x) dx
            </summary>
            <param name="q">G(x;a,b)</param>
            <returns>\int G(x;a,b) LogGamma(x) dx</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRateOp_Laplace">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GammaFromShapeAndRate(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Distributions.Gamma.SampleFromMeanAndVariance(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromMeanAndVarianceOp.SampleAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="variance">Constant value for 'variance'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp">
            <summary>
            Provides just the operators for constructing Gamma distributions with this parameterisation.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="scale">Constant value for 'scale'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="scale">Constant value for 'scale'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="scale">Constant value for 'scale'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,variance))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message to 'sample'.</param>
            <param name="to_sample">Message sent to 'sample'</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,variance))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="scale">Constant value for 'scale'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndScaleOp.SampleAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="scale">Constant value for 'scale'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator">
            <summary>
            Class for accumulating weighted noisy vector observations,
            and computing sample count, mean vector, and covariance matrix
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.diff">
            <summary>
            Temporary workspace
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Adds an observation 
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Adds a weighted observation.
            </summary>
            <param name="x"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Adds a noisy observation.
            </summary>
            <param name="x"></param>
            <param name="noiseVariance"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.#ctor(System.Int32)">
            <summary>
            Constructs an accumulator for vector observations
            </summary>
            <param name="dimension"></param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Count">
            <summary>
            Count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Mean">
            <summary>
            Mean
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Variance">
            <summary>
            Covariance
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Dimension">
            <summary>
            The dimensionality of the vector
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.ARD">
            <summary>
            Automatic Relevance Determination Kernel
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.SetupParams(System.Double[],System.Double)">
            <summary>
            Sets up names and values of parameters
            </summary>
            <param name="logLengths">Log of the lengths</param>
            <param name="logSigVar">Log of the signal variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.#ctor(System.Double[],System.Double)">
            <summary>
            Constructs an ARD kernel from a vector of log lengths, and a log signal variance
            </summary>
            <param name="logLengths"></param>
            <param name="logSigVar"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.InitialiseFromData(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Initialises the parameters from data
            </summary>
            <param name="X">X data - initialises lengths</param>
            <param name="y">y data - initialises signal standard deviation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.Read(System.IO.StreamReader)">
            <summary>
            Reads the parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.ARD.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.ARD.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GammaPower">
            <summary>
            The distribution of a Gamma variable raised to a power.  The Weibull distribution is a special case.
            </summary>
            <remarks><para>
            The Gamma-power distribution is defined as the distribution of a Gamma(a,b) variable raised to the power c.  
            Thus it has three parameters (a,b,c) and probability density function
            <c>p(x) = x^(a/c-1)*exp(-b*x^(1/c))*b^a/Gamma(a)/abs(c)</c>.
            In this implementation, the <c>a</c> parameter is called the "Shape", the <c>b</c> parameter
            is called the "Rate", and the <c>c</c> parameter is called the "Power".  
            The power can be any real number, positive or negative.
            The distribution is sometimes also parameterized by (shape,scale,power) where scale = 1/rate.
            </para><para>
            Special cases:
            When the power is 1 it reduces to a Gamma distribution.
            When the shape is 1 it reduces to a Weibull distribution.
            When the shape equals the power and rate is 0, the distribution is uniform.
            When the shape is infinity, the distribution is a point mass and the density is delta(x-Point)
            where the Point property gives the mean.
            When the power is zero, the distribution is a point mass at one.
            When a &lt;= 0 or b &lt;= 0 the <c>b^a/Gamma(a)/abs(c)</c> term is dropped.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GammaPower.Rate">
            <summary>
            Rate parameter for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GammaPower.Shape">
            <summary>
            Shape parameter for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GammaPower.Power">
            <summary>
            Power parameter for the distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetMean">
            <summary>
            Get the expected value E(x)
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetVariance">
            <summary>
            Get the variance
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Get the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Set the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.FromMeanAndVariance(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new Gamma distribution from mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new Gamma instance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetShapeAndRate(System.Double,System.Double,System.Double)">
            <summary>
            Sets the shape and rate (rate = 1/scale) parameters of the distribution.
            </summary>
            <param name="shape"></param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.FromShapeAndRate(System.Double,System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and rate parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="rate">rate = 1/scale</param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetShapeAndScale(System.Double,System.Double,System.Double)">
            <summary>
            Sets the shape and scale for this instance
            </summary>
            <param name="shape">Shape</param>
            <param name="scale">Scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.FromShapeAndScale(System.Double,System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and scale parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="scale">scale</param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetMeanLog">
            <summary>
            Computes E[log(x)]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetMeanPower(System.Double)">
            <summary>
            Computes E[x^power]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing Rate parameter
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetToUniform">
            <summary>
            Set shape and rate to be a uniform distribution, without changing the power.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetLogProb(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Logarithm of the density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate parameter</param>
            <param name="power">Power parameter</param>
            <returns>log(GammaPower(x;shape,rate,power))</returns>
            <remarks>
            The distribution is <c>p(x) = x^(a/c-1)*exp(-b*x^(1/c))*b^a/Gamma(a)/abs(c)</c>.
            When a &lt;= 0 or b &lt;= 0 or c = 0 the <c>b^a/Gamma(a)/abs(c)</c> term is dropped.
            Thus if shape = 1 and rate = 0 the density is 1.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetLogProb(System.Double)">
            <summary>
            Logarithm of the density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <returns>log(Gamma(x;shape,rate,power))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetLogNormalizer">
            <summary>
            Gets log normalizer
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetAverageLog(MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.IsProper">
            <summary>
            Asks whether this Gamma instance is proper or not. A Gamma distribution
            is proper only if Shape > 0 and Rate > 0.
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.IsProper(System.Double,System.Double)">
            <summary>
            Asks whether a Gamma distribution is proper or not. A Gamma distribution
            is proper only if Shape > 0 and Rate > 0.
            </summary>
            <param name="shape">shape parameter for the Gamma</param>
            <param name="rate">rate parameter for the Gamma</param>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            The log of the integral of the product of this Gamma and that Gamma
            </summary>
            <param name="that">That Gamma</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetLogAverageOfPower(MicrosoftResearch.Infer.Distributions.GammaPower,System.Double)">
            <summary>
            Get the integral of this distribution times another distribution raised to a power.
            </summary>
            <param name="that"></param>
            <param name="power"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.Sample">
            <summary>
            Draw a sample from the distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.Sample(System.Double)">
            <summary>
            Samples from this Gamma distribution
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.Sample(System.Double,System.Double,System.Double)">
            <summary>
            Samples from a Gamma distribution with given shape and scale
            </summary>
            <param name="shape">shape parameter</param>
            <param name="scale">scale parameter</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SampleFromMeanAndVariance(System.Double,System.Double,System.Double)">
            <summary>
            Samples from a Gamma distribution with given mean and variance
            </summary>
            <param name="mean">mean parameter</param>
            <param name="variance">variance parameter</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetTo(MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Set this distribution to have the same parameter values as that
            </summary>
            <param name="that">the source parameters</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetToProduct(MicrosoftResearch.Infer.Distributions.GammaPower,MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Set the parameters so that the density function equals the product of two given GammaPower density functions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution.  Must have the same power parameter as <paramref name="a"/></param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.op_Multiply(MicrosoftResearch.Infer.Distributions.GammaPower,MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Creates a new GammaPower distribution whose density function equals the product of two other GammaPower density functions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution.  Must have the same power parameter as <paramref name="a"/></param>
            <returns>Result.  May not be proper.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetToRatio(MicrosoftResearch.Infer.Distributions.GammaPower,MicrosoftResearch.Infer.Distributions.GammaPower,System.Boolean)">
            <summary>
            Sets the parameters so that the density function equals the ratio of two given GammaPower density functions
            </summary>
            <param name="numerator">The numerator distribution. Can be the same object as this.</param>
            <param name="denominator">The denominator distribution.  Must have the same power parameter as <paramref name="numerator"/></param>
            <param name="forceProper">If true, the result has shape >= power and rate >= 0</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.op_Division(MicrosoftResearch.Infer.Distributions.GammaPower,MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Creates a new GammaPower distribution whose density function equals the ratio of two other GammaPower density functions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution.  Must have the same power parameter as <paramref name="numerator"/></param>
            <returns>Result. May not be proper.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetToPower(MicrosoftResearch.Infer.Distributions.GammaPower,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source distribution to some exponent.
            </summary>
            <param name="dist">The source distribution</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.GammaPower,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.GammaPower,System.Double,MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Sets the mean and variance to match a mixture of two GammaPower distributions.
            </summary>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this distribution and that distribution
            </summary>
            <param name="thatd">distribution to compare to</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            Array of distribution requiring the distribution type to be a value type.
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.op_Equality(MicrosoftResearch.Infer.Distributions.GammaPower,MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.op_Inequality(MicrosoftResearch.Infer.Distributions.GammaPower,MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates a GammaPower distribution with given shape and scale parameters (scale = 1/rate) 
            </summary>
            <param name="shape"></param>
            <param name="scale">scale = 1/rate</param>
            <remarks>
            The distribution is <c>p(x) = x^(shape-1)*exp(-x/scale)/(scale^shape * Gamma(shape))</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.#ctor(MicrosoftResearch.Infer.Distributions.GammaPower)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.Clone">
            <summary>
            Clones this object. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a GammaPower type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.Uniform(System.Double)">
            <summary>
            Create a uniform GammaPower distribution.
            </summary>
            <returns>A new uniform GammaPower distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.PointMass(System.Double,System.Double)">
            <summary>
            Creates a point mass Gamma distribution
            </summary>
            <param name="mean">The location of the point mass</param>
            <returns>A new point mass Gamma distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaPower.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GammaPower.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GammaPower.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.BernoulliEstimator">
            <summary>
            Estimates a Bernoulli distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.N">
            <summary>
            Number of samples
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.NProbTrue">
            <summary>
            Number of samples with value true
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Gets the estimated distribution
            </summary>
            <param name="result">A place to put the resulting distribution. This is ignored because Bernoulli is a struct</param>
            <returns>The estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.Add(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Adds a distribution item to the estimator
            </summary>
            <param name="distribution">A Bernoulli distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.Add(System.Boolean)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="sample">The sample - true or false</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.Clone">
            <summary>
            Returns a copy of the estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.SetTo(MicrosoftResearch.Infer.Distributions.BernoulliEstimator)">
            <summary>
            Sets this estimator's state from the supplied estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet">
            <summary>
            Represents the distribution proportion to x^{Shape-1} exp(-Rate*x) / B(x,D)^K
            where B(x,D)=Gamma(x)^D/Gamma(D*x)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.errorMessage">
            <summary>
            Error message for proposal distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Rate">
            <summary>
            Rate parameter for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Shape">
            <summary>
            Shape parameter for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.D">
            <summary>
            Parameter D for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.K">
            <summary>
            Parameter K for the distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetMean">
            <summary>
            Gets the expected value E(x) - calculated as shape/rate
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetVariance">
            <summary>
            Gets the variance - calculated as shape/rate^2
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GammaApproximation">
            <summary>
            This is an asymptotic approximation to this distribution, derived from the Rocktaeschel approximation:
            ln Gamma(x) \approx (x-.5)*ln(x) - x +.5*ln(2*pi)
            </summary>
            <returns>A gamma approximation to this distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SmartProposal(System.Double@,System.Double@)">
            <summary>
            Find a Laplace approximation to the density of this distribution under a change of variable x=log(y)
            </summary>
            <param name="mean">Mean of approximation</param>
            <param name="variance">Variance of approximation</param>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.approximationMethod">
            <summary>
            Approximation method to use for non-analytic expectations. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance. Note for K!=0 this requires quadrature. 
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a new Gamma distribution from mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new Gamma instance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetShapeAndRate(System.Double,System.Double)">
            <summary>
            Sets the shape and rate (rate = 1/scale) parameters of the distribution.
            </summary>
            <param name="shape"></param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.FromShapeAndRate(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and rate parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="rate">rate = 1/scale</param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetScale">
            <summary>
            Gets the scale (1/rate)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetShapeAndScale(System.Double@,System.Double@)">
            <summary>
            Gets the shape and scale (1/rate)
            </summary>
            <param name="shape">Where to put the shape</param>
            <param name="scale">Where to put the scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetShapeAndScale(System.Double,System.Double)">
            <summary>
            Sets the shape and scale for this instance
            </summary>
            <param name="shape">Shape</param>
            <param name="scale">Scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.FromShapeAndScale(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and scale parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="scale">scale</param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.FromMeanAndMeanLog(System.Double,System.Double)">
            <summary>
            Constructs a Conjugate Dirichlet distribution with the given mean and mean logarithm.
            </summary>
            <param name="mean">Desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <returns>A new Gamma distribution.</returns>
            <remarks>This function is equivalent to maximum-likelihood estimation of a Gamma distribution
            from data given by sufficient statistics.
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization. The algorithm is a generalized Newton iteration, 
            described in "Estimating a Gamma distribution" by T. Minka, 2002.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.FromLogMeanAndMeanLog(System.Double,System.Double)">
            <summary>
            Constructs a Conjugate Dirichlet distribution with the given log mean and mean logarithm.
            </summary>
            <param name="logMean">Log of desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <returns>A new Gamma distribution.</returns>
            <remarks>
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization. The algorithm is a generalized Newton iteration, 
            described in "Estimating a Gamma distribution" by T. Minka, 2002.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetNatural(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Sets the natural parameters of the distribution.
            </summary>
            <param name="shapeMinus1">The shape parameter - 1.</param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetMeanLog">
            <summary>
            Computes E[log(x)] using quadrature if necessary
            </summary>
            <returns>E[log(x)]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetMeanLogGamma(System.Double)">
            <summary>
             Compute E[log G(factor * x)] using quadrature
            </summary>
            <param name="factor">Multiplier for x</param>
            <returns>E[log G(factor * x)]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetMeanInverse">
            <summary>
            Computes E[1/x]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetMeanPower(System.Double)">
            <summary>
            Computes E[x^power]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing Rate parameter
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetToUniform">
            <summary>
            Sets this Conjugate Dirichlet instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetLogProb(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Logarithm of the Conjugate Dirichlet density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate parameter</param>
            <param name="D">D parameter</param>
            <param name="K">K parameter</param>
            <returns>log(Conjugate Dirichlet(x;shape,rate,D,K))</returns>
            <remarks>
            The distribution is <c>x^{Shape-1} exp(-Rate*x) / B(x,D)^K
            where B(x,D)=Gamma(x)^D/Gamma(D*x)</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetLogProb(System.Double)">
            <summary>
            Logarithm of this Conjugate Dirichlet density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <returns>log(Conjugate Dirichlet(x))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetLogNormalizer">
            <summary>
            Gets log normalizer
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetAverageLog(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.IsProper">
            <summary>
            Asks whether this Conjugate Dirichlet instance is proper or not. A Conjugate Dirichlet distribution
            is proper if it's approximating gamma is proper
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.IsProper(System.Double,System.Double)">
            <summary>
            Asks whether a Conjugate Dirichlet distribution is proper or not. A Conjugate Dirichlet distribution
            is proper only if Shape > 0 and Rate > 0.
            </summary>
            <param name="shape">shape parameter for the Conjugate Dirichlet</param>
            <param name="rate">rate parameter for the Conjugate Dirichlet</param>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            The log of the integral of the product of this Conjugate Dirichlet and that Conjugate Dirichlet
            </summary>
            <param name="that">That Conjugate Dirichlet</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Sample">
            <summary>
            Samples from this Conjugate Dirichlet distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Sample(System.Double)">
            <summary>
            Samples from this Conjugate Dirichlet distribution
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Sample(System.Double,System.Double)">
            <summary>
            Samples from a Conjugate Dirichlet distribution with given shape and scale
            </summary>
            <param name="shape">shape parameter</param>
            <param name="scale">scale parameter</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SampleFromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Samples from a Conjugate Dirichlet distribution with given mean and variance
            </summary>
            <param name="mean">mean parameter</param>
            <param name="variance">variance parameter</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetTo(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Sets this Conjugate Dirichlet instance to have the parameter values of that Conjugate Dirichlet instance
            </summary>
            <param name="that">That Conjugate Dirichlet</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetToProduct(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Sets the parameters to represent the product of two Gammas.
            </summary>
            <param name="a">The first Conjugate Dirichlet</param>
            <param name="b">The second Conjugate Dirichlet</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.op_Multiply(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Creates a new Conjugate Dirichlet which the product of two other Conjugate Dirichlets
            </summary>
            <param name="a">First Conjugate Dirichlet</param>
            <param name="b">Second Conjugate Dirichlet</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetToRatio(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,System.Boolean)">
            <summary>
            Sets the parameters to represent the ratio of two Conjugate Dirichlets.
            </summary>
            <param name="numerator">The numerator Conjugate Dirichlet</param>
            <param name="denominator">The denominator Conjugate Dirichlet</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.op_Division(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Creates a new Conjugate Dirichlet which the ratio of two other Conjugate Dirichlets
            </summary>
            <param name="numerator">numerator Conjugate Dirichlet</param>
            <param name="denominator">denominator Conjugate Dirichlet</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetToPower(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source Conjugate Dirichlet to some exponent.
            </summary>
            <param name="dist">The source Conjugate Dirichlet</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,System.Double,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Set the mean and variance to match a mixture of two Gammas.
            </summary>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first Conjugate Dirichlet</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second Conjugate Dirichlet</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Conjugate Dirichlet
            and that Conjugate Dirichlet
            </summary>
            <param name="thatd">That Conjugate Dirichlet</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            Array of distribution requiring the distribution type to be a value type.
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.op_Equality(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.op_Inequality(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet,MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Not equals operator
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a Conjugate Dirichlet distribution with given shape and scale parameters (scale = 1/rate) 
            </summary>
            <param name="shape"></param>
            <param name="scale">scale = 1/rate</param>
            <remarks>
            The distribution is <c>x^{Shape-1} exp(-Rate*x) / B(x,D)^K
            where B(x,D)=Gamma(x)^D/Gamma(D*x)</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.FromNatural(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a Conjugate Dirichlet distribution from its natural parameters.
            </summary>
            <param name="shapeMinus1">shape - 1</param>
            <param name="rate">rate = 1/scale</param>
            <returns>A new Conjugate Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.#ctor(MicrosoftResearch.Infer.Distributions.ConjugateDirichlet)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Clone">
            <summary>
            Clones this Conjugate Dirichlet. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Conjugate Dirichlet type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Uniform">
            <summary>
            Create a uniform Conjugate Dirichlet distribution.
            </summary>
            <returns>A new uniform Conjugate Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.PointMass(System.Double)">
            <summary>
            Creates a point mass Conjugate Dirichlet distribution
            </summary>
            <param name="mean">The location of the point mass</param>
            <returns>A new point mass Conjugate Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ApproximationMethod">
            <summary>
            Approximation method to use for non-analytic expectations. 
            Asymptotic: use expectations under the approximating Gamma distribution
            GaussHermiteQuadrature: Use Gauss-Hermite quadrature with 32 quadrature points
            ClenshawCurtisQuadrature: Use Clenshaw Curtis quadrature with an adaptive number of quadrature points
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ApproximationMethod.Asymptotic">
            <summary>
            Uses the approximation Gamma(Shape+K(D-1)/2,Rate-KDlogD)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ApproximationMethod.GaussHermiteQuadrature">
            <summary>
            Gaussian Hermite quadrature, using Asymptotic as the proposal distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ApproximationMethod.ClenshawCurtisQuadrature">
            <summary>
            Clenshaw Curtis Quadrature
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ApproximationMethod.GaussLaguerreQuadrature">
            <summary>
            Gauss Laguerre Quadrature
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.ConjugateDirichlet.ApproximationMethod.GaussHermiteQuadratureLaplace">
            <summary>
            Gaussian Hermite quadrature, using Asymptotic as the proposal distribution if shape less than 1 and 
            Laplace approximation as the proposal distribution otherwise
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.AssertFailedException">
            <summary>
            Thrown when Assert.IsTrue fails.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.Assert">
            <summary>
            Assertion methods for debugging.
            </summary>
            <remarks>To catch assertion failures in the debugger:
            Debug -> Exceptions -> Add
            Microsoft.VisualStudio.TestTools.UnitTesting.AssertFailedException
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Assert.IsTrue(System.Boolean,System.String)">
            <summary>
            Checks if a condition is true; if not, an exception is thrown with an error message.
            </summary>
            <param name="condition">Condition that must be true</param>
            <param name="message">Message to be output by the exception</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Assert.IsTrue(System.Boolean)">
            <summary>
            Checks if a condition is true; if not, an exception  without error message is thrown.
            </summary>
            <param name="condition">Condition that must be true</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.AssertWhenDebugging">
            <summary>
            Assertion methods which are stripped out in release mode.
            </summary>
            <remarks>To catch assertion failures in the debugger:
            Debug -> Exceptions -> Add
            Microsoft.VisualStudio.TestTools.UnitTesting.AssertFailedException
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.AssertWhenDebugging.IsTrue(System.Boolean,System.String)">
            <summary>
            Checks if a condition is true; if not, an exception is thrown with an error message.
            </summary>
            <param name="condition">Condition that must be true</param>
            <param name="message">Message to be output by the exception</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.AssertWhenDebugging.IsTrue(System.Boolean)">
            <summary>
            Checks if a condition is true; if not, an exception  without error message is thrown.
            </summary>
            <param name="condition">Condition that must be true</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.NonconjugateUsesEqualDefOp">
            <summary>
            UsesEqualDef operator to combine Gaussian and nonconjugate messages. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.NonconjugateUsesEqualDefOp.UsesAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,System.Double}[],MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP Messages to Uses
            </summary>
            <param name="Uses">Nonconjugate messages from uses</param>
            <param name="Def">Gaussian message from Defintion</param>
            <param name="result">Previous message</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.NonconjugateUsesEqualDefOp.MarginalAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.NonconjugateGaussian,System.Double}[],MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            The marginal distribution is the same as the message to uses.  
            </summary>
            <param name="Uses"></param>
            <param name="Def"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.AllTrueOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.AllTrue(System.Collections.Generic.IList{System.Boolean})"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogAverageFactor(System.Boolean,System.Collections.Generic.IList{System.Boolean})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="allTrue">Constant value for 'allTrue'.</param>
            <param name="array">Constant value for 'array'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(allTrue,array))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogEvidenceRatio(System.Boolean,System.Collections.Generic.IList{System.Boolean})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="allTrue">Constant value for 'allTrue'.</param>
            <param name="array">Constant value for 'array'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(allTrue,array))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.AverageLogFactor(System.Boolean,System.Collections.Generic.IList{System.Boolean})">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="allTrue">Constant value for 'allTrue'.</param>
            <param name="array">Constant value for 'array'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(allTrue,array))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="allTrue">Incoming message from 'allTrue'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_allTrue">Outgoing message to 'allTrue'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(allTrue) p(allTrue) factor(allTrue,array))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="allTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogAverageFactor(System.Boolean,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="allTrue">Constant value for 'allTrue'.</param>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(array) p(array) factor(allTrue,array))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="allTrue">Incoming message from 'allTrue'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks>returns 0</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogEvidenceRatio(System.Boolean,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="allTrue">Constant value for 'allTrue'.</param>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence.</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(array) p(array) factor(allTrue,array))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.AllTrueAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            EP message to 'allTrue'.
            </summary>
            <param name="array">Incoming message from 'array'.</param>
            <returns>The outgoing EP message to the 'allTrue' argument.</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'allTrue' as the random arguments are varied.
            The formula is <c>proj[p(allTrue) sum_(array) p(array) factor(allTrue,array)]/p(allTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.AllTrueAverageConditional(System.Collections.Generic.IList{System.Boolean})">
            <summary>
            EP message to 'allTrue'.
            </summary>
            <param name="array">Constant value for 'array'.</param>
            <returns>The outgoing EP message to the 'allTrue' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'allTrue' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},``0)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="allTrue">Incoming message from 'allTrue'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(allTrue) p(allTrue) factor(allTrue,array)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="allTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.ArrayAverageConditional``1(System.Boolean,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},``0)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="allTrue">Constant value for 'allTrue'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{System.Boolean},``0)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="allTrue">Incoming message from 'allTrue'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="array">Constant value for 'array'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(allTrue) p(allTrue) factor(allTrue,array)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="allTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.AllTrueAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            VMP message to 'allTrue'.
            </summary>
            <param name="array">Incoming message from 'array'.</param>
            <returns>The outgoing VMP message to the 'allTrue' argument.</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'allTrue' as the random arguments are varied.
            The formula is <c>proj[sum_(array) p(array) factor(allTrue,array)]</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},``0)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="allTrue">Incoming message from 'allTrue'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'allTrue' integrated out.
            The formula is <c>sum_allTrue p(allTrue) factor(allTrue,array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="allTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.ArrayAverageLogarithm``1(System.Boolean,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},``0)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="allTrue">Constant value for 'allTrue'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            In Variational Message Passing, the evidence contribution of a deterministic factor is zero.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.MatlabWriter">
            <summary>
            Write data objects to a MAT file
            </summary>
            <remarks>
            The MAT file format is defined in <a href="http://www.mathworks.com/access/helpdesk/help/pdf_doc/matlab/matfile_format.pdf">The MAT file format</a>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.#ctor(System.String)">
            <summary>
            Create a MatlabWriter to write to a given file name.
            </summary>
            <param name="fileName">The file name to write to (will be created if missing, or truncated if already exists)</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.Byte[])">
            <summary>
            Write an array of bytes to the stream
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Int32)">
            <summary>
            Write a string value with zero padding to write numBytes in total.
            </summary>
            <param name="value"></param>
            <param name="numBytes"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Object)">
            <summary>
            Write a named object to the stream
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Collections.Generic.IList{System.Boolean})">
            <summary>
            Write a named bool array to the stream
            </summary>
            <param name="name"></param>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Collections.Generic.IList{System.Int32})">
            <summary>
            Write a named int array to the stream
            </summary>
            <param name="name"></param>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Double)">
            <summary>
            Write a named scalar to the stream
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Collections.Generic.IList{System.Double})">
            <summary>
            Write a named vector to the stream
            </summary>
            <param name="name"></param>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Collections.Generic.IList{System.Object})">
            <summary>
            Write a named cell vector to the stream
            </summary>
            <param name="name"></param>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Write a named Matrix to the stream
            </summary>
            <param name="name">Name of the matrix.</param>
            <param name="matrix">A matrix.</param>
            <param name="imaginary">If writing a complex matrix, the imaginary part of the matrix.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,MicrosoftResearch.Infer.Utils.MatlabReader.ComplexMatrix)">
            <summary>
            Write a named ComplexMatrix to the stream
            </summary>
            <param name="name"></param>
            <param name="matrix"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Write a named struct to the stream
            </summary>
            <param name="name"></param>
            <param name="dict"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.Object[0:,0:])">
            <summary>
            Write a named cell array to the stream
            </summary>
            <param name="name"></param>
            <param name="dict"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Write(System.String,System.String)">
            <summary>
            Write a named string to the stream
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.MakeValidVariableName(System.String)">
            <summary>
            Converts a variable name to a valid variable name by changing all invalid characters to an underscore.
            </summary>
            <param name="name">Variable name</param>
            <returns>A valid MATLAB variable name.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Matlab5Header(System.String)">
            <summary>
            Generate a Matlab V5 compatible header byte array
            </summary>
            <param name="comments">The comments that will go into the header of the Matlab file.</param>
            <returns>The header as a byte array.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Dispose">
            <summary>
            Release the stream used by a MatlabWriter
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.MatType">
            <summary>
            A number type in a MAT file
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.mxClass">
            <summary>
            An object class in a MAT file
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.MatlabReader">
            <summary>
            Reads the contents of a MAT file.
            </summary>
            <remarks>
            The MAT file format is defined in <a href="http://www.mathworks.com/access/helpdesk/help/pdf_doc/matlab/matfile_format.pdf">The MAT file format</a>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.#ctor(System.String)">
            <summary>
            Create a MatlabReader that reads from the given file name.
            </summary>
            <param name="fileName">The MAT file name to read from</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.#ctor(System.IO.Stream)">
            <summary>
            Create a MatlabReader that reads from the given stream.
            </summary>
            <param name="reader">The stream to read from</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.Read(System.String)">
            <summary>
            Read all variables from a file and store them in a dictionary
            </summary>
            <param name="fileName">The name of a MAT file</param>
            <returns>A dictionary that maps variable names into values</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadAll">
            <summary>
            Read all variables from the current stream and store them in a dictionary
            </summary>
            <returns>A dictionary that maps variable names into values</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.Matlab5DataElement(System.String@)">
            <summary>
            Read the next data element from the stream
            </summary>
            <param name="name">On exit, the variable name</param>
            <returns>The data value, as a .NET object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.RemoveRfc1950Header(System.Byte[])">
            <summary>
            Removes the header defined by <a href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</a>
            </summary>
            <param name="bytes"></param>
            <returns>A smaller array of bytes</returns>
            <remarks>
            The header to remove is 2 or 6 bytes at the start, and 4 bytes at the end.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.Parse(MicrosoftResearch.Infer.Utils.MatType,System.String@)">
            <summary>
            Read a specific data type from the stream
            </summary>
            <param name="dataType">The type number as documented by the MAT format</param>
            <param name="name">On exit, the variable name</param>
            <returns>The data value, as a .NET object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.Matlab5Header">
            <summary>
            Read a MAT file header from the stream
            </summary>
            <returns>The header as a string</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadInt">
            <summary>
            Read a 32-bit integer from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadUInt">
            <summary>
            Read an unsigned 32-bit integer from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadInt16">
            <summary>
            Read a 16-bit integer from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadUInt16">
            <summary>
            Read an unsigned 16-bit integer from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadInt64">
            <summary>
            Read a 64-bit integer from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadUInt64">
            <summary>
            Read an unsigned 64-bit integer from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadSingle">
            <summary>
            Read a single-precision float from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadDouble">
            <summary>
            Read a double-precision float from the stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ReadString(System.Int32)">
            <summary>
            Read a string of known length from the stream
            </summary>
            <param name="length">The number of bytes in the string</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.ParseString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an array of bytes into a string
            </summary>
            <param name="bytes">The bytes</param>
            <param name="start">The position of the first character in the string</param>
            <param name="length">An upper bound on the length of the string</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.Dispose">
            <summary>
            Release the stream used by this MatlabReader
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.DataContractSurrogate">
            <summary>
            Allows DataContractSerializer to serialize Vector and Matrix objects
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp">
            <summary>
            Implements nonconjugate VMP messages for multiplying a Gaussian variable (a) with a Beta variable (b)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.damping">
            <summary>
            How much damping to use to prevent improper messages. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'product'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[sum_(a,b) p(a,b) factor(product,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.ProductAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'product'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'product' as the random arguments are varied.
            The formula is <c>proj[sum_(b) p(b) factor(product,a,b)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            Because the factor is deterministic, 'product' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(b) p(b) log(sum_product p(product) factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_B">Previous outgoing message to 'B'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            Because the factor is deterministic, 'product' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(a) p(a) log(sum_product p(product) factor(product,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            The formula is <c>exp(sum_(a) p(a) log(factor(product,a,b)))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' with 'product' integrated out.
            The formula is <c>sum_product p(product) factor(product,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianBetaProductOp">
            <summary>
            Provides outgoing Gaussian messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianBetaProductOp.ProposalDistribution(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Find a proposal distribution - we will use this to set the limits of
            integration
            </summary>
            <param name="y">Gaussian distribution for y</param>
            <param name="a">Gaussian distribution for a</param>
            <param name="b">Beta distribution for b</param>
            <returns>A proposal distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianBetaProductOp.LogisticProposalDistribution(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Find the Laplace approximation for Beta(Logistic(x)) * Gaussian(x))
            </summary>
            <param name="beta">Beta distribution</param>
            <param name="gauss">Gaussian distribution</param>
            <returns>A proposal distribution</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BooleanNotOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Not(System.Boolean)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogAverageFactor(System.Boolean,System.Boolean)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="not">Constant value for 'not'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(not,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogEvidenceRatio(System.Boolean,System.Boolean)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="not">Constant value for 'not'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(not,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.AverageLogFactor(System.Boolean,System.Boolean)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="not">Constant value for 'not'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(not,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.NotAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'not'.
            </summary>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'not' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'not'.
            The formula is <c>int f(not,x) q(x) dx</c> where <c>x = (b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="not">Incoming message from 'not'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (not)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="not"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.BAverageConditional(System.Boolean)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="not">Constant value for 'not'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (not)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="not">Incoming message from 'not'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <param name="to_not">Outgoing message to 'not'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(not,b) p(not,b) factor(not,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="not">Incoming message from 'not'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(not) p(not) factor(not,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="not">Constant value for 'not'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (not,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="not">Incoming message from 'not'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(not) p(not) factor(not,b) / sum_not p(not) messageTo(not))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="not">Constant value for 'not'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(not,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.NotAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'not'.
            </summary>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'not' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'not'.
            The formula is <c>int log(f(not,x)) q(x) dx</c> where <c>x = (b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="not">Incoming message from 'not'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (not)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="not"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.BAverageLogarithm(System.Boolean)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="not">Constant value for 'not'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (not)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (not,b)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MaxGaussianOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Max(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.MaxGaussianOp.ForceProper">
            <summary>
            Static flag to force a proper distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(max,a,b) p(max,a,b) factor(max,a,b))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(max,b) p(max,b) factor(max,a,b))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(max,a) p(max,a) factor(max,a,b))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(max,a,b))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(max,a,b))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(max,a,b))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(max,a,b) p(max,a,b) factor(max,a,b) / sum_max p(max) messageTo(max))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(max,b) p(max,b) factor(max,a,b) / sum_max p(max) messageTo(max))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(max,a) p(max,a) factor(max,a,b) / sum_max p(max) messageTo(max))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(max,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(b) p(b) factor(max,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a) p(a) factor(max,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.MaxAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'max'
            </summary>
            <param name="max">Incoming message from 'max'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'max' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'max' as the random arguments are varied.
            The formula is <c>proj[p(max) sum_(b) p(b) factor(max,a,b)]/p(max)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.MaxAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'max'
            </summary>
            <param name="max">Incoming message from 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'max' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'max' as the random arguments are varied.
            The formula is <c>proj[p(max) sum_(a) p(a) factor(max,a,b)]/p(max)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.MaxAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'max'
            </summary>
            <param name="max">Incoming message from 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'max' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'max' as the random arguments are varied.
            The formula is <c>proj[p(max) sum_(a,b) p(a,b) factor(max,a,b)]/p(max)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(max,b) p(max,b) factor(max,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(b) p(b) factor(max,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(max) p(max) factor(max,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(max,a) p(max,a) factor(max,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(a) p(a) factor(max,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(max) p(max) factor(max,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.BAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.InnerProductOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.InnerProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(innerProduct,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            VMP message to 'innerProduct'
            </summary>
            <param name="AMean">Buffer 'AMean'.</param>
            <param name="AVariance">Buffer 'AVariance'.</param>
            <param name="BMean">Buffer 'BMean'.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <returns>The outgoing VMP message to the 'innerProduct' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'innerProduct' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            VMP message to 'innerProduct'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="BMean">Buffer 'BMean'.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <returns>The outgoing VMP message to the 'innerProduct' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'innerProduct' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            VMP message to 'innerProduct'
            </summary>
            <param name="AMean">Buffer 'AMean'.</param>
            <param name="AVariance">Buffer 'AVariance'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'innerProduct' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'innerProduct' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'BVariance'
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Initial value of buffer 'BVariance'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Update the buffer 'BVariance'
            </summary>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'BMean'
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Initial value of buffer 'BMean'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Update the buffer 'BMean'
            </summary>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AVarianceInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'AVariance'
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <returns>Initial value of buffer 'AVariance'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AVariance(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Update the buffer 'AVariance'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AMeanInit(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Initialise the buffer 'AMean'
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <returns>Initial value of buffer 'AMean'</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AMean(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Update the buffer 'AMean'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="AVariance">Buffer 'AVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="BMean">Buffer 'BMean'.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            Because the factor is deterministic, 'innerProduct' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(b) p(b) log(sum_innerProduct p(innerProduct) factor(innerProduct,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="innerProduct"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'a'.
            The formula is <c>exp(sum_(b) p(b) log(factor(innerProduct,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' with 'innerProduct' integrated out.
            The formula is <c>sum_innerProduct p(innerProduct) factor(innerProduct,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="innerProduct"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'a'
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="AMean">Buffer 'AMean'.</param>
            <param name="AVariance">Buffer 'AVariance'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            Because the factor is deterministic, 'innerProduct' is integrated out before taking the logarithm.
            The formula is <c>exp(sum_(a) p(a) log(sum_innerProduct p(innerProduct) factor(innerProduct,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="innerProduct"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'b'.
            The formula is <c>exp(sum_(a) p(a) log(factor(innerProduct,a,b)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' with 'innerProduct' integrated out.
            The formula is <c>sum_innerProduct p(innerProduct) factor(innerProduct,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="innerProduct"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'b'
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'innerProduct'
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'innerProduct' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'innerProduct' as the random arguments are varied.
            The formula is <c>proj[p(innerProduct) sum_(a,b) p(a,b) factor(innerProduct,a,b)]/p(innerProduct)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(innerProduct,b) p(innerProduct,b) factor(innerProduct,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(innerProduct,a) p(innerProduct,a) factor(innerProduct,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            EP message to 'innerProduct'
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="BMean">Buffer 'BMean'.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <returns>The outgoing EP message to the 'innerProduct' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'innerProduct' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            EP message to 'innerProduct'
            </summary>
            <param name="AMean">Buffer 'AMean'.</param>
            <param name="AVariance">Buffer 'AVariance'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'innerProduct' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'innerProduct' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'a' as the random arguments are varied.
            The formula is <c>proj[p(a) sum_(innerProduct) p(innerProduct) factor(innerProduct,a,b)]/p(a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="innerProduct"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'a'
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'a' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'b' as the random arguments are varied.
            The formula is <c>proj[p(b) sum_(innerProduct) p(innerProduct) factor(innerProduct,a,b)]/p(b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="innerProduct"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'b'
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'b' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(innerProduct,a,b) p(innerProduct,a,b) factor(innerProduct,a,b) / sum_innerProduct p(innerProduct) messageTo(innerProduct))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(innerProduct,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(innerProduct,b) p(innerProduct,b) factor(innerProduct,a,b) / sum_innerProduct p(innerProduct) messageTo(innerProduct))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="BMean">Buffer 'BMean'.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(innerProduct,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(innerProduct,a) p(innerProduct,a) factor(innerProduct,a,b) / sum_innerProduct p(innerProduct) messageTo(innerProduct))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="AMean">Buffer 'AMean'.</param>
            <param name="AVariance">Buffer 'AVariance'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(innerProduct,a,b))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(innerProduct,a,b) p(innerProduct,a,b) factor(innerProduct,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(a,b) p(a,b) factor(innerProduct,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="to_innerProduct">Outgoing message to 'innerProduct'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(innerProduct) p(innerProduct) factor(innerProduct,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="BMean">Buffer 'BMean'.</param>
            <param name="BVariance">Buffer 'BVariance'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(innerProduct,a,b))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="AMean">Buffer 'AMean'.</param>
            <param name="AVariance">Buffer 'AVariance'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(innerProduct,a,b))</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GetItemOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GetItem``1(System.Collections.Generic.IList{``0},System.Int32)"/>, given random arguments to the function.
            This factor gets an item from an array of items
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.LogAverageFactor``1(``0,``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="item">Incoming message from 'item'.</param>
            <param name="to_item">Outgoing message to 'item'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(item) p(item) factor(item,array,index))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.LogAverageFactor``1(`0,System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="index">Constant value for 'index'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(array) p(array) factor(item,array,index))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.LogEvidenceRatio``1(``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="item">Incoming message from 'item'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(item) p(item) factor(item,array,index) / sum_item p(item) messageTo(item))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.LogEvidenceRatio``1(`0,System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="index">Constant value for 'index'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(array) p(array) factor(item,array,index))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ItemAverageConditional``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
            <summary>
            EP message to 'item'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'item' as the random arguments are varied.
            The formula is <c>proj[p(item) sum_(array) p(array) factor(item,array,index)]/p(item)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ArrayAverageConditional``2(``0,System.Int32,``1)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="item">Incoming message from 'item'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(item) p(item) factor(item,array,index)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="item"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ArrayAverageConditional``2(`0,System.Int32,``1)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(item,array,index))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ItemAverageLogarithm``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
            <summary>
            VMP message to 'item'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'item' as the random arguments are varied.
            The formula is <c>proj[sum_(array) p(array) factor(item,array,index)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ArrayAverageLogarithm``2(``0,System.Int32,``1)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="item">Incoming message from 'item'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'item' integrated out.
            The formula is <c>sum_item p(item) factor(item,array,index)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="item"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ArrayAverageLogarithm``2(`0,System.Int32,``1)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GetItem2DOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GetItem2D``1(``0[0:,0:],System.Int32,System.Int32)"/>, given random arguments to the function.
            This factor gets an item from an array of items
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.LogAverageFactor``1(``0,``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="item">Incoming message from 'item'.</param>
            <param name="to_item">Outgoing message to 'item'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(item) p(item) factor(item,array,index1,index2))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.LogAverageFactor``1(`0,MicrosoftResearch.Infer.Collections.IArray2D{``0},System.Int32,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(array) p(array) factor(item,array,index1,index2))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.LogEvidenceRatio``1(``0)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="item">Incoming message from 'item'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(item) p(item) factor(item,array,index1,index2) / sum_item p(item) messageTo(item))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.LogEvidenceRatio``1(`0,MicrosoftResearch.Infer.Collections.IArray2D{``0},System.Int32,System.Int32)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(array) p(array) factor(item,array,index1,index2))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ItemAverageConditional``1(MicrosoftResearch.Infer.Collections.IArray2D{``0},System.Int32,System.Int32,``0)">
            <summary>
            EP message to 'item'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'item' as the random arguments are varied.
            The formula is <c>proj[p(item) sum_(array) p(array) factor(item,array,index1,index2)]/p(item)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ArrayAverageConditional``2(``0,System.Int32,System.Int32,``1)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="item">Incoming message from 'item'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'array' as the random arguments are varied.
            The formula is <c>proj[p(array) sum_(item) p(item) factor(item,array,index1,index2)]/p(array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="item"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ArrayAverageConditional``2(`0,System.Int32,System.Int32,``1)">
            <summary>
            EP message to 'array'
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns>Zero</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(item,array,index1,index2))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ItemAverageLogarithm``1(MicrosoftResearch.Infer.Collections.IArray2D{``0},System.Int32,System.Int32,``0)">
            <summary>
            VMP message to 'item'
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'item' as the random arguments are varied.
            The formula is <c>proj[sum_(array) p(array) factor(item,array,index1,index2)]</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ArrayAverageLogarithm``2(``0,System.Int32,System.Int32,``1)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="item">Incoming message from 'item'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' with 'item' integrated out.
            The formula is <c>sum_item p(item) factor(item,array,index1,index2)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="item"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ArrayAverageLogarithm``2(`0,System.Int32,System.Int32,``1)">
            <summary>
            VMP message to 'array'
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <param name="result">Modified to contain the outgoing message</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'array' conditioned on the given values.
            </para></remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "T:MicrosoftResearch.Infer.Factors.SparseGaussianListOp" -->
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageConditional(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(mean) p(mean) factor(sample,mean,precision)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageConditional(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageConditional(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            EP message to 'precision'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing EP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'precision' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(mean) p(mean) factor(sample,mean,precision)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(sample) p(sample) factor(sample,mean,precision)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(mean,precision) p(mean,precision) factor(sample,mean,precision)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            EP message to 'sample'
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'sample' as the random arguments are varied.
            The formula is <c>proj[p(sample) sum_(precision) p(precision) factor(sample,mean,precision)]/p(sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(sample,precision) p(sample,precision) factor(sample,mean,precision)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageConditional(System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            EP message to 'mean'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'mean' as the random arguments are varied.
            The formula is <c>proj[p(mean) sum_(precision) p(precision) factor(sample,mean,precision)]/p(mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageConditional(System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            EP message to 'precision'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'precision' as the random arguments are varied.
            The formula is <c>proj[p(precision) sum_(mean) p(mean) factor(sample,mean,precision)]/p(precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            EP message to 'precision'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'precision' as the random arguments are varied.
            The formula is <c>proj[p(precision) sum_(sample) p(sample) factor(sample,mean,precision)]/p(precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            EP message to 'precision'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is a distribution matching the moments of 'precision' as the random arguments are varied.
            The formula is <c>proj[p(precision) sum_(sample,mean) p(sample,mean) factor(sample,mean,precision)]/p(precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,precision))</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,mean) p(sample,mean) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(precision) p(precision) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(mean,precision) p(mean,precision) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,precision) p(sample,precision) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's average value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,mean,precision) p(sample,mean,precision) factor(sample,mean,precision))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,mean) p(sample,mean) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample) p(sample) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(mean) p(mean) factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(precision) p(precision) factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(mean,precision) p(mean,precision) factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,mean,precision) p(sample,mean,precision) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Evidence message for EP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_sample">Outgoing message to 'sample'.</param>
            <returns>Logarithm of the factor's contribution the EP model evidence</returns>
            <remarks><para>
            The formula for the result is <c>log(sum_(sample,precision) p(sample,precision) factor(sample,mean,precision) / sum_sample p(sample) messageTo(sample))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for EP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageLogarithm(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageLogarithm(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(mean,precision) p(mean,precision) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(sample,precision) p(sample,precision) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.SampleAverageLogarithm(System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sample' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'sample'.
            The formula is <c>exp(sum_(precision) p(precision) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.MeanAverageLogarithm(System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList,MicrosoftResearch.Infer.Distributions.SparseGaussianList)">
            <summary>
            VMP message to 'mean'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'mean' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'mean'.
            The formula is <c>exp(sum_(precision) p(precision) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageLogarithm(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            VMP message to 'precision'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing VMP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'precision' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            VMP message to 'precision'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'precision'.
            The formula is <c>exp(sum_(sample,mean) p(sample,mean) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            VMP message to 'precision'
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing VMP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'precision'.
            The formula is <c>exp(sum_(sample) p(sample) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.PrecisionAverageLogarithm(System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            VMP message to 'precision'
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'precision' argument</returns>
            <remarks><para>
            The outgoing message is the exponential of the average log-factor value, where the average is over all arguments except 'precision'.
            The formula is <c>exp(sum_(mean) p(mean) log(factor(sample,mean,precision)))</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,mean,precision) p(sample,mean,precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(precision) p(precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample) p(sample) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(mean) p(mean) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(mean,precision) p(mean,precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double},MicrosoftResearch.Infer.Distributions.SparseGammaList)">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,precision) p(sample,precision) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGaussianListOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.SparseGaussianList,MicrosoftResearch.Infer.Distributions.SparseGaussianList,System.Collections.Generic.IList{System.Double})">
            <summary>
            Evidence message for VMP
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Average of the factor's log-value across the given argument distributions</returns>
            <remarks><para>
            The formula for the result is <c>sum_(sample,mean) p(sample,mean) log(factor(sample,mean,precision))</c>.
            Adding up these values across all factors and variables gives the log-evidence estimate for VMP.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp_JJ96">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromLogOdds(System.Double)"/>, given random arguments to the function.
            </summary> 
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp_JJ96.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Fixed value for sample</param>
            <param name="logOdds">Incoming message from logOdds</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp_JJ96.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from sample</param>
            <param name="logOdds">Incoming message from logOdds</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp_JJ96.LogOddsAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to LogOdds
            </summary>
            <param name="sample">Fixed value for sample</param>
            <param name="logOdds">Incoming message from logOdds</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'logOdds'.
            The formula is <c>int log(f(logOdds,x)) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp_JJ96.LogOddsAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to LogOdds
            </summary>
            <param name="sample">Incoming message from sample</param>
            <param name="logOdds">Incoming message from logOdds</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'logOdds'.
            The formula is <c>int log(f(logOdds,x)) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp_SJ99">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromLogOdds(System.Double)"/>, given random arguments to the function.
            Uses a generalisation of the bound from Saul and Jordan (1999). 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp_SJ99.LogOddsAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to LogOdds
            </summary>
            <param name="sample">Incoming message from sample</param>
            <param name="logOdds">Incoming message from logOdds</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'logOdds'.
            The formula is <c>int log(f(logOdds,x)) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromLogOdds(System.Double)"/>, given random arguments to the function.
            Performs KL minimisation using gradient matching, a distributed gradient descent algorithm. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogOddsAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'logOdds'.
            </summary>
            <param name="sample">Constant value for sample.</param>
            <param name="logOdds">Incoming message from 'logOdds'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'logOdds' argument.</returns>
            <remarks><para>
            The outgoing message is the moment matched Gaussian approximation to the factor.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogOddsAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'logOdds'.
            </summary>
            <param name="sample">Incoming message from sample.</param>
            <param name="logOdds">Incoming message from 'logOdds'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'logOdds' argument.</returns>
            <remarks><para>
            The outgoing message is the moment matched Gaussian approximation to the factor.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogAverageFactor(System.Boolean,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logOdds">Constant value for 'logOdds'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logOdds">Incoming message from 'logOdds'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogEvidenceRatio(System.Boolean,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logOdds">Constant value for 'logOdds'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logOdds">Incoming message from 'logOdds'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="logOdds">Incoming message from 'logOdds'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the moment matched Gaussian approximation to the factor.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.AverageLogFactor(System.Boolean,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Fixed value for sample</param>
            <param name="logOdds">Fixed value for logOdds</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from sample</param>
            <param name="logOdds">Fixed value for logOdds</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logOdds">Incoming message from 'logOdds'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="logOdds">Incoming message from 'logOdds'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to sample
            </summary>
            <param name="logOdds">Incoming message from logOdds</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.SampleAverageLogarithm(System.Double)">
            <summary>
            VMP message to 'sample'
            </summary>
            <param name="logOdds">Fixed value for logOdds</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogOddsAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gradient matching VMP message from factor to logOdds variable
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logOdds">Incoming message. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="to_LogOdds">Previous message sent, used for damping</param>
            <returns>The outgoing VMP message.</returns>
            <remarks><para>
            The outgoing message is the Gaussian approximation to the factor which results in the 
            same derivatives of the KL(q||p) divergence with respect to the parameters of the posterior
            as if the true factor had been used.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logOdds"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogOddsAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gradient matching VMP message from factor to logOdds variable
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="logOdds">Incoming message. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Previous message sent, used for damping</param>
            <returns>The outgoing VMP message.</returns>
            <remarks><para>
            The outgoing message is the Gaussian approximation to the factor which results in the 
            same derivatives of the KL(q||p) divergence with respect to the parameters of the posterior
            as if the true factor had been used.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logOdds"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList">
            <summary>
            Represents a list of Bernoulli distributions, optimised for the case where many share 
            the same probability of being true.
            This class can be used as a distribution over a fixed-sized list of booleans or sparsely 
            as a distribution over a variable-sized list of integers, which are the indices of elements 
            in the boolean list with value 'true'.
            </summary>
            <remarks>
            One use for this class is as a distribution over subsets of a set of objects.
            </remarks>
            TODO: operators
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase">
            <summary>
            Base class for <see cref="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset"/> and <see cref="T:MicrosoftResearch.Infer.Distributions.SparseBernoulliList"/>.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.GetProbTrue(System.Int32)">
            <summary>
            Gets the probability of the binary variable being true
            </summary>
            <returns>p(x=true)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.SetProbTrue(System.Int32,System.Double)">
            <summary>
            Sets the probability of the binary variable being true
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.GetProbFalse(System.Int32)">
            <summary>
            Gets the probability of the binary variable being false
            </summary>
            <returns>p(x=false)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.SetProbFalse(System.Int32,System.Double)">
            <summary>
            Sets the probability of the binary variable being false
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.SetToUniform">
            <summary>
            Sets all Bernoulli elements to uniform.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.IsUniform">
            <summary>
            Tests if all Bernoulli elements are uniform.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.MaxDiff(System.Object)">
            <summary>
            The maximum 'difference' between this instance and that instance.
            This returns the maximum absolute difference between the Log-odds of any element
            </summary>
            <param name="that">The other distribution</param>
            <returns>The resulting maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.GetProbTrueVector">
            <summary>
            Gets a vector of P(true) values.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.SetProbTrueVector(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Gets a vector of P(true) values.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.GetLogProbTrueVector">
            <summary>
            Gets a vector of log P(true) values.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.GetLogProbFalseVector">
            <summary>
            Gets a vector of log P(false) values.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.LogOddsVector">
            <summary>
            The sparse vector holding the log odds of each Bernoulli in the list
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.Count">
            <summary>
            The number of elements in the list
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.Item(System.Int32)">
            <summary>Gets or sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseBernoulliListBase.IsPointMass">
            <summary>
            Whether all the Bernoulli elements are point masses
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.DefaultSparsity">
            <summary>
            Default sparsity specification for this distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.#ctor">
            <summary>
            Parameterless constructor required for serialization 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.#ctor(System.Int32)">
            <summary>
            Creates a list of Bernoullis of the specified size, each set to uniform.
            </summary>
            <param name="size">The size of the list</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.#ctor(System.Int32,System.Double)">
            <summary>
            Creates a list of Bernoullis of the specified size, each set to have the specified probability of being true.
            </summary>
            <param name="size">The size of the list</param>
            <param name="probTrue">The probability of each Bernoulli being true</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.#ctor(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a list of Bernoullis using the supplied vector of log odds (which will *not* be cloned).
            </summary>
            <param name="logOddsVector">The log odds vector to use internally</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.ToString">
            <summary>
            Returns a human readable string form of this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.ToArray">
            <summary>
            Converts this sparse array to an ordinary dense .NET array.
            </summary>
            <returns>A .NET array of Bernoulli values</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.Clone">
            <summary>
            Clones this sparse Bernoulli list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.GetLogProb(System.Collections.Generic.IList{System.Boolean})">
            <summary>
            Evaluates the logarithm of the density function
            </summary>
            <param name="value">a list of boolean values</param>
            <returns>Log of the probability density for the given event</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.Sample">
            <summary>
            Samples a list of booleans from this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.Sample(System.Collections.Generic.IList{System.Boolean})">
            <summary>
            Samples a list of booleans from this distribution, using the supplied list for storage.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.Sample(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Samples from a list of Bernoulli distributions with the specified vector of P(true) values
            </summary>
            <param name="probsTrue">the vector of P(true) values</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.SetToProduct(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>
            Sets this list to the elementwise product of the two supplied lists.
            </summary>
            <param name="a">The first list</param>
            <param name="b">The second list</param>
            <returns>The resulting list of Bernoulli distributions</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.SetTo(MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>
            Sets this lists to copy the state of another list (which must be the same size).
            </summary>
            <param name="otherList">The list to copy</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.SparseBernoulliList,System.Double,MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>
            Sets this sparse Bernoulli list to the weighted sum of two others (which must be of the same size)
            </summary>
            <param name="weight1"></param>
            <param name="value1"></param>
            <param name="weight2"></param>
            <param name="value2"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.SetToRatio(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,MicrosoftResearch.Infer.Distributions.SparseBernoulliList,System.Boolean)">
            <summary>
            Sets this sparse Bernoulli list to the ratio of two others (which must be of the same size)
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.SetToPower(MicrosoftResearch.Infer.Distributions.SparseBernoulliList,System.Double)">
            <summary>
            Sets this sparse Bernoulli list to the power of another (which must be of the same size)
            </summary>
            <param name="value"></param>
            <param name="exponent"></param>
            <remarks>Not yet implemented</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>
            Gets the integral of the product of two sparse Bernoulli list distributions.
            </summary>
            <remarks>Not yet implemented</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.GetAverageLog(MicrosoftResearch.Infer.Distributions.SparseBernoulliList)">
            <summary>
            Gets the expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseBernoulliList.Point">
            <summary>
            Gets/sets the distribution as a point value boolean array
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset">
            <summary>
            Represents a list of Bernoulli distributions considered as a distribution over a variable-sized list of
            integers, which are the indices of elements in the boolean list with value 'true'
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(System.Int32)">
            <summary>
            Creates a list of Bernoullis of the specified size, each set to uniform.
            </summary>
            <param name="size">The size of the list</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(System.Int32,System.Double)">
            <summary>
            Creates a list of Bernoullis of the specified size, each set to have the specified probability of being true.
            </summary>
            <param name="size">The size of the list</param>
            <param name="probTrue">The probability of each Bernoulli being true</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.#ctor(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a list of Bernoullis using the supplied vector of log odds (which will *not* be cloned).
            </summary>
            <param name="logOddsVector">The log odds vector to use internally</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.GetLogProb(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Gets the log probability of the given value under this distribution
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Clone">
            <summary>
            Clones this object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Sample">
            <summary>
            Samples a list of ints from this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Sample(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Samples a list of ints from this distribution
            </summary>
            <param name="result">Where to put the resulting sample</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Sample(MicrosoftResearch.Infer.Maths.SparseVector)">
            <summary>
            Samples from a list of Bernoulli distributions with the specified vector of P(true) values
            </summary>
            <param name="probsTrue">the vector of P(true) values</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SetToProduct(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            Sets this BernoulliIntegerSubset distribution to a product of two other such distributions
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SetTo(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            Sets this BernoulliIntegerSubset distribution to another such distribution
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SetToPower(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,System.Double)">
            <summary>
            Sets this BernoulliIntegerSubset distribution to the power another such distribution
            </summary>
            <param name="value"></param>
            <param name="exponent"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SetToRatio(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,System.Boolean)">
            <summary>
            Sets this BernoulliIntegerSubset distribution to the ratio of two other such distributions
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset,System.Double,MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            Sets this BernoulliIntegerSubset distribution to the weighted sum of two other such distributions
            </summary>
            <param name="weight1"></param>
            <param name="value1"></param>
            <param name="weight2"></param>
            <param name="value2"></param>
            <remarks>Not yet implemented</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            Gets the log of the integral of the product of this BernoulliIntegerSubset distribution and another such distribution
            </summary>
            <param name="that"></param>
            <returns></returns>
            <remarks>Not yet implemented</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.GetAverageLog(MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.BernoulliIntegerSubset.Point">
            <summary>
            Gets/sets the distribution as a point value int array. This is a sparse method - the ints specify
            the indices where elements are true - all other elements are false.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ParallelCursorArray`2">
            <summary>
            A multidimensional array of objects where each field is in a CursorArray.
            </summary>
            <typeparam name="CursorType"></typeparam>
            <typeparam name="ArrayType">A cursor-based array type, such as CursorArray or ParallelCursorArray.</typeparam>
            <remarks><para>
            A ParallelCursorArray is meant to behave like an ordinary Array, while 
            being more memory-efficient.  It uses a cursor similar to a CursorArray.
            However, the storage layout is different.  Each field of the cursor
            is stored in a separate ICursorArray, with its own inner cursor.
            By advancing these inner cursors, the outer cursor is automatically
            updated.  Thus <typeparamref name="CursorType"/> does not need to implement <c>ICursor</c>.
            For example, <typeparamref name="CursorType"/> might be <c>Array&lt;ICursor&gt;</c>, holding an array of  
            inner cursors.
            </para><para>
            There must be at least one member array, and 
            all member arrays must have the same dimensions.
            </para></remarks>
            <example>See CursorArrayTest.cs.</example>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ParallelCursorArray`2.#ctor(`0,System.Collections.Generic.IList{`1})">
            <summary>
            Create a new ParallelCursorArray.
            </summary>
            <param name="cursor">An object to use as the cursor.</param>
            <param name="members">A list of cursor-based arrays.</param>
            <remarks>
            <paramref name="cursor"/> must already be initialized to contain
            the cursors of the arrays in <paramref name="members"/>.
            There must be at least one member array, and 
            all member arrays must have the same dimensions.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix">
            <summary>
            Upper triangular matrix class
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a zero matrix of the given dimensions.
            </summary>
            <param name="nRows">Number of rows >= 0.</param>
            <param name="nCols">Number of columns >= 0.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.#ctor(System.Int32,System.Int32,System.Double[])">
            <summary>
            Constructs a matrix by referencing an array.
            </summary>
            <param name="nRows">Number of rows.</param>
            <param name="nCols">Number of columns.</param>
            <param name="data">Storage for the matrix elements.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Constructs a matrix from data in a 2D array.
            </summary>
            <param name="data">2D array of elements.</param>
            <remarks>The 2D array is copied into new storage.
            The size of the matrix is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.Clone">
            <summary>
            Creates a full clone of this upper triangular matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.CheckUpperTriangular">
            <summary>
            Check that this matrix is upper triangular
            </summary>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.TransposeInPlace(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Transposes a given lower triangular matrix in place.
            </summary>
            <param name="L">Matrix to transpose.  Contents are corrupted on exit.</param>
            <returns>An upper triangular wrapper of L's source array.</returns>
            <remarks>L is no longer a valid lower triangular matrix.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.Transpose">
            <summary>
            Return the transpose of this upper triangular matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.ProdDiag">
            <summary>
            Returns the product of diagonal elements.
            </summary>
            <returns><c>prod(diag(this))</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.Determinant">
            <summary>
            Returns the determinant of this upper-triangular matrix.
            </summary>
            <returns>The determinant of this.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.TraceLn">
            <summary>
            Returns the sum of the logarithm of diagonal elements.
            </summary>
            <returns><c>sum(log(diag(this)))</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.LogDeterminant">
            <summary>
            Returns the natural logarithm of the determinant of this upper-triangular matrix.
            </summary>
            <returns>The log-determinant of this.</returns>
        </member>
    </members>
</doc>
